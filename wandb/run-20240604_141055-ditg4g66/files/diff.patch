diff --git a/games/breakout/breakout_env.py b/games/breakout/breakout_env.py
index 7b9d929..c3bbb54 100644
--- a/games/breakout/breakout_env.py
+++ b/games/breakout/breakout_env.py
@@ -2,31 +2,43 @@ import gym
 from gym import spaces
 import numpy as np
 import pygame
-from paddle import Paddle
-from ball import Ball
-from scoreboard import Scoreboard
-from ui import UI
-from bricks import Bricks
+from games.breakout.paddle import Paddle
+from games.breakout.ball import Ball
+from games.breakout.scoreboard import Scoreboard
+from games.breakout.ui import UI
+from games.breakout.bricks import Bricks
 import time
+import torch
+from torch_geometric.data import Data, HeteroData 
+import networkx as nx
+from games.encoder.GraphEncoder import GraphConverter
 
 class BreakoutEnv(gym.Env):
     """Custom Environment that follows gym interface"""
     metadata = {'render.modes': ['human']}
 
-    def __init__(self):
+    def __init__(self, num_frames=4):
         super(BreakoutEnv, self).__init__()
         # Define action and observation space
         # They must be gym.spaces objects
         # Example when using discrete actions:
+        self.num_frames = num_frames
+        self.observation_space = spaces.Box(low=0, high=255,
+                                            shape=(600, 1200, 3 * num_frames),  # Stack frames along the channel dimension
+                                            dtype=np.uint8)
+        self.proximity_threshold = 50  # Example threshold for proximity
         self.action_space = spaces.Discrete(3)  # actions: move left, stay, move right
         # Example for observation space: the game state
         self.observation_space = spaces.Box(low=0, high=255, shape=(600, 1200, 3), dtype=np.uint8)
         self.screen_width = 1200
         self.screen_height = 600
         self.screen = pygame.display.set_mode((self.screen_width, self.screen_height))
-        pygame.display.set_caption('Breakout')
+        pygame.display.set_caption('Breakout') 
+
         pygame.init()
         self.clock = pygame.time.Clock()
+        self.frame_buffer = np.zeros((self.screen_height, self.screen_width, 3 * num_frames), dtype=np.uint8)
+
         
 
     def reset(self):
@@ -40,8 +52,12 @@ class BreakoutEnv(gym.Env):
         self.bricks.draw()
         self.scoreboard.draw()
         self.ui.header()
+        initial_state = self.get_state()
+        for i in range(self.num_frames):
+            start_idx = i * 3
+            self.frame_buffer[:, :, start_idx:start_idx + 3] = initial_state
+        return self.frame_buffer
 
-        return self.get_state()    
 
     def check_collision_with_walls(self, ball, score, ui):
         reward = 0
@@ -126,13 +142,15 @@ class BreakoutEnv(gym.Env):
         reward += self.check_collision_with_walls(self.ball, self.scoreboard, self.ui)
         reward += self.check_collision_with_paddle(self.ball, self.paddle)
         reward += self.check_collision_with_bricks(self.ball, self.scoreboard, self.bricks)
-
+        new_frame = self.get_state()
+        # Update the frame buffer
+        self.update_frame_buffer(new_frame)
         # Draw all game elements
         self.paddle.draw()
         self.ball.draw()
         self.bricks.draw()
         self.scoreboard.draw()
-
+        self.get_graph_data()
         # Check if game over
         done = self.scoreboard.lives == 0 or len(self.bricks.bricks) == 0
 
@@ -142,17 +160,108 @@ class BreakoutEnv(gym.Env):
         # Additional info can be passed, though not used here
         info = {}
 
-        return self.get_state(), reward, done, info
+        return self.frame_buffer, reward, done, info
+    
+
+   
+
+
+    def check_proximity(self, rect1, rect2, d=50):
+        # Dummy implementation for proximity check
+        return np.linalg.norm(np.array([rect1['x'], rect1['y']]) - np.array([rect2['x'], rect2['y']])) < d
+
+    def check_adjacent(self, rect1, rect2, d=50):
+        # Dummy implementation for adjacency check
+        return np.linalg.norm(np.array([rect1['x'], rect1['y']]) - np.array([rect2['x'], rect2['y']])) < d
+
+    def get_graph_data(self):
+        # Initialize a NetworkX graph
+        graph = nx.Graph()
+
+        # Define object features and add nodes
+        ball_features = [self.ball.rect.x, self.ball.rect.y, self.ball.x_move_dist, self.ball.y_move_dist, 1, 0, 0]
+        graph.add_node("ball", type="object", features=ball_features)
+
+        paddle_features = [self.paddle.rect.x, self.paddle.rect.y, 0, 0, 0, 1, 0]
+        graph.add_node("paddle", type="object", features=paddle_features)
 
+        brick_features = [[brick.rect.x, brick.rect.y, 0, 0, 0, 0, 1] for brick in self.bricks.bricks]
+        for i, features in enumerate(brick_features):
+            graph.add_node(f"brick_{i}", type="object", features=features)
 
+        # Combine object positions
+        object_positions = {
+            "ball": ball_features[:2],
+            "paddle": paddle_features[:2],
+        }
+        for i, features in enumerate(brick_features):
+            object_positions[f"brick_{i}"] = features[:2]
+        # Proximity threshold for creating atoms
+        proximity_threshold = self.proximity_threshold
+
+        # Create atom nodes and edges based on proximity and adjacency
+        atom_index = len(object_positions)  # Start indexing atoms after all objects
+        standard_feature_vector_size = len(ball_features)
+        empty_feature_vector = [0] * (2 * standard_feature_vector_size)
+
+
+        # Add proximity atoms and edges for ball and bricks
+        for i, brick in enumerate(self.bricks.bricks):
+            if self.check_proximity(self.ball, brick, d=50):
+                atom_node = f"Proximity_Ball_Brick_{i}_{atom_index}"
+                graph.add_node(atom_node, type="atom", features=empty_feature_vector, predicate="Proximity")
+                graph.add_edge("ball", atom_node, position=0)
+                graph.add_edge(f"brick_{i}", atom_node, position=1)
+                atom_index += 1
+        # Add proximity atoms and edges for paddle and ball
+        if self.check_proximity(self.ball, self.paddle, d=50):
+            atom_node = f"Proximity_Ball_Paddle_{atom_index}"
+            graph.add_node(atom_node, type="atom",features=empty_feature_vector, predicate="Proximity")
+            graph.add_edge("ball", atom_node, position=0)
+            graph.add_edge("paddle", atom_node, position=1)
+            atom_index += 1
+
+        # Add adjacent atoms and edges (bricks with bricks)
+        for i, brick1 in enumerate(self.bricks.bricks):
+            for j, brick2 in enumerate(self.bricks.bricks):
+                if i != j and self.check_adjacent(brick1, brick2, d=5):
+                    atom_node = f"Adjacent_Bricks_{i}_{j}_{atom_index}"
+                    graph.add_node(atom_node, type="atom", features=empty_feature_vector,predicate="Adjacent")
+                    graph.add_edge(f"brick_{i}", atom_node, position=0)
+                    graph.add_edge(f"brick_{j}", atom_node, position=1)
+                    atom_index += 1
+
+        # Create a GraphConverter object
+        converter = GraphConverter()
+
+        # Convert the NetworkX graph to a PyG Data object
+        data = converter.to_pyg_data(graph)
+        return data
+
+    def check_collision(self, rect1, rect2):
+        return rect1.colliderect(rect2)
+    
+    def check_proximity(self, obj1, obj2, d):
+        center1 = obj1.rect.center
+        center2 = obj2.rect.center
+        distance = np.sqrt((center1[0] - center2[0])**2 + (center1[1] - center2[1])**2)
+        return distance < d
+    
+    def check_directional_influence(self, rect1, rect2, theta):
+        # Check if rect1 is moving towards rect2 within a given angle theta
+        # Simplified for demonstration
+        return True  # Add your own logic here
     
+    def check_adjacent(self, rect1, rect2, d):
+        return self.check_proximity(rect1, rect2, d)
+
 
     def render(self, mode='human'):
 
         pass # update turtle graphics if needed
 
     def close(self):
-        tr.bye()
+        pygame.quit()
 
     def check_collisions(self):
         # Implement collision checks
@@ -162,9 +271,17 @@ class BreakoutEnv(gym.Env):
         return reward
 
     def get_state(self):
-        # Implement a method to extract the current game state
-        # This might include positions of the paddle, ball, bricks, etc.
-        return pygame.surfarray.array3d(pygame.display.get_surface())
+        # Get the surface array from Pygame
+        surface_array = pygame.surfarray.array3d(pygame.display.get_surface())
+        # Transpose the array from (width, height, channels) to (height, width, channels)
+        transposed_array = np.transpose(surface_array, axes=(1, 0, 2))
+        return transposed_array 
+    
+    def update_frame_buffer(self, new_frame):
+        # Shift frames to the left in the buffer and append the new frame on the right
+        # Ensure that the new_frame is transposed before being added to the frame buffer
+        self.frame_buffer = np.roll(self.frame_buffer, shift=-3, axis=2)
+        self.frame_buffer[:, :, -3:] = new_frame
     
 if __name__ == "__main__":
     env = BreakoutEnv()
diff --git a/games/freeway/freeway_envs/freeway_env.py b/games/freeway/freeway_envs/freeway_env.py
index 3b2577b..7943cce 100644
--- a/games/freeway/freeway_envs/freeway_env.py
+++ b/games/freeway/freeway_envs/freeway_env.py
@@ -6,10 +6,11 @@ from gymnasium import spaces
 import torch
 import torch_geometric
 from torch_geometric.data import Data
-
+from ...encoder.GraphEncoder import GraphConverter
+import networkx as nx
 
 class FreewayEnv(gym.Env):
-    metadata = {'render.modes': ['human']}
+    metadata = {'render.modes': ['human', 'rgb_array']}
 
     def __init__(self):
         super(FreewayEnv, self).__init__()
@@ -27,15 +28,15 @@ class FreewayEnv(gym.Env):
         # Actions: 0 - Stay, 1 - Move Up, 2 - Move Down
         self.action_space = spaces.Discrete(3)
         self.observation_space = spaces.Box(low=0, high=255,
-                                            shape=(self.window_height, self.window_width, 3),
+                                            shape=(self.window_height, self.window_width, 3 * self.frame_stack),
                                             dtype=np.uint8)
-
         # Load images
         self.window = pygame.display.set_mode((self.window_width, self.window_height))
 
-        self.background_image = pygame.transform.scale(pygame.image.load("../../images/Atari - background.png"), (self.window_width, self.window_height))
-        self.player_image = pygame.transform.scale(pygame.image.load("../../images/chicken.png").convert_alpha(), (self.player_width, self.player_height))
-        self.car_image = pygame.transform.scale(pygame.image.load("../../images/car2.png").convert_alpha(), (self.car_width, self.car_height))
+        self.background_image = pygame.transform.scale(pygame.image.load("games/images/Atari - background.png"), (self.window_width, self.window_height))
+        self.player_image = pygame.transform.scale(pygame.image.load("games/images/chicken.png").convert_alpha(), (self.player_width, self.player_height))
+        self.car_image = pygame.transform.scale(pygame.image.load("games/images/car2.png").convert_alpha(), (self.car_width, self.car_height))
+        self.frame_buffer = np.zeros((self.window_height, self.window_width, 3 * self.frame_stack), dtype=np.uint8)
 
         self.clock = pygame.time.Clock()
 
@@ -51,6 +52,7 @@ class FreewayEnv(gym.Env):
                     'speed': random.randint(2, 5)} for _ in range(20)]
         self.done = False
         self.episode_start_time = pygame.time.get_ticks()
+        self.frame_buffer = np.zeros((self.window_height, self.window_width, 3 * self.frame_stack), dtype=np.uint8)
         return self.get_observation()
 
     def step(self, action):
@@ -82,57 +84,73 @@ class FreewayEnv(gym.Env):
         graph_data = self.get_graph_data()
 
         return self.get_observation(), self.score, self.done, {}
-    
+            
     def get_graph_data(self):
-        # Node features for chicken, lanes, and cars
-        chicken_node = [self.player_rect['x'], self.player_rect['y'],5, 1, 0, 0]
-        lane_nodes = [[0, lane, 0, 0, 0, 1, 0] for lane in self.lanes]
-        car_nodes = [[car['x'], car['lane'], car['speed'], 0, 0, 1] for car in self.cars]
-
-        # Combine all nodes into a single feature matrix
-        features = torch.tensor([chicken_node] + lane_nodes + car_nodes, dtype=torch.float)
+        # Initialize a NetworkX graph
+        graph = nx.Graph()
+
+        # Define object features and add nodes
+        chicken_features = [self.player_rect.x, self.player_rect.y, 5, 1, 0, 0]
+        graph.add_node("chicken", type="object", features=chicken_features)
+        
+        lane_features = [[0, lane, 0, 0, 1, 0] for lane in self.lanes]
+        for i, features in enumerate(lane_features):
+            graph.add_node(f"lane_{i}", type="object", features=features)
+
+        car_features = [[car['x'], car['lane'], car['speed'], 0, 0, 1] for car in self.cars]
+        for i, features in enumerate(car_features):
+            graph.add_node(f"car_{i}", type="object", features=features)
+
+        # Combine object positions
+        object_positions = {
+            "chicken": chicken_features[:2],
+        }
+        for i, lane in enumerate(self.lanes):
+            object_positions[f"lane_{i}"] = lane_features[i][:2]
+        for i, car in enumerate(self.cars):
+            object_positions[f"car_{i}"] = car_features[i][:2]
 
-        # Create edges and edge attributes
-        edge_index = []
-        edge_features = []
 
-        # Atom nodes: one for each predicate that might hold true
-        atom_features = []
-        atom_index = len(features)  # Start indexing atoms after all objects
+        # Create atom nodes and edges based on proximity
+        atom_index = len(object_positions)  # Start indexing atoms after all objects
+        standard_feature_vector_size = len(chicken_features)
+        empty_feature_vector = [0] *(2* standard_feature_vector_size)
 
         # Add ChickenOnLane atoms and edges
         for i, lane in enumerate(self.lanes):
-            if self.player_rect['y'] == lane:
-                atom_features.append([0, 0, 0, 0, 1])  # Feature vector for the ChickenOnLane atom
-                edge_index.extend([[0, atom_index], [atom_index, i+1]])
-                edge_features.extend([[1, 0, 0], [1, 0, 0]])
-                atom_index += 1
+            # check if the chicken is in the range of the lane of +-50
+                if self.player_rect.y >= lane - 50 and self.player_rect.y <= lane + 50:
+                    atom_node = f"ChickenOnLane_{atom_index}"
+                    graph.add_node(atom_node, type="atom", features=empty_feature_vector, predicate="ChickenOnLane")
+                    graph.add_edge("chicken", atom_node, position=0)
+                    graph.add_edge(f"lane_{i}", atom_node, position=1)
+                    atom_index += 1
 
         # Add CarOnLane atoms and edges
         num_lanes = len(self.lanes)
         for i, car in enumerate(self.cars, start=num_lanes + 1):
-            car_lane_index = self.lanes.index(car['lane']) + 1
-            atom_features.append([0, 0, 0, 0, 1])  # Feature vector for the CarOnLane atom
-            edge_index.extend([[i, atom_index], [atom_index, car_lane_index]])
+            car_lane_index = self.lanes.index(car['lane'])
+            atom_node = f"CarOnLane_{atom_index}"
+            graph.add_node(atom_node, type="atom",features=empty_feature_vector, predicate="CarOnLane")
+            graph.add_edge(f"car_{i - num_lanes - 1}", atom_node, position=0)
+            graph.add_edge(f"lane_{car_lane_index}", atom_node, position=1)
             atom_index += 1
 
         # Add LaneNextToLane atoms and edges
         for i in range(num_lanes - 1):
-            atom_features.append([0]*2*len(chicken_node))  # Feature vector for the LaneNextToLane atom
-            edge_index.extend([[i + 1, atom_index], [atom_index, i + 2]])
-            edge_features.extend([[0, 0, 1], [0, 0, 1]])
+            atom_node = f"LaneNextToLane_{atom_index}"
+            graph.add_node(atom_node, type="atom",features=empty_feature_vector, predicate="LaneNextToLane")
+            graph.add_edge(f"lane_{i}", atom_node, position=0)
+            graph.add_edge(f"lane_{i + 1}", atom_node, position=1)
             atom_index += 1
 
-        # Concatenate all features and convert to tensors
-        all_features = torch.cat([features, torch.tensor(atom_features, dtype=torch.float)], dim=0)
-        edge_index = torch.tensor(edge_index, dtype=torch.long).t().contiguous()
-        edge_attr = torch.tensor(edge_features, dtype=torch.float)
+        # Create a GraphConverter object
+        converter = GraphConverter()
 
-        # Create the PyTorch Geometric Data object
-        data = Data(x=all_features, edge_index=edge_index, edge_attr=edge_attr)
+        # Convert the NetworkX graph to a PyG Data object
+        data = converter.to_pyg_data(graph)
         return data
-            
-
+    
     def render(self, mode='human'):
         self.window.blit(self.background_image, (0, 0))
         for car in self.cars:
@@ -141,9 +159,13 @@ class FreewayEnv(gym.Env):
         pygame.display.update()
 
     def get_observation(self):
-        # Optionally return a screenshot of the game as an observation
         # You can also choose to return other representations of the game state
-        return np.array(pygame.surfarray.array3d(pygame.display.get_surface()))
+        frame = pygame.surfarray.array3d(pygame.display.get_surface())
+        frame = frame.transpose((1, 0, 2))  # Correct the shape to (height, width, channels)
+        # Update frame buffer
+        self.frame_buffer = np.roll(self.frame_buffer, -3, axis=2)
+        self.frame_buffer[:, :, -3:] = frame
+        return self.frame_buffer
 
     def close(self):
         pygame.quit()
Submodule games/pacman contains modified content
diff --git a/games/pacman/.gitignore b/games/pacman/.gitignore
deleted file mode 100644
index 574e611..0000000
--- a/games/pacman/.gitignore
+++ /dev/null
@@ -1,67 +0,0 @@
-# Byte-compiled / optimized / DLL files
-__pycache__/
-*.py[cod]
-*$py.class
-
-# C extensions
-*.so
-
-# Distribution / packaging
-.Python
-venv/
-build/
-develop-eggs/
-dist/
-downloads/
-eggs/
-.eggs/
-lib/
-lib64/
-parts/
-sdist/
-var/
-*.egg-info/
-.installed.cfg
-*.egg
-MANIFEST
-MANIFEST.in
-
-# PyInstaller
-#  Usually these files are written by a python script from a template
-#  before PyInstaller builds the exe, so as to inject date/other infos into it.
-*.manifest
-*.spec
-
-# Installer logs
-pip-log.txt
-pip-delete-this-directory.txt
-
-# Unit test / coverage reports
-htmlcov/
-.tox/
-.coverage
-.coverage.*
-.cache
-nosetests.xml
-coverage.xml
-*,cover
-.hypothesis/
-
-# Translations
-*.mo
-*.pot
-
-# Django stuff:
-*.log
-
-# Sphinx documentation
-docs/_build/
-
-# PyBuilder
-target/
-
-# pyenv python configuration file
-.python-version
-
-#pycharm
-.idea*
diff --git a/games/pacman/README.md b/games/pacman/README.md
deleted file mode 100644
index 97dbc8a..0000000
--- a/games/pacman/README.md
+++ /dev/null
@@ -1,17 +0,0 @@
-# Pacman
-Classic pacman game built in python using pygame
-
-<img alt="pacman gameplay" src="https://github.com/shivammathur/pacman/raw/master/images/play.png" width="42%"> <img alt="win pacman game" src="https://github.com/shivammathur/pacman/raw/master/images/win.png" width="42%">
-
-## Setup
-```shell script
-pip install requirements.txt
-```
-
-## Run
-```shell script
-python pacman.py   
-```
-
-## References
-https://github.com/hbokmann/Pacman - Improved code and UI
\ No newline at end of file
diff --git a/games/pacman/pacman.py b/games/pacman/pacman.py
index 430e039..70436f3 100644
--- a/games/pacman/pacman.py
+++ b/games/pacman/pacman.py
@@ -1,6 +1,23 @@
+import random
 import pygame
+import numpy as np
+from pygame.math import Vector2
 
+class node ():
+    
+    def __init__ (self):
+        self.g = -1 # movement cost to move from previous node to this one (usually +10)
+        self.h = -1 # estimated movement cost to move from this node to the ending node (remaining horizontal and vertical steps * 10)
+        self.f = -1 # total movement cost of this node (= g + h)
+        # parent node - used to trace path back to the starting node at the end
+        self.parent = (-1, -1)
+        # node type - 0 for empty space, 1 for wall (optionally, 2 for starting node and 3 for end)
+        self.type = -1 
+        # create a 2d grid numpy array of 20x20
 
+
+
+    
 class Color:
     """
     Class to store hex values for colors/
@@ -18,6 +35,21 @@ class Color:
         self.purple = (255, 0, 255)
         self.yellow = (255, 255, 0)
 
+class PowerUp(pygame.sprite.Sprite):
+    def __init__(self, x, y):
+        super().__init__()
+        self.image = pygame.Surface([20, 20])
+        self.image.fill(Color().purple)  # Color indicating special power-up
+        self.rect = self.image.get_rect()
+        self.rect.x = x
+        self.rect.y = y
+        self.type = 'eat_ghosts'  # Specific type for eating ghosts
+        self.duration = 7000  # Lasts for 7 seconds
+
+    def apply_effect(self, player):
+        if self.type == 'eat_ghosts':
+            player.enable_ghost_eating(self.duration)
+
 
 class Wall(pygame.sprite.Sprite):
     def __init__(self, x, y, width, height, color):
@@ -113,6 +145,17 @@ class Player(pygame.sprite.Sprite):
         self.rect.left = x
         self.prev_x = x
         self.prev_y = y
+        self.goal = None
+        self.ghost_eating = False
+        self.position = Vector2(x, y)  # Current position as a vector
+        self.goal = Vector2()  # Goal position initialized to zero vector
+        self.directions = {
+            'up': Vector2(0, -1),
+            'down': Vector2(0, 1),
+            'left': Vector2(-1, 0),
+            'right': Vector2(1, 0)
+        }
+
 
     def prev_direction(self):
         """
@@ -140,7 +183,9 @@ class Player(pygame.sprite.Sprite):
         :param gate: 
         :type gate: 
         """
-
+        for event in pygame.event.get():
+            if event.type == pygame.USEREVENT + 3:  # Timer for ghost eating power-up
+                self.ghost_eating = False
         # Get the old position, in case we need to go back to it
         old_x = self.rect.left
         new_x = old_x + self.change_x
@@ -149,6 +194,7 @@ class Player(pygame.sprite.Sprite):
         old_y = self.rect.top
         new_y = old_y + self.change_y
 
+   
         x_collide = pygame.sprite.spritecollide(self, walls, False)
         if x_collide:
             self.rect.left = old_x
@@ -162,50 +208,79 @@ class Player(pygame.sprite.Sprite):
             gate_hit = pygame.sprite.spritecollide(self, gate, False)
             if gate_hit:
                 self.rect.left = old_x
-                self.rect.top = old_y
+                self.rect.top = old_y 
+    
+    def enable_ghost_eating(self, duration):
+        self.ghost_eating = True
+        pygame.time.set_timer(pygame.USEREVENT + 3, duration)
+
+    
 
 
 class Ghost(Player):
     """
-    Class to handle ghosts
+    Class to handle ghosts, inheriting from Player.
     """
-
-    def ghost_change_speed(self, direction_list, ghost, turn, steps, l):
-        """
-        Change the speed of the ghost
-        :param direction_list: 
-        :type direction_list: 
-        :param ghost: 
-        :type ghost: 
-        :param turn: 
-        :type turn: 
-        :param steps: 
-        :type steps: 
-        :param l: 
-        :type l: 
-        :return: 
-        :rtype: 
-        """
-        try:
-            z = direction_list[turn][2]
-            if steps < z:
-                self.change_x = direction_list[turn][0]
-                self.change_y = direction_list[turn][1]
-                steps += 1
+    def __init__(self, x, y, filename, game):
+        super().__init__(x, y, filename)
+        self.game = game
+
+    def update_behavior(self, pacman):
+        self.mode = "flee" if pacman.ghost_eating else "chase"
+
+    def move(self, pacman):
+        self.update_behavior(pacman)
+        direction = self.chase_pacman() if self.mode == "chase" else self.run_away_from_pacman()
+        if direction:
+            movement = self.calculate_movement(direction)
+            self.change_speed(*movement)
+
+    def chase_pacman(self):
+        return self.goal_direction(self.game.game_map)
+
+    def run_away_from_pacman(self):
+        furthest_point = self.find_furthest_point()
+        self.set_goal(*furthest_point)
+        return self.goal_direction(self.game.game_map)
+
+    def find_furthest_point(self):
+        max_distance = 0
+        furthest_point = (self.rect.x, self.rect.y)
+        for y in range(self.game.path_finder.size[0]):
+            for x in range(self.game.path_finder.size[1]):
+                if self.game.game_map[y][x] == 0:
+                    distance = (Vector2(x, y) - self.position).length_squared()
+                    if distance > max_distance:
+                        max_distance = distance
+                        furthest_point = (x, y)
+        return furthest_point
+
+    def goal_direction(self, game_map):
+        TILEWIDTH = 30
+        distances = []
+        directions = list(self.directions.keys())
+        for direction in directions:
+            next_position = self.position + self.directions[direction] * TILEWIDTH
+            if game_map[int(next_position.y // TILEWIDTH)][int(next_position.x // TILEWIDTH)] == 1:
+                distances.append(float('inf'))
             else:
-                if turn < l:
-                    turn += 1
-                elif ghost == 'ghost_four':
-                    turn = 2
-                else:
-                    turn = 0
-                self.change_x = direction_list[turn][0]
-                self.change_y = direction_list[turn][1]
-                steps = 0
-            return [turn, steps]
-        except IndexError:
-            return [0, 0]
-
+                vec = next_position - self.goal
+                distances.append(vec.length_squared())
+        if min(distances) == float('inf'):
+            return None
+        else:
+            index = distances.index(min(distances))
+            return directions[index]
+
+    def calculate_movement(self, direction):
+        movement_map = {
+            'up': (0, -30),
+            'down': (0, 30),
+            'left': (-30, 0),
+         'right': (30, 0)
+        }
+        return movement_map.get(direction, (0, 0)) 
+    
 
 class Game:
     """
@@ -216,7 +291,10 @@ class Game:
         """
         Constructor Function
         """
-
+        self.cell_size = 30
+        self.grid_width = 20
+        self.grid_height = 20
+        #self.path_finder = path_finder()
         # This is a list of walls. Each is in the form [x, y, width, height]
         self.walls = [
             [0, 0, 6, 600],
@@ -259,111 +337,7 @@ class Game:
             [360, 540, 126, 6],
         ]
 
-        self.ghost_one_directions = [
-            [0, -30, 4],
-            [15, 0, 9],
-            [0, 15, 11],
-            [-15, 0, 23],
-            [0, 15, 7],
-            [15, 0, 3],
-            [0, -15, 3],
-            [15, 0, 19],
-            [0, 15, 3],
-            [15, 0, 3],
-            [0, 15, 3],
-            [15, 0, 3],
-            [0, -15, 15],
-            [-15, 0, 7],
-            [0, 15, 3],
-            [-15, 0, 19],
-            [0, -15, 11],
-            [15, 0, 9],
-        ]
-
-        self.ghost_two_directions = [
-            [0, -15, 4],
-            [15, 0, 9],
-            [0, 15, 11],
-            [15, 0, 3],
-            [0, 15, 7],
-            [-15, 0, 11],
-            [0, 15, 3],
-            [15, 0, 15],
-            [0, -15, 15],
-            [15, 0, 3],
-            [0, -15, 11],
-            [-15, 0, 3],
-            [0, -15, 11],
-            [-15, 0, 3],
-            [0, -15, 3],
-            [-15, 0, 7],
-            [0, -15, 3],
-            [15, 0, 15],
-            [0, 15, 15],
-            [-15, 0, 3],
-            [0, 15, 3],
-            [-15, 0, 3],
-            [0, -15, 7],
-            [-15, 0, 3],
-            [0, 15, 7],
-            [-15, 0, 11],
-            [0, -15, 7],
-            [15, 0, 5],
-        ]
-
-        self.ghost_three_directions = [
-            [30, 0, 2],
-            [0, -15, 4],
-            [15, 0, 10],
-            [0, 15, 7],
-            [15, 0, 3],
-            [0, -15, 3],
-            [15, 0, 3],
-            [0, -15, 15],
-            [-15, 0, 15],
-            [0, 15, 3],
-            [15, 0, 15],
-            [0, 15, 11],
-            [-15, 0, 3],
-            [0, -15, 7],
-            [-15, 0, 11],
-            [0, 15, 3],
-            [-15, 0, 11],
-            [0, 15, 7],
-            [-15, 0, 3],
-            [0, -15, 3],
-            [-15, 0, 3],
-            [0, -15, 15],
-            [15, 0, 15],
-            [0, 15, 3],
-            [-15, 0, 15],
-            [0, 15, 11],
-            [15, 0, 3],
-            [0, -15, 11],
-            [15, 0, 11],
-            [0, 15, 3],
-            [15, 0, 1],
-        ]
-
-        self.ghost_four_directions = [
-            [-30, 0, 2],
-            [0, -15, 4],
-            [15, 0, 5],
-            [0, 15, 7],
-            [-15, 0, 11],
-            [0, -15, 7],
-            [-15, 0, 3],
-            [0, 15, 7],
-            [-15, 0, 7],
-            [0, 15, 15],
-            [15, 0, 15],
-            [0, -15, 3],
-            [-15, 0, 11],
-            [0, -15, 7],
-            [15, 0, 3],
-            [0, -15, 11],
-            [15, 0, 9],
-        ]
+       
 
         self.color = Color()
         # Call this function so the Pygame library can initialize itself
@@ -383,45 +357,7 @@ class Game:
         pygame.font.init()
         self.font = pygame.font.SysFont('arial', 30)
         self.all_sprites_list = None
-
-    def setup_walls(self):
-        """
-        Make the walls. (x_pos, y_pos, width, height)
-        :return:
-        :rtype:
-        """
-        wall_list = pygame.sprite.RenderPlain()
-
-        # Loop through the list. Create the wall, add it to the list
-        for item in self.walls:
-            wall = Wall(item[0], item[1], item[2], item[3], self.color.grey)
-            wall_list.add(wall)
-            self.all_sprites_list.add(wall)
-
-        # return our new list
-        return wall_list
-
-    def setup_gate(self):
-        """
-        Add gates in the walls
-        :return:
-        :rtype:
-        """
-        gate = pygame.sprite.RenderPlain()
-        gate.add(Wall(282, 242, 42, 2, self.color.white))
-        self.all_sprites_list.add(gate)
-        return gate
-
-    def start_game(self):
-        """
-        start the game
-        """
-
-        pl = len(self.ghost_one_directions) - 1
-        bl = len(self.ghost_two_directions) - 1
-        il = len(self.ghost_three_directions) - 1
-        cl = len(self.ghost_four_directions) - 1
-
+        self.power_pellets = pygame.sprite.RenderPlain()
         # default locations for Pacman and ghosts
         w = 303 - 16  # Width
         p_h = 7 * 60 + 19
@@ -431,11 +367,12 @@ class Game:
         c_w = 303 + 32 - 16
 
         self.all_sprites_list = pygame.sprite.RenderPlain()
-        block_list = pygame.sprite.RenderPlain()
-        ghost_list = pygame.sprite.RenderPlain()
-        pacman_collide = pygame.sprite.RenderPlain()
-        wall_list = self.setup_walls()
-        gate = self.setup_gate()
+        self.block_list = pygame.sprite.RenderPlain()
+        self.ghost_list = pygame.sprite.RenderPlain()
+        self.pacman_collide = pygame.sprite.RenderPlain()
+        self.wall_list = self.setup_walls()
+
+        self.gate = self.setup_gate()
 
         p_turn = 0
         p_steps = 0
@@ -449,30 +386,31 @@ class Game:
         c_turn = 0
         c_steps = 0
 
-        # Create the player paddle object
-        pacman = Player(w, p_h, 'images/pacman.png')
-        self.all_sprites_list.add(pacman)
-        pacman_collide.add(pacman)
+        # Create the player  object
+        self.pacman = Player(w, p_h, 'images/pacman.png')
+        self.all_sprites_list.add(self.pacman)
+        self.pacman_collide.add(self.pacman)
 
-        ghost_two = Ghost(w, b_h, 'images/red.png')
-        ghost_list.add(ghost_two)
-        self.all_sprites_list.add(ghost_two)
+        self.ghost_two = Ghost(w, b_h, 'images/red.png', self)
+        self.ghost_list.add(self.ghost_two)
+        self.all_sprites_list.add(self.ghost_two)
 
-        ghost_one = Ghost(w, m_h, 'images/pink.png')
-        ghost_list.add(ghost_one)
-        self.all_sprites_list.add(ghost_one)
+        self.ghost_one = Ghost(w, m_h, 'images/pink.png', self)
+        self.ghost_list.add(self.ghost_one)
+        self.all_sprites_list.add(self.ghost_one)
 
-        ghost_three = Ghost(i_w, m_h, 'images/blue.png')
-        ghost_list.add(ghost_three)
+        ghost_three = Ghost(i_w, m_h, 'images/blue.png',self)
+        self.ghost_list.add(ghost_three)
         self.all_sprites_list.add(ghost_three)
 
-        ghost_four = Ghost(c_w, m_h, 'images/yellow.png')
-        ghost_list.add(ghost_four)
+        ghost_four = Ghost(c_w, m_h, 'images/yellow.png',self)
+        self.ghost_list.add(ghost_four)
         self.all_sprites_list.add(ghost_four)
-
+        grid = [[0 for _ in range(19)] for _ in range(19)]
         # Draw the grid
         for row in range(19):
             for column in range(19):
+                
                 if (row == 7 or row == 8) and (column == 8 or column == 9 or column == 10):
                     continue
                 else:
@@ -482,18 +420,111 @@ class Game:
                     block.rect.x = 30 * column + 6 + 26
                     block.rect.y = 30 * row + 6 + 26
 
-                    b_collide = pygame.sprite.spritecollide(block, wall_list, False)
-                    p_collide = pygame.sprite.spritecollide(block, pacman_collide, False)
+                    b_collide = pygame.sprite.spritecollide(block, self.wall_list, False)
+                    p_collide = pygame.sprite.spritecollide(block, self.pacman_collide, False)
                     if b_collide:
+                        grid[row][column] = 1
+
                         continue
+
                     elif p_collide:
+                        grid[row][column] = 0
                         continue
                     else:
                         # Add the block to the list of objects
-                        block_list.add(block)
+                        grid[row][column] = 0
+                        self.block_list.add(block)
                         self.all_sprites_list.add(block)
+        # create new grid which is 20x20 with edges as 1 from grid
+        
+        new_grid = [[1 if i == 0 or i == 19 or j == 0 or j == 19 else grid[i-1][j-1] for j in range(20)] for i in range(20)] 
+        self.game_map = new_grid
+        self.path_finder.ResizeMap(20, 20)
+        self.update_path_finder_with_walls(new_grid)
+        blocks = list(self.block_list)
+        selected_blocks = random.sample(blocks, 4)
+        self.power_pellet_list = pygame.sprite.RenderPlain()
+# Replace the selected blocks with power pellets
+        for block in selected_blocks:
+            power_pellet = PowerUp(block.rect.x, block.rect.y)  # Assuming you have a PowerPellet class
+            self.power_pellet_list.add(power_pellet)
+    # Add the power pellet to the game (you might need to modify this part based on your game structure)
+            self.all_sprites_list.add(power_pellet)
+        self.bll = len(self.block_list)
+
+
+   
+
+    def update_path_finder_with_walls(self, grid):
+        for i in range(len(grid[0])):
+            for j in range(len(grid[1])):
+                self.path_finder.SetType(i,j, grid[i][j])
+
+
+
+    def get_maze_size(self):
+        max_width = 0
+        max_height = 0
+
+        for wall in self.walls:
+            x, y, width, height = wall
+            # Calculate the furthest extents of the walls
+            max_width = max(max_width, x + width)
+            max_height = max(max_height, y + height)
+
+        return max_width, max_height
+    def setup_walls(self):
+        """
+        Make the walls. (x_pos, y_pos, width, height)
+        :return:
+        :rtype:
+        """
+        wall_list = pygame.sprite.RenderPlain()
+
+        # Loop through the list. Create the wall, add it to the list
+        for item in self.walls:
+            wall = Wall(item[0], item[1], item[2], item[3], self.color.grey)
+            wall_list.add(wall)
+            self.all_sprites_list.add(wall)
 
-        bll = len(block_list)
+        # return our new list
+        return wall_list
+
+    def setup_gate(self):
+        """
+        Add gates in the walls
+        :return:
+        :rtype:
+        """
+        gate = pygame.sprite.RenderPlain()
+        gate.add(Wall(282, 242, 42, 2, self.color.white))
+        self.all_sprites_list.add(gate)
+        return gate 
+    
+
+    def setup_power_pellets(self):
+        # Define power pellet locations and add them to the game
+        locations = [(100, 200), (500, 300), (300, 100)]  # Example locations
+        for x, y in locations:
+            pellet = PowerUp(x, y)
+            self.power_pellets.add(pellet)
+            self.all_sprites_list.add(pellet) 
+
+
+    def start_game(self):
+        """
+        start the game
+        """
+
+       
+
+        
+                
+       
+
+        # Get the unique row indices
+
+        
         score = 0
         done = False
         while not done:
@@ -504,89 +535,88 @@ class Game:
 
                 if event.type == pygame.KEYDOWN:
                     if event.key == pygame.K_LEFT:
-                        pacman.change_speed(-30, 0)
+                        self.pacman.change_speed(-30, 0)
                     if event.key == pygame.K_RIGHT:
-                        pacman.change_speed(30, 0)
+                        self.pacman.change_speed(30, 0)
                     if event.key == pygame.K_UP:
-                        pacman.change_speed(0, -30)
+                        self.pacman.change_speed(0, -30)
                     if event.key == pygame.K_DOWN:
-                        pacman.change_speed(0, 30)
+                        self.pacman.change_speed(0, 30)
 
                 if event.type == pygame.KEYUP:
                     if event.key == pygame.K_LEFT:
-                        pacman.change_speed(30, 0)
+                        self.pacman.change_speed(30, 0)
                     if event.key == pygame.K_RIGHT:
-                        pacman.change_speed(-30, 0)
+                        self.pacman.change_speed(-30, 0)
                     if event.key == pygame.K_UP:
-                        pacman.change_speed(0, 30)
+                        self.pacman.change_speed(0, 30)
                     if event.key == pygame.K_DOWN:
-                        pacman.change_speed(0, -30)
-
-            pacman.update(wall_list, gate)
-            returned = ghost_one.ghost_change_speed(self.ghost_one_directions, False, p_turn, p_steps, pl)
-            p_turn = returned[0]
-            p_steps = returned[1]
-            ghost_one.ghost_change_speed(self.ghost_one_directions, False, p_turn, p_steps, pl)
-            ghost_one.update(wall_list, False)
-
-            returned = ghost_two.ghost_change_speed(self.ghost_two_directions, False, b_turn, b_steps, bl)
-            b_turn = returned[0]
-            b_steps = returned[1]
-            ghost_two.ghost_change_speed(self.ghost_two_directions, False, b_turn, b_steps, bl)
-            ghost_two.update(wall_list, False)
-
-            returned = ghost_three.ghost_change_speed(self.ghost_three_directions, False, i_turn, i_steps, il)
-            i_turn = returned[0]
-            i_steps = returned[1]
-            ghost_three.ghost_change_speed(self.ghost_three_directions, False, i_turn, i_steps, il)
-            ghost_three.update(wall_list, False)
-
-            returned = ghost_four.ghost_change_speed(self.ghost_four_directions, 'ghost_four', c_turn, c_steps, cl)
-            c_turn = returned[0]
-            c_steps = returned[1]
-            ghost_four.ghost_change_speed(self.ghost_four_directions, 'ghost_four', c_turn, c_steps, cl)
-            ghost_four.update(wall_list, False)
-
+                        self.pacman.change_speed(0, -30)
+
+            self.pacman.update(self.wall_list, self.gate) 
+
+            # Assuming new_grid is your grid
+            
+
+            # Check if the two grids are the same
+            # print(f"new_grid_np: {new_grid_np}")
+            # print(f"path_finder_grid: {path_finder_grid}")
+            # print(f"Are the grids equal? {are_grids_equal}")
+        # whic
+            #self.ghost_one.move(self.pacman)
+            self.ghost_two.move(self.pacman)
+            # ghost_three.move(pacman)
+            # ghost_four.move(pacman)
+
+            # ghost_one.update(wall_list, None)
+            self.ghost_two.update(self.wall_list, None)
+            print(f"Ghost Two position: {self.ghost_two.rect.x}, {self.ghost_two.rect.y}")
+            print("Is Ghost Two in all_sprites_list?", self.ghost_two in self.all_sprites_list)
+            print("Is Ghost Two in ghost_list?", self.ghost_two in self.ghost_list)
+            # ghost_three.update(wall_list, None)
+            # ghost_four.update(wall_list, None)
             # See if the pacman block has collided with anything.
-            blocks_hit_list = pygame.sprite.spritecollide(pacman, block_list, True)
-
+            blocks_hit_list = pygame.sprite.spritecollide(self.pacman, self.block_list, True) 
+            power_pellets_hit_list = pygame.sprite.spritecollide(self.pacman, self.power_pellet_list, True)
+            # check if pacman hits any power pellet
+            # if pellet is hit 
             # Check the list of collisions.
             if len(blocks_hit_list) > 0:
                 score += len(blocks_hit_list)
 
             self.screen.fill(self.color.black)
 
-            wall_list.draw(self.screen)
-            gate.draw(self.screen)
+            self.wall_list.draw(self.screen)
+            self.gate.draw(self.screen)
             self.all_sprites_list.draw(self.screen)
-            ghost_list.draw(self.screen)
+            self.ghost_list.draw(self.screen)
 
-            text = self.font.render(str(score) + '/' + str(bll), True, self.color.white)
+            text = self.font.render(str(score) + '/' + str(self.bll), True, self.color.white)
             self.screen.blit(text, [270, 254])
 
-            if score == bll:
+            if score == self.bll:
                 self.do_next(
                     'Congratulations, you won!',
                     145,
-                    block_list,
-                    ghost_list,
-                    pacman_collide,
-                    wall_list,
-                    gate,
+                    self.block_list,
+                    self.ghost_list,
+                    self.pacman_collide,
+                    self.wall_list,
+                    self.gate,
                 )
                 return
 
-            ghost_hit_list = pygame.sprite.spritecollide(pacman, ghost_list, False)
+            ghost_hit_list = pygame.sprite.spritecollide(self.pacman, self.ghost_list, False)
 
             if ghost_hit_list:
                 self.do_next(
                     'Game Over',
                     235,
-                    block_list,
-                    ghost_list,
-                    pacman_collide,
-                    wall_list,
-                    gate,
+                    self.block_list,
+                    self.ghost_list,
+                    self.pacman_collide,
+                    self.wall_list,
+                    self.gate,
                 )
                 return
 
@@ -653,4 +683,4 @@ if __name__ == '__main__':
     # main function
     game = Game()
     game.start_game()
-    pygame.quit()
+    pygame.quit()
\ No newline at end of file
diff --git a/games/pacman/requirements.txt b/games/pacman/requirements.txt
deleted file mode 100644
index 231dd17..0000000
--- a/games/pacman/requirements.txt
+++ /dev/null
@@ -1 +0,0 @@
-pygame
\ No newline at end of file
diff --git a/games/pong/__init__.py b/games/pong/__init__.py
index 15c7fb5..e69de29 100644
--- a/games/pong/__init__.py
+++ b/games/pong/__init__.py
@@ -1,6 +0,0 @@
-from gym.envs.registration import register
-
-register(
-    id="pong_envs/Pong-v0",
-    entry_point="pong_envs:GridWorldEnv",
-)
diff --git a/games/pong/pong.py b/games/pong/pong.py
index cbd428d..b410ade 100644
--- a/games/pong/pong.py
+++ b/games/pong/pong.py
@@ -89,10 +89,7 @@ while running:
         ball.x, ball.y = screen_width // 2 - ball_size // 2, screen_height // 2 - ball_size // 2
         ball_speed_x, ball_speed_y = -4, 4 * random.choice((1, -1))
 
-    # Update the features
-    nodes = pong_features.update_node_features(nodes, ball, left_paddle, right_paddle, ball_speed_x, ball_speed_y,left_paddle_move, right_paddle_move, paddle_speed,node_width, node_height, grid_width, grid_height)
-    pong_features.update_node_features_graph(G, nodes, grid_width, grid_height)
-
+    
     # Game over check
     if left_player_lives == 0 or right_player_lives == 0:
         running = False  # Stop the game
diff --git a/games/pong/pong_envs/__init__.py b/games/pong/pong_envs/__init__.py
index 89917b5..8b13789 100644
--- a/games/pong/pong_envs/__init__.py
+++ b/games/pong/pong_envs/__init__.py
@@ -1,2 +1 @@
-from pong_envs.pong_env import PongEnv
 
diff --git a/games/pong/pong_envs/__pycache__/pong_env.cpython-39.pyc b/games/pong/pong_envs/__pycache__/pong_env.cpython-39.pyc
index ec3733d..3ec2bfd 100644
Binary files a/games/pong/pong_envs/__pycache__/pong_env.cpython-39.pyc and b/games/pong/pong_envs/__pycache__/pong_env.cpython-39.pyc differ
diff --git a/games/pong/pong_envs/pong_env.py b/games/pong/pong_envs/pong_env.py
index 8672680..5cdbd41 100644
--- a/games/pong/pong_envs/pong_env.py
+++ b/games/pong/pong_envs/pong_env.py
@@ -1,196 +1,58 @@
+
 import gymnasium as gym
 from gymnasium import spaces
 import pygame
-import numpy as np 
+import numpy as np
 import random
 import torch
 from torch_geometric.data import Data
-import torch.nn.functional as F
+import networkx as nx
+from collections import defaultdict
+from itertools import combinations
 
-class PongEnv(gym.Env):
-    metadata = {"render_modes": ["human", "rgb_array"], "render_fps": 60}
+class PongEnvNew(gym.Env):
+    metadata = {"render_modes": ["human", "rgb_array"], "render_fps": 60, "observation_types": ["pixel", "graph"]}
 
-    def __init__(self, render_mode='human', paddle_width=10, paddle_height=40, ball_size=15, paddle_speed=5):
+    def __init__(self, render_mode='human', observation_type='pixel', paddle_width=10, paddle_height=40, ball_size=15, paddle_speed=5, frame_stack=4):
         pygame.init()
         self.width = 800
         self.height = 600
         self.render_mode = render_mode
+        self.observation_type = observation_type
         self.paddle_width = paddle_width
         self.paddle_height = paddle_height
         self.ball_size = ball_size
         self.paddle_speed = paddle_speed
+        self.frame_stack = frame_stack  # Number of frames to stack
         self.action_space = spaces.Discrete(3)  # [Stay, Up, Down]
-        self.observation_space = spaces.Box(low=0, high=255, shape=(self.height, self.width), dtype=np.uint8)
-        if self.render_mode == "human":
-            self.screen = pygame.display.set_mode((self.width, self.height))
-            pygame.display.set_caption("Pong")
-        else:
-            self.screen = pygame.Surface((self.width, self.height))
-        self.clock = pygame.time.Clock() 
-        self.ai_reaction_time = 2  # milliseconds
-        self.np_random = None
-        self.frame_buffer = np.zeros((self.height, self.width, 4), dtype=np.uint8)
-        self.proximity_threshold = 50
-    
-    def seed(self, seed=None):
-        self.np_random, seed = gym.utils.seeding.np_random(seed)
-        return [seed]
-    
-    def reset(self, seed = None, options = None):
-        super().reset(seed = seed, options = options) 
-        if seed is not None:
-            self.seed(seed)  # Seed the RNG for the environment
-        self.ball = pygame.Rect(self.width // 2 - self.ball_size // 2, self.height // 2 - self.ball_size // 2, self.ball_size, self.ball_size)
-        self.left_paddle = pygame.Rect(50, self.height // 2 - self.paddle_height // 2, self.paddle_width, self.paddle_height)
-        self.right_paddle = pygame.Rect(self.width - 50 - self.paddle_width, self.height // 2 - self.paddle_height // 2, self.paddle_width, self.paddle_height)
-        self.ai_last_reaction_time = pygame.time.get_ticks()
-        self.ball_speed_x, self.ball_speed_y = 4 * random.choice((1, -1)), 4 * random.choice((1, -1))
-        self.left_player_score = 0
-        self.right_player_score = 0
-        return self._get_observation(), {}
-
 
-    def render(self):
-        if self.render_mode == "human":
-            self.screen.fill((0, 0, 0))
-            pygame.draw.rect(self.screen, (255, 255, 255), self.left_paddle)
-            pygame.draw.rect(self.screen, (255, 255, 255), self.right_paddle)
-            pygame.draw.ellipse(self.screen, (255, 255, 255), self.ball)
-            pygame.display.flip()
-            
-            self.clock.tick(self.metadata['render_fps'])
-        elif self.render_mode == "rgb_array":
-            return np.array(pygame.surfarray.pixels3d(self.screen))
-
-    def _get_observation(self):
-        self.render()
-        if self.render_mode == "rgb_array":
-            frame = pygame.surfarray.array3d(pygame.display.get_surface())
-            # Convert to grayscale
-            grayscale = np.dot(frame[..., :3], [0.2989, 0.5870, 0.1140]).astype(np.uint8)
-            # Update frame buffer, pushing back older frames
-            self.frame_buffer = np.roll(self.frame_buffer, shift=-1, axis=2)
-            self.frame_buffer[:, :, 3] = grayscale
-            return self.frame_buffer
+        if observation_type == "pixel":
+            self.observation_space = spaces.Box(low=0, high=255, shape=(self.frame_stack, self.height, self.width), dtype=np.uint8)
         else:
-            # Return a dummy observation if not in rgb_array mode
-            return self.frame_buffer
-        return None
-    
-    def _apply_action(self, action):
-        if action == 1 and self.left_paddle.top > 0:
-            self.left_paddle.y -= self.paddle_speed
-        elif action == 2 and self.left_paddle.bottom < self.height:
-            self.left_paddle.y += self.paddle_speed
-
-
-    def ai_move(self):
-        current_time = pygame.time.get_ticks()
-        # AI paddle movement
-        if current_time - self.ai_last_reaction_time > self.ai_reaction_time:
-            if self.ball.y < self.right_paddle.y + self.paddle_height / 2 and self.right_paddle.top > 0:
-                self.right_paddle.y -= self.paddle_speed
-            if self.ball.y > self.right_paddle.y + self.paddle_height / 2 and self.right_paddle.bottom < self.height:
-                self.right_paddle.y += self.paddle_speed
-            self.ai_last_reaction_time = current_time
-
-
-    def _update_game_state(self):
-        # Existing game state update logic
-        self.ball.x += self.ball_speed_x
-        self.ball.y += self.ball_speed_y
-        # Check for collisions with top and bottom of the screen
-        if self.ball.top <= 0 or self.ball.bottom >= self.height:
-            self.ball_speed_y *= -1
-        # AI paddle move
-        self.ai_move()
-        # Check for collisions with paddles
-        collision = False
-        if self.ball.colliderect(self.left_paddle) or self.ball.colliderect(self.right_paddle):
-            self.ball_speed_x *= -1
-            collision = True
-            # Adjust the ball's position to prevent sticking
-            if self.ball.colliderect(self.left_paddle):
-                self.ball.left = self.left_paddle.right  # Place the ball right outside the left paddle
-            elif self.ball.colliderect(self.right_paddle):
-                self.ball.right = self.right_paddle.left  # Place the ball right outside the right paddle
-
-        # Check for scoring
-        score = 0
-        if self.ball.left <= 0:
-            self.right_player_score += 1
-            score = -1  # Negative reward for the agent 
-            self.ball_reset()
-        elif self.ball.right >= self.width:
-            self.left_player_score += 1
-        
-            score = 1   # Positive reward for the agent
-            self.ball_reset()
-
-        return collision, score
-    
+            # Define a generic observation space for graph data
+            self.observation_space = spaces.Box(low=-np.inf, high=np.inf, shape=(5, 7), dtype=np.float32)  # Number of objects and feature length
 
-    def ball_reset(self):
-        self.ball.x, self.ball.y = self.width // 2 - self.ball_size // 2, self.height // 2 - self.ball_size // 2
-        self.ball_speed_x, self.ball_speed_y = 4 * random.choice((1, -1)), 4 * random.choice((1, -1))
-
-
-    def step(self, action):
-        self._apply_action(action)
-        collision, score = self._update_game_state()
-        observation = self._get_observation()
-        reward = 0
-        if collision:
-            reward += 0.1  # Reward for hitting the ball
-        reward += score  # Reward or penalty for scoring/losing a point
-        done = self._check_done()
-        return observation, reward, done, False, {}
-
-    
-
-    def _check_done(self):
-        # Define the conditions under which the game is considered done
-        if self.left_player_score >= 3 or self.right_player_score >= 3:
-            return True
-        return False
-
-    def close(self):
-        pygame.display.quit()
-        pygame.quit()
-
-class PongEnvRel(gym.Env):
-    metadata = {"render_modes": ["human", "rgb_array"], "render_fps": 60}
-
-    def __init__(self, render_mode='human', paddle_width=10, paddle_height=40, ball_size=15, paddle_speed=5):
-        pygame.init()
-        self.width = 800
-        self.height = 600
-        self.render_mode = render_mode
-        self.paddle_width = paddle_width
-        self.paddle_height = paddle_height
-        self.ball_size = ball_size
-        self.paddle_speed = paddle_speed
-        self.action_space = spaces.Discrete(3)  # [Stay, Up, Down]
-        self.observation_space = spaces.Box(low=0, high=255, shape=(self.height, self.width), dtype=np.uint8)
         if self.render_mode == "human":
             self.screen = pygame.display.set_mode((self.width, self.height))
             pygame.display.set_caption("Pong")
         else:
             self.screen = pygame.Surface((self.width, self.height))
-        self.clock = pygame.time.Clock() 
+        
+        self.clock = pygame.time.Clock()
         self.ai_reaction_time = 2  # milliseconds
         self.np_random = None
-        self.frame_buffer = np.zeros((self.height, self.width, 4), dtype=np.uint8)
+        self.frame_buffer = np.zeros((self.height, self.width, self.frame_stack), dtype=np.uint8)
         self.proximity_threshold = 50
     
     def seed(self, seed=None):
         self.np_random, seed = gym.utils.seeding.np_random(seed)
         return [seed]
     
-    def reset(self, seed = None, options = None):
-        super().reset(seed = seed, options = options) 
+    def reset(self, seed=None, options=None):
+        super().reset(seed=seed, options=options) 
         if seed is not None:
             self.seed(seed)  # Seed the RNG for the environment
+        
         self.ball = pygame.Rect(self.width // 2 - self.ball_size // 2, self.height // 2 - self.ball_size // 2, self.ball_size, self.ball_size)
         self.left_paddle = pygame.Rect(50, self.height // 2 - self.paddle_height // 2, self.paddle_width, self.paddle_height)
         self.right_paddle = pygame.Rect(self.width - 50 - self.paddle_width, self.height // 2 - self.paddle_height // 2, self.paddle_width, self.paddle_height)
@@ -198,43 +60,52 @@ class PongEnvRel(gym.Env):
         self.ball_speed_x, self.ball_speed_y = 4 * random.choice((1, -1)), 4 * random.choice((1, -1))
         self.left_player_score = 0
         self.right_player_score = 0
-        return self._get_observation(), {}
+        self.frame_buffer = np.zeros((self.height, self.width, self.frame_stack), dtype=np.uint8)
+        
+        # Fill the frame buffer with the initial frame
+        for _ in range(self.frame_stack):
+            self._get_observation()
 
+        return self._get_observation(), {}
 
     def render(self):
+        # Ensure the screen is always updated with the current game state
+        self.screen.fill((0, 0, 0))
+        pygame.draw.rect(self.screen, (255, 255, 255), self.left_paddle)
+        pygame.draw.rect(self.screen, (255, 255, 255), self.right_paddle)
+        pygame.draw.ellipse(self.screen, (255, 255, 255), self.ball)
+
         if self.render_mode == "human":
-            self.screen.fill((0, 0, 0))
-            pygame.draw.rect(self.screen, (255, 255, 255), self.left_paddle)
-            pygame.draw.rect(self.screen, (255, 255, 255), self.right_paddle)
-            pygame.draw.ellipse(self.screen, (255, 255, 255), self.ball)
+            # Update the display when in human mode
             pygame.display.flip()
-            
             self.clock.tick(self.metadata['render_fps'])
         elif self.render_mode == "rgb_array":
+            # Return an RGB array of the screen for non-human modes (e.g., for AI processing)
             return np.array(pygame.surfarray.pixels3d(self.screen))
 
     def _get_observation(self):
-        self.render()
-        if self.render_mode == "rgb_array":
+        if self.observation_type == "pixel":
+            self.render()
             frame = pygame.surfarray.array3d(pygame.display.get_surface())
-            # Convert to grayscale
-            grayscale = np.dot(frame[..., :3], [0.2989, 0.5870, 0.1140]).astype(np.uint8)
-            # Update frame buffer, pushing back older frames
+            frame = np.transpose(frame, (1, 0, 2))  # Transpose to match (height, width, channels)
+            grayscale = np.dot(frame[..., :3], [0.2989, 0.5870, 0.1140]).astype(np.uint8)  # Convert to grayscale
             self.frame_buffer = np.roll(self.frame_buffer, shift=-1, axis=2)
-            self.frame_buffer[:, :, 3] = grayscale
-            return self.frame_buffer
+            self.frame_buffer[:, :, -1] = grayscale  # Update the last frame
+
+            # Normalize frame buffer
+            normalized_frame_buffer = self.frame_buffer / 255.0
+
+            # Convert to (batch_size, 4, height, width)
+            return normalized_frame_buffer.transpose(2, 0, 1)
         else:
-            # Return a dummy observation if not in rgb_array mode
-            return self.frame_buffer
-        return None
-    
+            return self.get_graph_data()
+
     def _apply_action(self, action):
         if action == 1 and self.left_paddle.top > 0:
             self.left_paddle.y -= self.paddle_speed
         elif action == 2 and self.left_paddle.bottom < self.height:
             self.left_paddle.y += self.paddle_speed
 
-
     def ai_move(self):
         current_time = pygame.time.get_ticks()
         # AI paddle movement
@@ -245,7 +116,6 @@ class PongEnvRel(gym.Env):
                 self.right_paddle.y += self.paddle_speed
             self.ai_last_reaction_time = current_time
 
-
     def _update_game_state(self):
         # Existing game state update logic
         self.ball.x += self.ball_speed_x
@@ -274,18 +144,15 @@ class PongEnvRel(gym.Env):
             self.ball_reset()
         elif self.ball.right >= self.width:
             self.left_player_score += 1
-        
-            score = 1   # Positive reward for the agent
+            score = 1  # Positive reward for the agent
             self.ball_reset()
 
         return collision, score
-    
 
     def ball_reset(self):
         self.ball.x, self.ball.y = self.width // 2 - self.ball_size // 2, self.height // 2 - self.ball_size // 2
         self.ball_speed_x, self.ball_speed_y = 4 * random.choice((1, -1)), 4 * random.choice((1, -1))
 
-
     def step(self, action):
         self._apply_action(action)
         collision, score = self._update_game_state()
@@ -293,63 +160,29 @@ class PongEnvRel(gym.Env):
         reward = 0
         if collision:
             reward += 0.1  # Reward for hitting the ball
-        reward += score  # Reward or penalty for scoring/losing a point
+        reward += score  # Reward or penalty for scoring/losing a point 
         done = self._check_done()
-        graph_data = self.get_graph_data()
-        return observation, reward, done, False, graph_data
+        info = {}
+        truncated = False  # Indicates if the episode was truncated
+        return observation, reward, done,truncated, info
 
-    
-    
 
     def get_graph_data(self):
-        # Define object features
-        ball_features = [self.ball['x'], self.ball['y'], self.ball['speed_x'], self.ball['speed_y'], 1, 0, 0]
-        left_paddle_features = [self.left_paddle['x'], self.left_paddle['y'], 0, 0, 0, 1, 0]
-        right_paddle_features = [self.right_paddle['x'], self.right_paddle['y'], 0, 0, 0, 1, 0]
-        top_wall_features = [0, self.top_wall['y'], 0, 0, 0, 0, 1]
-        bottom_wall_features = [0, self.bottom_wall['y'], 0, 0, 0, 0, 1]
-
-        # Combine object features
-        object_features = [ball_features, left_paddle_features, right_paddle_features, top_wall_features, bottom_wall_features]
-        
-        # Initialize tensors for PyG
-        x = torch.tensor(object_features, dtype=torch.float)
-        edge_index = []
-        edge_attr = []
-
-        num_objects = len(object_features)
-        positions = [(feat[0], feat[1]) for feat in object_features]  # Position is first two features
-
-        # Calculate proximity and create atoms based on it
-        atom_features = []
-        atom_index = num_objects  # Start indexing atoms after all objects
-
-        for i in range(num_objects):
-            for j in range(i + 1, num_objects):
-                dist = np.linalg.norm(np.array(positions[i]) - np.array(positions[j]))
-                if dist < self.proximity_threshold:
-                    # Create an atom for this proximity
-                    proximity_atom_features = [0]*2*len(ball_features) # Example atom features
-                    atom_features.append(proximity_atom_features)
-                    # Add edges between the atom and involved objects
-                    edge_index.extend([[atom_index, i], [atom_index, j]]) 
-
-                    # edge_attr.extend([[1], [1], [1], [1]])  # Example edge attributes
-                    
-                    atom_index += 1  # Move to next atom index
-
-        # Concatenate object and atom features
-        all_features = torch.cat([x, torch.tensor(atom_features, dtype=torch.float)], dim=0)
-
-        # Convert lists to tensors
-        edge_index = torch.tensor(edge_index, dtype=torch.long).t().contiguous()
-        #edge_attr = torch.tensor(edge_attr, dtype=torch.float)
-
-        # Create the PyTorch Geometric Data object
-        data = Data(x=all_features, edge_index=edge_index) 
-        return data
-
-
+        # Define the features for each object in the environment
+        objects = {
+            "ball": [self.ball.x, self.ball.y, self.ball_speed_x, self.ball_speed_y, 1, 0, 0],
+            "left_paddle": [self.left_paddle.x, self.left_paddle.y, 0, 0, 0, 1, 0],
+            "right_paddle": [self.right_paddle.x, self.right_paddle.y, 0, 0, 0, 1, 0],
+            "top_wall": [0, 0, 0, 0, 0, 0, 1],
+            "bottom_wall": [0, self.height, 0, 0, 0, 0, 1]
+        }
+
+        # Convert the object features to a tensor
+        node_features = [features for features in objects.values()]
+        x = torch.tensor(node_features, dtype=torch.float32)
+
+        return x 
+    
 
     def _check_done(self):
         # Define the conditions under which the game is considered done
@@ -361,18 +194,17 @@ class PongEnvRel(gym.Env):
         pygame.display.quit()
         pygame.quit()
 
-
 if __name__ == "__main__":
-    env = PongEnv(render_mode='human')
+    env = PongEnvNew(render_mode='human', observation_type='pixel')
     env.reset()
 
     done = False
     try:
         while not done:
             action = env.action_space.sample()
-            _, _, done, _, _ = env.step(action)
+            _, _, done, _ = env.step(action)
             env.render()
             pygame.time.wait(10)
     finally:
-        print(done)
-        env.close() 
+        env.close()
+
diff --git a/games/pong/test.py b/games/pong/test.py
index 585351f..0965e45 100644
--- a/games/pong/test.py
+++ b/games/pong/test.py
@@ -1,11 +1,29 @@
-import gym
-
-env = gym.make('Pong-v0')
-env.reset()
-for _ in range(1000):
-    env.render()
-    action = env.action_space.sample()
-    obs, reward, done, info = env.step(action)
-    if done:
-        env.reset()
-env.close()
\ No newline at end of file
+import wandb
+import random
+
+# start a new wandb run to track this script
+wandb.init(
+    # set the wandb project where this run will be logged
+    project="my-awesome-project",
+
+    # track hyperparameters and run metadata
+    config={
+    "learning_rate": 0.02,
+    "architecture": "CNN",
+    "dataset": "CIFAR-100",
+    "epochs": 10,
+    }
+)
+
+# simulate training
+epochs = 10
+offset = random.random() / 5
+for epoch in range(2, epochs):
+    acc = 1 - 2 ** -epoch - random.random() / epoch - offset
+    loss = 2 ** -epoch + random.random() / epoch + offset
+
+    # log metrics to wandb
+    wandb.log({"acc": acc, "loss": loss})
+
+# [optional] finish the wandb run, necessary in notebooks
+wandb.finish()
\ No newline at end of file
diff --git a/games/shoot.py b/games/shoot.py
deleted file mode 100644
index da393d6..0000000
--- a/games/shoot.py
+++ /dev/null
@@ -1,77 +0,0 @@
-import pygame
-import random
-
-pygame.init()
-
-# Game window dimensions
-WIDTH, HEIGHT = 800, 600
-win = pygame.display.set_mode((WIDTH, HEIGHT))
-pygame.display.set_caption("Shooting Game")
-
-# Colors
-WHITE = (255, 255, 255)
-RED = (255, 0, 0)
-BLACK = (0, 0, 0)
-
-# Shooter settings
-shooter_pos = [WIDTH // 2, HEIGHT - 50]
-shooter_speed = 5
-
-# Target settings
-target_pos = [random.randint(20, WIDTH - 20), random.randint(20, HEIGHT / 2)]
-target_speed = 2
-target_direction = 1
-
-# Bullet settings
-bullet_pos = []
-bullet_speed = 10
-
-clock = pygame.time.Clock()
-
-def draw_game():
-    win.fill(BLACK)
-    pygame.draw.circle(win, RED, target_pos, 20)
-    pygame.draw.rect(win, WHITE, (*shooter_pos, 50, 20))
-    for bullet in bullet_pos:
-        pygame.draw.rect(win, WHITE, (*bullet, 10, 5))
-    pygame.display.update()
-
-def move_target():
-    global target_direction
-    target_pos[0] += target_speed * target_direction
-    if target_pos[0] >= WIDTH - 20 or target_pos[0] <= 20:
-        target_direction *= -1
-
-def shoot_bullet():
-    bullet_pos.append([shooter_pos[0] + 20, shooter_pos[1]])
-
-def move_bullets():
-    for bullet in bullet_pos[:]:
-        bullet[1] -= bullet_speed
-        if bullet[1] < 0:
-            bullet_pos.remove(bullet)
-
-def check_collision():
-    global shooter_pos, target_pos
-    for bullet in bullet_pos:
-        if target_pos[0] - 20 < bullet[0] < target_pos[0] + 20 and target_pos[1] - 20 < bullet[1] < target_pos[1] + 20:
-            shooter_pos = [random.randint(50, WIDTH - 50), HEIGHT - 50]
-            target_pos = [random.randint(20, WIDTH - 20), random.randint(20, HEIGHT / 2)]
-            bullet_pos.remove(bullet)
-
-running = True
-while running:
-    clock.tick(60)
-    for event in pygame.event.get():
-        if event.type == pygame.QUIT:
-            running = False
-        if event.type == pygame.KEYDOWN:
-            if event.key == pygame.K_SPACE:
-                shoot_bullet()
-
-    move_target()
-    move_bullets()
-    check_collision()
-    draw_game()
-
-pygame.quit()
