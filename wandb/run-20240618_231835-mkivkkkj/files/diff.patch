diff --git a/games/.DS_Store b/games/.DS_Store
index 6362bcd..0262a6d 100644
Binary files a/games/.DS_Store and b/games/.DS_Store differ
diff --git a/games/breakout/breakout_env.py b/games/breakout/breakout_env.py
index c3bbb54..2455bcf 100644
--- a/games/breakout/breakout_env.py
+++ b/games/breakout/breakout_env.py
@@ -14,38 +14,47 @@ import networkx as nx
 from games.encoder.GraphEncoder import GraphConverter
 
 class BreakoutEnv(gym.Env):
-    """Custom Environment that follows gym interface"""
-    metadata = {'render.modes': ['human']}
-
-    def __init__(self, num_frames=4):
+    metadata = {'render.modes': ['human', 'rgb_array']}
+    
+    def __init__(self, render_mode='human', observation_type='pixel', num_frames=4):
         super(BreakoutEnv, self).__init__()
-        # Define action and observation space
-        # They must be gym.spaces objects
-        # Example when using discrete actions:
+
+        self.render_mode = render_mode
+        self.observation_type = observation_type
         self.num_frames = num_frames
-        self.observation_space = spaces.Box(low=0, high=255,
-                                            shape=(600, 1200, 3 * num_frames),  # Stack frames along the channel dimension
-                                            dtype=np.uint8)
-        self.proximity_threshold = 50  # Example threshold for proximity
-        self.action_space = spaces.Discrete(3)  # actions: move left, stay, move right
-        # Example for observation space: the game state
-        self.observation_space = spaces.Box(low=0, high=255, shape=(600, 1200, 3), dtype=np.uint8)
-        self.screen_width = 1200
-        self.screen_height = 600
-        self.screen = pygame.display.set_mode((self.screen_width, self.screen_height))
-        pygame.display.set_caption('Breakout') 
 
+        # Action space (move left, stay, move right)
+        self.action_space = spaces.Discrete(3)
+
+        # Observation space
+        self.window_width = 1200
+        self.window_height = 600
+        if observation_type == 'pixel':
+            self.observation_space = spaces.Box(low=0, high=255,
+                                                shape=(self.window_height, self.window_width, 3 * self.num_frames),
+                                                dtype=np.uint8)
+        else:
+            brick_width = 60
+            brick_spacing = 5
+            num_bricks_per_lane = (self.screen.get_width() - 2 * brick_spacing) // (brick_width + brick_spacing)
+            self.total_bricks = 5 * num_bricks_per_lane
+
+            self.observation_space = spaces.Box(low=-np.inf, high=np.inf, shape=(self.total_bricks+ 2, 7), dtype=np.float32)
+
+        # Initialize the game
         pygame.init()
+        self.screen = pygame.display.set_mode((self.window_width, self.window_height))
+        pygame.display.set_caption("Breakout")
+        self.frame_buffer = np.zeros((self.window_height, self.window_width, 3 * self.num_frames), dtype=np.uint8)
         self.clock = pygame.time.Clock()
-        self.frame_buffer = np.zeros((self.screen_height, self.screen_width, 3 * num_frames), dtype=np.uint8)
 
-        
+        self.reset()
 
     def reset(self):
         self.paddle = Paddle(self.screen)
         self.ball = Ball(self.screen)
         self.bricks = Bricks(self.screen)
-        self.scoreboard = Scoreboard(self.screen, lives=5 )
+        self.scoreboard = Scoreboard(self.screen, lives=5)
         self.ui = UI(self.screen)
         self.paddle.draw()
         self.ball.draw()
@@ -56,52 +65,84 @@ class BreakoutEnv(gym.Env):
         for i in range(self.num_frames):
             start_idx = i * 3
             self.frame_buffer[:, :, start_idx:start_idx + 3] = initial_state
-        return self.frame_buffer
+        if self.observation_type == 'pixel':
+            return self.frame_buffer
+        else:
+            return self.get_object_data()
 
+    def step(self, action):
+        assert self.action_space.contains(action), f"{action} is an invalid action"
+        
+        self.screen.fill((0, 0, 0))
+        
+        if action == 0:
+            self.paddle.move_left()
+        elif action == 1:
+            self.paddle.move_right()
+        elif action == 2:
+            pass  # Do nothing for 'stay' action
+
+        self.ball.move()
+        
+        reward = 0
+        reward += self.check_collision_with_walls(self.ball, self.scoreboard, self.ui)
+        reward += self.check_collision_with_paddle(self.ball, self.paddle)
+        reward += self.check_collision_with_bricks(self.ball, self.scoreboard, self.bricks)
+        
+        new_frame = self.get_state()
+        self.update_frame_buffer(new_frame)
+        
+        self.paddle.draw()
+        self.ball.draw()
+        self.bricks.draw()
+        self.scoreboard.draw()
+        
+        done = self.scoreboard.lives == 0 or len(self.bricks.bricks) == 0
+
+        pygame.display.flip()
+
+        if self.observation_type == 'pixel':
+            observation = self.frame_buffer
+        else:
+            observation = self.get_object_data()
+
+        return observation, reward, done, {}
 
     def check_collision_with_walls(self, ball, score, ui):
         reward = 0
-        # detect collision with left and right walls:
-        if ball.rect.left <= 0 or ball.rect.right >= self.screen_width:
+        if ball.rect.left <= 0 or ball.rect.right >= self.window_width:
             ball.bounce(x_bounce=True, y_bounce=False)
 
-        # detect collision with upper wall
         if ball.rect.top <= 0:
             ball.bounce(x_bounce=False, y_bounce=True)
 
-        # detect collision with bottom wall
-        if ball.rect.bottom >= self.screen_height:
+        if ball.rect.bottom >= self.window_height:
             ball.reset()
             reward = -100
             score.decrease_lives()
             
             if score.lives == 0:
                 score.reset()
-                playing_game = False
                 ui.game_over(win=False)
             else:
-                ui.change_color() 
+                ui.change_color()
         return reward
 
-
-    def check_collision_with_paddle(self,ball, paddle):
+    def check_collision_with_paddle(self, ball, paddle):
         reward = 0
         if ball.rect.colliderect(paddle.rect):
-            # Determine the collision side and bounce accordingly
             center_ball = ball.rect.centerx
             center_paddle = paddle.rect.centerx
             reward = 10
 
-            if center_ball < center_paddle:  # Ball hits the left side of the paddle
+            if center_ball < center_paddle:
                 ball.bounce(x_bounce=True, y_bounce=True)
-            elif center_ball > center_paddle:  # Ball hits the right side of the paddle
+            elif center_ball > center_paddle:
                 ball.bounce(x_bounce=True, y_bounce=True)
             else:
-                # Ball hits the middle of the paddle
                 ball.bounce(x_bounce=False, y_bounce=True)
         return reward
 
-
     def check_collision_with_bricks(self, ball, score, bricks):
         reward = 0
         for brick in bricks.bricks:
@@ -111,182 +152,69 @@ class BreakoutEnv(gym.Env):
                 brick.quantity -= 1
                 if brick.quantity == 0:
                     bricks.bricks.remove(brick)
-                # Determine collision direction
-                # Note: Simple version without precise side detection
                 ball.bounce(x_bounce=False, y_bounce=True)
-                break 
+                break
         return reward
-        
-
-        
-
-    def step(self, action):
-        assert self.action_space.contains(action), f"{action} is an invalid action"
-        
-        # Clear the screen (fill with black or another color)
-        self.screen.fill((0, 0, 0))
-        
-        # Map action to game movements
-        if action == 0:
-            self.paddle.move_left()
-        elif action == 1:
-            self.paddle.move_right()
-        elif action == 2:
-            pass  # Do nothing for 'stay' action
 
-        # Move ball and check for interactions
-        self.ball.move()
-        
-        # Check collisions and compute rewards
-        reward = 0
-        reward += self.check_collision_with_walls(self.ball, self.scoreboard, self.ui)
-        reward += self.check_collision_with_paddle(self.ball, self.paddle)
-        reward += self.check_collision_with_bricks(self.ball, self.scoreboard, self.bricks)
-        new_frame = self.get_state()
-        # Update the frame buffer
-        self.update_frame_buffer(new_frame)
-        # Draw all game elements
-        self.paddle.draw()
-        self.ball.draw()
-        self.bricks.draw()
-        self.scoreboard.draw()
-        self.get_graph_data()
-        # Check if game over
-        done = self.scoreboard.lives == 0 or len(self.bricks.bricks) == 0
-
-        # Update the display to show the new positions of game elements
-        pygame.display.flip()
-
-        # Additional info can be passed, though not used here
-        info = {}
-
-        return self.frame_buffer, reward, done, info
-    
-
-   
-
-
-    def check_proximity(self, rect1, rect2, d=50):
-        # Dummy implementation for proximity check
-        return np.linalg.norm(np.array([rect1['x'], rect1['y']]) - np.array([rect2['x'], rect2['y']])) < d
+    def get_state(self):
+        surface_array = pygame.surfarray.array3d(pygame.display.get_surface())
+        transposed_array = np.transpose(surface_array, axes=(1, 0, 2))
+        return transposed_array
 
-    def check_adjacent(self, rect1, rect2, d=50):
-        # Dummy implementation for adjacency check
-        return np.linalg.norm(np.array([rect1['x'], rect1['y']]) - np.array([rect2['x'], rect2['y']])) < d
+    def update_frame_buffer(self, new_frame):
+        self.frame_buffer = np.roll(self.frame_buffer, shift=-3, axis=2)
+        self.frame_buffer[:, :, -3:] = new_frame
 
-    def get_graph_data(self):
-        # Initialize a NetworkX graph
-        graph = nx.Graph()
+    def get_object_data(self):
+        object_features = []
 
-        # Define object features and add nodes
         ball_features = [self.ball.rect.x, self.ball.rect.y, self.ball.x_move_dist, self.ball.y_move_dist, 1, 0, 0]
-        graph.add_node("ball", type="object", features=ball_features)
+        object_features.append(ball_features)
 
         paddle_features = [self.paddle.rect.x, self.paddle.rect.y, 0, 0, 0, 1, 0]
-        graph.add_node("paddle", type="object", features=paddle_features)
-
-        brick_features = [[brick.rect.x, brick.rect.y, 0, 0, 0, 0, 1] for brick in self.bricks.bricks]
-        for i, features in enumerate(brick_features):
-            graph.add_node(f"brick_{i}", type="object", features=features)
-
-        # Combine object positions
-        object_positions = {
-            "ball": ball_features[:2],
-            "paddle": paddle_features[:2],
-        }
-        for i, features in enumerate(brick_features):
-            object_positions[f"brick_{i}"] = features[:2]
-        # Proximity threshold for creating atoms
-        proximity_threshold = self.proximity_threshold
-
-        # Create atom nodes and edges based on proximity and adjacency
-        atom_index = len(object_positions)  # Start indexing atoms after all objects
-        standard_feature_vector_size = len(ball_features)
-        empty_feature_vector = [0] * (2 * standard_feature_vector_size)
-
-
-        # Add proximity atoms and edges for ball and bricks
-        for i, brick in enumerate(self.bricks.bricks):
-            if self.check_proximity(self.ball, brick, d=50):
-                atom_node = f"Proximity_Ball_Brick_{i}_{atom_index}"
-                graph.add_node(atom_node, type="atom", features=empty_feature_vector, predicate="Proximity")
-                graph.add_edge("ball", atom_node, position=0)
-                graph.add_edge(f"brick_{i}", atom_node, position=1)
-                atom_index += 1
-        # Add proximity atoms and edges for paddle and ball
-        if self.check_proximity(self.ball, self.paddle, d=50):
-            atom_node = f"Proximity_Ball_Paddle_{atom_index}"
-            graph.add_node(atom_node, type="atom",features=empty_feature_vector, predicate="Proximity")
-            graph.add_edge("ball", atom_node, position=0)
-            graph.add_edge("paddle", atom_node, position=1)
-            atom_index += 1
-
-        # Add adjacent atoms and edges (bricks with bricks)
-        for i, brick1 in enumerate(self.bricks.bricks):
-            for j, brick2 in enumerate(self.bricks.bricks):
-                if i != j and self.check_adjacent(brick1, brick2, d=5):
-                    atom_node = f"Adjacent_Bricks_{i}_{j}_{atom_index}"
-                    graph.add_node(atom_node, type="atom", features=empty_feature_vector,predicate="Adjacent")
-                    graph.add_edge(f"brick_{i}", atom_node, position=0)
-                    graph.add_edge(f"brick_{j}", atom_node, position=1)
-                    atom_index += 1
-
-        # Create a GraphConverter object
-        converter = GraphConverter()
-
-        # Convert the NetworkX graph to a PyG Data object
-        data = converter.to_pyg_data(graph)
-        return data
-
-    def check_collision(self, rect1, rect2):
-        return rect1.colliderect(rect2)
-    
-    def check_proximity(self, obj1, obj2, d):
-        center1 = obj1.rect.center
-        center2 = obj2.rect.center
-        distance = np.sqrt((center1[0] - center2[0])**2 + (center1[1] - center2[1])**2)
-        return distance < d
-    
-    def check_directional_influence(self, rect1, rect2, theta):
-        # Check if rect1 is moving towards rect2 within a given angle theta
-        # Simplified for demonstration
-        return True  # Add your own logic here
-    
-    def check_adjacent(self, rect1, rect2, d):
-        return self.check_proximity(rect1, rect2, d)
+        object_features.append(paddle_features)
+
+        # left_wall_features = [0, 0, 0, 0, 0, 0, 1]
+        # object_features.append(left_wall_features)
+        # right_wall_features = [self.window_width, 0, 0, 0, 0, 0, 1]
+        # object_features.append(right_wall_features)
+        # top_wall_features = [0, 0, 0, 0, 0, 0, 1]
+        brick_count = 0
+        for brick in self.bricks.bricks:
+            brick_features = [brick.rect.x, brick.rect.y, 0, 0, 0, 0, 1]
+            object_features.append(brick_features) 
+            brick_count += 1
+        
+        while brick_count < self.total_bricks:
+            brick_features = [0, 0, 0, 0, 0, 0, 0]
+            object_features.append(brick_features)
+            brick_count += 1
 
+        return torch.tensor(object_features, dtype=torch.float32)
 
     def render(self, mode='human'):
-
-        pass # update turtle graphics if needed
+        if mode == 'human':
+            pygame.display.flip()
+        elif mode == 'rgb_array':
+            return pygame.surfarray.array3d(pygame.display.get_surface())
 
     def close(self):
         pygame.quit()
 
-    def check_collisions(self):
-        # Implement collision checks
-        reward = 0
-        # Implement collision logic with walls, paddle, bricks
-        # Adjust reward accordingly
-        return reward
-
-    def get_state(self):
-        # Get the surface array from Pygame
-        surface_array = pygame.surfarray.array3d(pygame.display.get_surface())
-        # Transpose the array from (width, height, channels) to (height, width, channels)
-        transposed_array = np.transpose(surface_array, axes=(1, 0, 2))
-        return transposed_array 
-    
-    def update_frame_buffer(self, new_frame):
-        # Shift frames to the left in the buffer and append the new frame on the right
-        # Ensure that the new_frame is transposed before being added to the frame buffer
-        self.frame_buffer = np.roll(self.frame_buffer, shift=-3, axis=2)
-        self.frame_buffer[:, :, -3:] = new_frame
-    
 if __name__ == "__main__":
     env = BreakoutEnv()
-    env.reset()
-    for _ in range(1000):
-        env.step(env.action_space.sample())
-        time.sleep(0.1)
-    env.close()
+    obs = env.reset()
+    done = False
+
+    while not done:
+        action = env.action_space.sample()
+        obs, reward, done, info = env.step(action)
+        env.render()
+        if reward < 0:
+            print("Ball lost")
+        if done:
+            print("Game Over. Restarting...")
+            obs = env.reset()
+            done = False
+
+    env.close()
\ No newline at end of file
diff --git a/games/breakout/bricks.py b/games/breakout/bricks.py
index 2bb97d4..02502f3 100644
--- a/games/breakout/bricks.py
+++ b/games/breakout/bricks.py
@@ -45,6 +45,7 @@ class Bricks:
         brick_height = 30
         row_spacing = 10  # Space between rows
         num_rows = 5  # Total number of rows
+        # total number of bricks
         
         for i in range(num_rows):
             y_cor = start_y + i * (brick_height + row_spacing)
diff --git a/games/encoder/GraphEncoder.py b/games/encoder/GraphEncoder.py
index 8f15c10..f15936b 100644
--- a/games/encoder/GraphEncoder.py
+++ b/games/encoder/GraphEncoder.py
@@ -1,27 +1,15 @@
 import torch
 import networkx as nx
-from itertools import combinations
-from collections import defaultdict
-from typing import NamedTuple
 from torch_geometric.data import HeteroData, Batch
-
-class PredicateEdgeType(NamedTuple):
-    src_type: str
-    pos: str
-    dst_type: str
-
-import torch
-import networkx as nx
-from torch_geometric.data import HeteroData
 from collections import defaultdict
 from itertools import combinations
 
-class HeteroGNNEncoder:
+class HeteroGNNEncoderPong:
     def __init__(self, obj_type_id: str = "obj", atom_type_id: str = "atom"):
         self.obj_type_id = obj_type_id
         self.atom_type_id = atom_type_id
 
-    def encode(self, batch_node_features: torch.Tensor, proximity_threshold: float = 1000) -> HeteroData:
+    def encode(self, batch_node_features: torch.Tensor, proximity_threshold: float = 150) -> Batch:
         batch_data = []
         batch_size = batch_node_features.size(0)
 
@@ -104,8 +92,399 @@ class HeteroGNNEncoder:
 
             data_list.append(data)
 
-        return data_list  
+        return data_list
+  
+
+
+
+class GraphEncoderFreeway:
+    def __init__(self, obj_type_id: str = "obj"):
+        self.obj_type_id = obj_type_id
+
+    def encode(self, batch_node_features: torch.Tensor, proximity_threshold: float = 50) -> Batch:
+        batch_data = []
+        batch_size = batch_node_features.size(0)
+
+        for b in range(batch_size):
+            node_features = batch_node_features[b]
+            num_nodes = node_features.size(0)
+            graph = nx.Graph()
+
+            # Adding object nodes
+            for i in range(num_nodes):
+                graph.add_node(i, type=self.obj_type_id, features=node_features[i].tolist())
+
+            # Adding atom nodes based on proximity and specific predicates
+            atom_index = num_nodes
+            object_feature_length = node_features.size(1)
+
+            # Add ChickenOnLane atoms and edges
+            for i in range(num_nodes):
+                if node_features[i, -3] == 1:  # Assuming the 5th feature is a flag for the chicken
+                    for j in range(num_nodes):
+                        if node_features[j, -2] == 1:  # Assuming the 6th feature is a flag for lanes
+                            if abs(node_features[i, 1] - node_features[j, 1]) <= 50:
+                                atom_features = torch.zeros((2, object_feature_length)).tolist()
+                                graph.add_node(atom_index, type="ChickenOnLane", features=atom_features)
+                                graph.add_edge(i, atom_index, position=0)
+                                graph.add_edge(j, atom_index, position=1)
+                                atom_index += 1
+
+            # Add CarOnLane atoms and edges
+            for i in range(num_nodes):
+                if node_features[i, -1] == 1:  # Assuming the last feature is a flag for cars
+                    for j in range(num_nodes):
+                        if node_features[j, -2] == 1:  # Assuming the 6th feature is a flag for lanes
+                            if abs(node_features[i, 1] - node_features[j, 1]) <= 50:
+                                atom_features = torch.zeros((2, object_feature_length)).tolist()
+                                graph.add_node(atom_index, type="CarOnLane", features=atom_features)
+                                graph.add_edge(i, atom_index, position=0)
+                                graph.add_edge(j, atom_index, position=1)
+                                atom_index += 1
+
+            # Add LaneNextToLane atoms and edges
+            lanes = [i for i in range(num_nodes) if node_features[i, -2] == 1]  # Collect lane nodes
+            for i in range(len(lanes) - 1):
+                atom_features = torch.zeros((2, object_feature_length)).tolist()
+                graph.add_node(atom_index, type="LaneNextToLane", features=atom_features)
+                graph.add_edge(lanes[i], atom_index, position=0)
+                graph.add_edge(lanes[i + 1], atom_index, position=1)
+                atom_index += 1
+
+            batch_data.append(graph)
+
+        return Batch.from_data_list(self.to_pyg_data(batch_data))
+
+    def to_pyg_data(self, batch_graphs):
+        data_list = []
+
+        for graph in batch_graphs:
+            data = HeteroData()
+            node_index_mapping = defaultdict(dict)
+            obj_features = []
+            atom_features_dict = defaultdict(list)
+            edge_dict = defaultdict(list)
+
+            current_obj_features = []
+            current_atom_features_dict = defaultdict(list)
+
+            for node, attrs in graph.nodes(data=True):
+                node_type = attrs['type']
+                features = torch.tensor(attrs['features'])
+                if node_type == self.obj_type_id:
+                    node_index_mapping[node_type][node] = len(current_obj_features)
+                    current_obj_features.append(features)
+                else:
+                    node_index_mapping[node_type][node] = len(current_atom_features_dict[node_type])
+                    current_atom_features_dict[node_type].append(features)
+
+            if current_obj_features:
+                obj_features.append(torch.stack(current_obj_features))
+            for node_type, features_list in current_atom_features_dict.items():
+                if features_list:
+                    flattened_features = [f.view(-1) for f in features_list]
+                    atom_features_dict[node_type].append(torch.stack(flattened_features))
+
+            if obj_features:
+                data[self.obj_type_id].x = torch.cat(obj_features)
+            for node_type, features_list in atom_features_dict.items():
+                if features_list:
+                    data[node_type].x = torch.cat(features_list)
+
+            for src, dst, attr in graph.edges(data=True):
+                src_type = graph.nodes[src]['type']
+                dst_type = graph.nodes[dst]['type']
+                pos = str(attr['position'])
+                edge_type = (src_type, pos, dst_type)
+
+                src_idx = node_index_mapping[src_type][src]
+                dst_idx = node_index_mapping[dst_type][dst]
+                edge_dict[edge_type].append((src_idx, dst_idx))
+                # Add reverse edges for bidirectionality
+                reverse_edge_type = (dst_type, pos, src_type)
+                edge_dict[reverse_edge_type].append((dst_idx, src_idx))
+
+            for edge_type, edges in edge_dict.items():
+                edge_tensor = torch.tensor(edges, dtype=torch.long).t().contiguous()
+                data[edge_type].edge_index = edge_tensor
+
+            data_list.append(data)
+
+        return data_list 
+
+class GraphEncoderPacman:
+    def __init__(self, obj_type_id: str = "obj", atom_type_id: str = "atom"):
+        self.obj_type_id = obj_type_id
+        self.atom_type_id = atom_type_id
+        self.grid_width = 21
+        self.grid_height = 25
+        self.map = {}
+
+    def load_map(self, level_num: int, script_path: str):
+        self.map = {}
+        file_path = os.path.join(script_path, "res", "levels", f"{level_num}.txt")
+        with open(file_path, 'r') as f:
+            line_num = -1
+            row_num = 0
+            is_reading_level_data = False
+
+            for line in f:
+                line_num += 1
+                line = line.strip()
+                if not line or line.startswith("'") or line.startswith("#"):
+                    continue
+
+                if line.startswith("#"):
+                    parts = line.split(' ')
+                    key = parts[1]
+
+                    if key == "lvlwidth":
+                        self.grid_width = int(parts[2])
+                    elif key == "lvlheight":
+                        self.grid_height = int(parts[2])
+                    elif key == "startleveldata":
+                        is_reading_level_data = True
+                        row_num = 0
+                    elif key == "endleveldata":
+                        is_reading_level_data = False
+                elif is_reading_level_data:
+                    values = list(map(int, line.split(' ')))
+                    for col, val in enumerate(values):
+                        self.map[(row_num, col)] = val
+                    row_num += 1
+
+    def GetMapTile(self, row, col):
+        return self.map.get((row, col), 0)
+
+    def IsWall(self, row, col):
+        if row > self.grid_height - 1 or row < 0:
+            return True
+        if col > self.grid_width - 1 or col < 0:
+            return True
+
+        result = self.GetMapTile(row, col)
+        if result >= 100 and result <= 199:
+            return True
+        else:
+            return False
+
+    def find_non_wall_cells(self):
+        non_wall_cells = []
+        for row in range(self.grid_height):
+            for col in range(self.grid_width):
+                if not self.IsWall(row, col):
+                    non_wall_cells.append((row, col))
+        return non_wall_cells
+
+    
+    def encode(self, batch_object_features: torch.Tensor) -> Batch:
+        batch_data = []
+        batch_size = batch_object_features.size(0)
+        non_wall_cells = self.find_non_wall_cells()
+        cell_feature_dim = batch_object_features.size(2)
+
+        for b in range(batch_size):
+            object_features = batch_object_features[b]
+            graph = nx.Graph()
+
+            # Add nodes for non-wall cells
+            for (i, j) in non_wall_cells:
+                cell_features = torch.zeros(cell_feature_dim).tolist()
+                cell_features[0] = i
+                cell_features[1] = j
+                graph.add_node((i, j), type="cell", features=cell_features)
+
+            atom_index = 0  # Atom index counter
+
+            # Add "to right of" relation and atom nodes
+            for (i, j) in non_wall_cells:
+                if (i, j + 1) in non_wall_cells:
+                    atom_features = torch.zeros((2, cell_feature_dim)).tolist()
+                    graph.add_node(atom_index, type="to_right_of", features=atom_features)
+                    graph.add_edge((i, j), atom_index, position=0)
+                    graph.add_edge((i, j + 1), atom_index, position=1)
+                    atom_index += 1
+
+                # Add "above" relation and atom nodes
+                if (i + 1, j) in non_wall_cells:
+                    atom_features = torch.zeros((2, cell_feature_dim)).tolist()
+                    graph.add_node(atom_index, type="above", features=atom_features)
+                    graph.add_edge((i, j), atom_index, position=0)
+                    graph.add_edge((i + 1, j), atom_index, position=1)
+                    atom_index += 1
+
+            # Add nodes and edges for objects
+            for obj_idx, (obj_x, obj_y) in enumerate(object_features[:, :2]):
+                obj_cell_x = int((obj_x + 8) / 16)
+                obj_cell_y = int((obj_y + 8) / 16)
+                obj_node = (obj_x, obj_y, "obj")
+                cell_node = (obj_cell_x, obj_cell_y)
+
+                graph.add_node(obj_node, type=self.obj_type_id, features=object_features[obj_idx].tolist())
+                
+                # Create an atom node for the "at" relation
+                atom_features = torch.zeros((2, cell_feature_dim)).tolist()
+                graph.add_node(atom_index, type="at", features=atom_features)
+                graph.add_edge(obj_node, atom_index, position=0)
+                graph.add_edge(cell_node, atom_index, position=1)
+                atom_index += 1
+
+            batch_data.append(graph)
+
+        return Batch.from_data_list(self.to_pyg_data(batch_data))
+
+    def to_pyg_data(self, batch_graphs):
+        data_list = []
+
+        for graph in batch_graphs:
+            data = HeteroData()
+            node_index_mapping = {self.obj_type_id: {}, self.atom_type_id: {}}
+            obj_features = []
+            atom_features = []
+            edge_dict = defaultdict(list)
+
+            current_obj_features = []
+            current_atom_features = []
+
+            for node, attrs in graph.nodes(data=True):
+                node_type = attrs['type']
+                features = torch.tensor(attrs['features'])
+                if node_type == self.obj_type_id:
+                    node_index_mapping[node_type][node] = len(current_obj_features)
+                    current_obj_features.append(features)
+                elif node_type == self.atom_type_id:
+                    node_index_mapping[node_type][node] = len(current_atom_features)
+                    current_atom_features.append(features)
+
+            if current_obj_features:
+                obj_features.append(torch.stack(current_obj_features))
+            if current_atom_features:
+                flattened_atom_features = [f.view(-1) for f in current_atom_features]
+                atom_features.append(torch.stack(flattened_atom_features))
+
+            if obj_features:
+                data[self.obj_type_id].x = torch.cat(obj_features)
+            if atom_features:
+                data[self.atom_type_id].x = torch.cat(atom_features)
+
+            for src, dst, attr in graph.edges(data=True):
+                src_type = graph.nodes[src]['type']
+                dst_type = graph.nodes[dst]['type']
+                pos = str(attr['position'])
+                edge_type = (src_type, pos, dst_type)
+
+                src_idx = node_index_mapping[src_type][src]
+                dst_idx = node_index_mapping[dst_type][dst]
+                edge_dict[edge_type].append((src_idx, dst_idx))
+                reverse_edge_type = (dst_type, pos, src_type)
+                edge_dict[reverse_edge_type].append((dst_idx, src_idx))
+
+            for edge_type, edges in edge_dict.items():
+                edge_tensor = torch.tensor(edges, dtype=torch.long).t().contiguous()
+                data[edge_type].edge_index = edge_tensor
+
+            data_list.append(data)
+
+        return data_list 
+    
+import networkx as nx
+import torch
+from torch_geometric.data import Data, HeteroData
+import numpy as np
+
+class BreakoutGraphEncoder:
+    def __init__(self, proximity_threshold=100, adjacency_threshold=5):
+        self.proximity_threshold = proximity_threshold
+        self.adjacency_threshold = adjacency_threshold
+
+    
+
+    def encode(self, batch_object_features: torch.Tensor) -> Batch:
+        batch_data = []
+        self.obj_type_id = "obj"
+        batch_size = batch_object_features.size(0)
+        cell_feature_dim = batch_object_features.size(2)
+
+        for b in range(batch_size):
+            object_features = batch_object_features[b]
+            # remove the values from batch_object_features that have all zeros in the vector
+            object_features = object_features[~torch.all(object_features == 0, dim=1)]
+            graph = nx.Graph()
+            num_nodes = object_features.size(0)
+            graph = nx.Graph()
+
+            # Adding object nodes
+            for i in range(num_nodes):
+                graph.add_node(i, type=self.obj_type_id, features=object_features[i].tolist())
+
+            atom_index = 0  # Atom index counter
+
+            
+
+            # Create an atom node for the "proximity" relation between all objects
+            atom_index = num_nodes
+            object_feature_length = object_features[i].size(1)
+            for i, j in combinations(range(num_nodes), 2):
+                dist = torch.norm(object_features[i, :2] - object_features[j, :2]).item()
+                if dist < self.proximity_threshold:
+                    # Create atom node with a 2D zero vector of the shape (2, object_feature_length)
+                    atom_features = torch.zeros((2, object_feature_length)).tolist()
+                    graph.add_node(atom_index, type=self.atom_type_id, features=atom_features)
+                    graph.add_edge(i, atom_index, position=0)
+                    graph.add_edge(j, atom_index, position=1)
+                    atom_index += 1
+
+            batch_data.append(graph)
+
+        return Batch.from_data_list(self.to_pyg_data(batch_data))
+
+
+
+    def check_proximity(self, obj1, obj2, threshold):
+        center1 = obj1[:2]
+        center2 = obj2[:2]
+        distance = torch.norm(torch.tensor(center1) - torch.tensor(center2)).item()
+        return distance < threshold
+
+    def check_adjacent(self, obj1, obj2, threshold):
+        return self.check_proximity(obj1, obj2, threshold)
+
+    def check_proximity(self, obj1, obj2, threshold):
+        center1 = obj1.rect.center
+        center2 = obj2.rect.center
+        distance = np.sqrt((center1[0] - center2[0]) ** 2 + (center1[1] - center2[1]) ** 2)
+        return distance < threshold
+
+    def check_adjacent(self, obj1, obj2, threshold):
+        return self.check_proximity(obj1, obj2, threshold)
+
+    def to_pyg_data(self, graph):
+        # Initialize a HeteroData object
+        data = HeteroData()
+
+        # Add nodes and their features
+        for node, attrs in graph.nodes(data=True):
+            node_type = attrs['type']
+            features = torch.tensor(attrs['features'], dtype=torch.float32)
+            if node_type not in data:
+                data[node_type].x = [features]
+            else:
+                data[node_type].x.append(features)
+
+        # Convert lists of features to tensors
+        for node_type in data.node_types:
+            data[node_type].x = torch.stack(data[node_type].x, dim=0)
 
+        # Add edges
+        for src, dst, attrs in graph.edges(data=True):
+            edge_type = (graph.nodes[src]['type'], attrs['position'], graph.nodes[dst]['type'])
+            if edge_type not in data.edge_types:
+                data[edge_type].edge_index = [[], []]
+            data[edge_type].edge_index[0].append(src)
+            data[edge_type].edge_index[1].append(dst)
 
-# Example usage
+        # Convert lists of edges to tensors
+        for edge_type in data.edge_types:
+            data[edge_type].edge_index = torch.tensor(data[edge_type].edge_index, dtype=torch.long)
 
+        return data
diff --git a/games/encoder/__pycache__/GraphEncoder.cpython-310.pyc b/games/encoder/__pycache__/GraphEncoder.cpython-310.pyc
index e89ae1d..c7a0e3d 100644
Binary files a/games/encoder/__pycache__/GraphEncoder.cpython-310.pyc and b/games/encoder/__pycache__/GraphEncoder.cpython-310.pyc differ
diff --git a/games/freeway/freeway_envs/freeway_env.py b/games/freeway/freeway_envs/freeway_env.py
index 7943cce..2251cbe 100644
--- a/games/freeway/freeway_envs/freeway_env.py
+++ b/games/freeway/freeway_envs/freeway_env.py
@@ -4,56 +4,67 @@ import numpy as np
 import gymnasium as gym
 from gymnasium import spaces
 import torch
-import torch_geometric
-from torch_geometric.data import Data
-from ...encoder.GraphEncoder import GraphConverter
 import networkx as nx
+from torch_geometric.data import HeteroData, Batch
+from collections import defaultdict
+from itertools import combinations
 
 class FreewayEnv(gym.Env):
-    metadata = {'render.modes': ['human', 'rgb_array']}
+    metadata = {'render_modes': ['human', 'rgb_array']}
 
-    def __init__(self):
+    def __init__(self, render_mode='human', observation_type='pixel', frame_stack=4):
         super(FreewayEnv, self).__init__()
         pygame.init()
+        self.render_mode = render_mode
+        self.observation_type = observation_type
         self.window_width = 800
         self.window_height = 600
         self.player_width = 30
         self.player_height = 30
         self.car_width = 50
-        self.car_height = 50 
+        self.car_height = 50
+        self.frame_stack = frame_stack
 
         self.lanes = [100, 200, 300, 400, 500, 600, 700]
 
         # Define action and observation space
         # Actions: 0 - Stay, 1 - Move Up, 2 - Move Down
         self.action_space = spaces.Discrete(3)
-        self.observation_space = spaces.Box(low=0, high=255,
-                                            shape=(self.window_height, self.window_width, 3 * self.frame_stack),
-                                            dtype=np.uint8)
-        # Load images
-        self.window = pygame.display.set_mode((self.window_width, self.window_height))
 
-        self.background_image = pygame.transform.scale(pygame.image.load("games/images/Atari - background.png"), (self.window_width, self.window_height))
-        self.player_image = pygame.transform.scale(pygame.image.load("games/images/chicken.png").convert_alpha(), (self.player_width, self.player_height))
-        self.car_image = pygame.transform.scale(pygame.image.load("games/images/car2.png").convert_alpha(), (self.car_width, self.car_height))
-        self.frame_buffer = np.zeros((self.window_height, self.window_width, 3 * self.frame_stack), dtype=np.uint8)
+        if observation_type == "pixel":
+            self.observation_space = spaces.Box(low=0, high=255, shape=(self.frame_stack, 84, 84), dtype=np.uint8)
+        else:
+            self.observation_space = spaces.Box(low=-np.inf, high=np.inf, shape=(self.max_cars + 3, 7), dtype=np.float32)
 
-        self.clock = pygame.time.Clock()
+        self.window = pygame.display.set_mode((self.window_width, self.window_height))
+        self.background_image = pygame.image.load("games/images/Atari - background.png")
+        self.background_image = pygame.transform.scale(self.background_image, (self.window_width, self.window_height))
+        self.player_image = pygame.image.load("games/images/chicken.png").convert_alpha()
+        self.player_image = pygame.transform.scale(self.player_image, (self.player_width, self.player_height))
+        self.car_image = pygame.image.load("games/images/car2.png").convert_alpha()
+        self.car_image = pygame.transform.scale(self.car_image, (self.car_width, self.car_height))
+        self.frame_buffer = np.zeros((self.frame_stack, 84, 84), dtype=np.uint8)
 
+        self.clock = pygame.time.Clock()
         self.reset()
 
     def reset(self):
         self.player_rect = pygame.Rect(self.window_width // 2 - self.player_width // 2,
-                                    self.window_height - self.player_height - 10,
-                                    self.player_width, self.player_height)
+                                       self.window_height - self.player_height - 10,
+                                       self.player_width, self.player_height)
         self.score = 0
         self.cars = [{'x': random.randint(0, self.window_width - self.car_width),
-                    'lane': random.choice([100, 200, 300, 400, 500, 600, 700]),
-                    'speed': random.randint(2, 5)} for _ in range(20)]
+                      'lane': random.choice(self.lanes),
+                      'speed': random.randint(2, 5)} for _ in range(20)]
         self.done = False
         self.episode_start_time = pygame.time.get_ticks()
-        self.frame_buffer = np.zeros((self.window_height, self.window_width, 3 * self.frame_stack), dtype=np.uint8)
-        return self.get_observation()
+        self.frame_buffer = np.zeros((self.frame_stack, 84, 84), dtype=np.uint8)
+        if self.observation_type == "pixel":
+            for _ in range(self.frame_stack):
+                self.update_frame_buffer()
+            return self.get_observation(), {}
+        else:
+            return self.get_object_data(), {}
 
     def step(self, action):
         if action == 1:  # Up
@@ -71,7 +82,6 @@ class FreewayEnv(gym.Env):
         hit = any(self.player_rect.colliderect(pygame.Rect(car['x'], car['lane'], self.car_width, self.car_height)) for car in self.cars)
         if hit:
             self.score = 0
-            # reset the player position
             self.player_rect.y = self.window_height - self.player_height - 10
 
         current_time = pygame.time.get_ticks()
@@ -81,107 +91,69 @@ class FreewayEnv(gym.Env):
         if self.player_rect.y <= 0:  # Reached top
             self.score += 1
             self.player_rect.y = self.window_height - self.player_height - 10
-        graph_data = self.get_graph_data()
 
-        return self.get_observation(), self.score, self.done, {}
-            
-    def get_graph_data(self):
-        # Initialize a NetworkX graph
-        graph = nx.Graph()
-
-        # Define object features and add nodes
-        chicken_features = [self.player_rect.x, self.player_rect.y, 5, 1, 0, 0]
-        graph.add_node("chicken", type="object", features=chicken_features)
-        
-        lane_features = [[0, lane, 0, 0, 1, 0] for lane in self.lanes]
-        for i, features in enumerate(lane_features):
-            graph.add_node(f"lane_{i}", type="object", features=features)
-
-        car_features = [[car['x'], car['lane'], car['speed'], 0, 0, 1] for car in self.cars]
-        for i, features in enumerate(car_features):
-            graph.add_node(f"car_{i}", type="object", features=features)
-
-        # Combine object positions
-        object_positions = {
-            "chicken": chicken_features[:2],
-        }
-        for i, lane in enumerate(self.lanes):
-            object_positions[f"lane_{i}"] = lane_features[i][:2]
-        for i, car in enumerate(self.cars):
-            object_positions[f"car_{i}"] = car_features[i][:2]
-
-
-        # Create atom nodes and edges based on proximity
-        atom_index = len(object_positions)  # Start indexing atoms after all objects
-        standard_feature_vector_size = len(chicken_features)
-        empty_feature_vector = [0] *(2* standard_feature_vector_size)
-
-        # Add ChickenOnLane atoms and edges
-        for i, lane in enumerate(self.lanes):
-            # check if the chicken is in the range of the lane of +-50
-                if self.player_rect.y >= lane - 50 and self.player_rect.y <= lane + 50:
-                    atom_node = f"ChickenOnLane_{atom_index}"
-                    graph.add_node(atom_node, type="atom", features=empty_feature_vector, predicate="ChickenOnLane")
-                    graph.add_edge("chicken", atom_node, position=0)
-                    graph.add_edge(f"lane_{i}", atom_node, position=1)
-                    atom_index += 1
-
-        # Add CarOnLane atoms and edges
-        num_lanes = len(self.lanes)
-        for i, car in enumerate(self.cars, start=num_lanes + 1):
-            car_lane_index = self.lanes.index(car['lane'])
-            atom_node = f"CarOnLane_{atom_index}"
-            graph.add_node(atom_node, type="atom",features=empty_feature_vector, predicate="CarOnLane")
-            graph.add_edge(f"car_{i - num_lanes - 1}", atom_node, position=0)
-            graph.add_edge(f"lane_{car_lane_index}", atom_node, position=1)
-            atom_index += 1
-
-        # Add LaneNextToLane atoms and edges
-        for i in range(num_lanes - 1):
-            atom_node = f"LaneNextToLane_{atom_index}"
-            graph.add_node(atom_node, type="atom",features=empty_feature_vector, predicate="LaneNextToLane")
-            graph.add_edge(f"lane_{i}", atom_node, position=0)
-            graph.add_edge(f"lane_{i + 1}", atom_node, position=1)
-            atom_index += 1
-
-        # Create a GraphConverter object
-        converter = GraphConverter()
-
-        # Convert the NetworkX graph to a PyG Data object
-        data = converter.to_pyg_data(graph)
-        return data
-    
-    def render(self, mode='human'):
+        if self.observation_type == "pixel":
+            self.update_frame_buffer()
+            observation = self.get_observation()
+        else:
+            observation = self.get_object_data()
+
+        return observation, self.score, self.done, False, {}
+
+    def update_frame_buffer(self):
+        frame = self.render_to_array()
+        grayscale = np.dot(frame[..., :3], [0.2989, 0.5870, 0.1140]).astype(np.uint8)  # Convert to grayscale
+        resized_frame = pygame.transform.scale(pygame.surfarray.make_surface(grayscale), (84, 84))
+        frame_array = pygame.surfarray.array3d(resized_frame).transpose(1, 0, 2)[:, :, 0]
+
+        self.frame_buffer = np.roll(self.frame_buffer, shift=-1, axis=0)
+        self.frame_buffer[-1] = frame_array
+
+    def render_to_array(self):
         self.window.blit(self.background_image, (0, 0))
         for car in self.cars:
             self.window.blit(self.car_image, (car['x'], car['lane']))
         self.window.blit(self.player_image, (self.player_rect.x, self.player_rect.y))
-        pygame.display.update()
+        return pygame.surfarray.array3d(self.window)
 
     def get_observation(self):
-        # You can also choose to return other representations of the game state
-        frame = pygame.surfarray.array3d(pygame.display.get_surface())
-        frame = frame.transpose((1, 0, 2))  # Correct the shape to (height, width, channels)
-        # Update frame buffer
-        self.frame_buffer = np.roll(self.frame_buffer, -3, axis=2)
-        self.frame_buffer[:, :, -3:] = frame
         return self.frame_buffer
 
+    def get_object_data(self):
+        objects = [
+            [self.player_rect.x, self.player_rect.y, 0, 0, 1, 0, 0],  # Player
+            [0, 0, 0, 0, 0, 1, 0],  # Top wall
+            [0, self.window_height, 0, 0, 0, 1, 0]  # Bottom wall
+        ]
+
+        for i, car in enumerate(self.cars):
+            objects.append([car['x'], car['lane'], car['speed'], 0, 0, 0, 1])
+
+        while len(objects) < self.max_cars + 3:  # Ensure the list has a constant length
+            objects.append([0, 0, 0, 0, 0, 0, 0])
+
+        return torch.tensor(objects, dtype=torch.float32)
+
+    def render(self, mode='human'):
+        self.window.blit(self.background_image, (0, 0))
+        for car in self.cars:
+            self.window.blit(self.car_image, (car['x'], car['lane']))
+        self.window.blit(self.player_image, (self.player_rect.x, self.player_rect.y))
+        pygame.display.update()
+
     def close(self):
         pygame.quit()
 
-# Example usage
 if __name__ == "__main__":
-    env = FreewayEnv()
+    env = FreewayEnv(render_mode='human', observation_type='pixel')
     env.reset()
 
     done = False
     try:
         while not done:
             action = env.action_space.sample()
-            _, _, done, _ = env.step(action)
+            _, _, done, _,_ = env.step(action)
             env.render()
             pygame.time.wait(10)
     finally:
-        print(done)
-        env.close() 
+        env.close()
diff --git a/games/model/__pycache__/policy.cpython-310.pyc b/games/model/__pycache__/policy.cpython-310.pyc
index 3bf6443..d2352bb 100644
Binary files a/games/model/__pycache__/policy.cpython-310.pyc and b/games/model/__pycache__/policy.cpython-310.pyc differ
diff --git a/games/model/policy.py b/games/model/policy.py
index 212fde2..a554772 100644
--- a/games/model/policy.py
+++ b/games/model/policy.py
@@ -5,12 +5,12 @@ from stable_baselines3.common.policies import ActorCriticPolicy
 from stable_baselines3.common.torch_layers import BaseFeaturesExtractor
 from games.model.hetero_gnn import HeteroGNN
 from typing import Dict
-from games.encoder.GraphEncoder import HeteroGNNEncoder
+from games.encoder.GraphEncoder import HeteroGNNEncoderPong
 from gymnasium import spaces
 import torch
 import torch.nn as nn
 from stable_baselines3.common.torch_layers import BaseFeaturesExtractor
-from games.encoder.GraphEncoder import HeteroGNNEncoder
+from games.encoder.GraphEncoder import HeteroGNNEncoderPong
 from games.model.hetero_gnn import HeteroGNN
 import torch_geometric as pyg
 from games.model.cnn_model import CNNgame
@@ -18,7 +18,7 @@ from games.model.cnn_model import CNNgame
 class CustomHeteroGNN(BaseFeaturesExtractor):
     def __init__(self, observation_space, features_dim=64, hidden_size=64, num_layer=2, obj_type_id='obj', arity_dict={'atom': 2}):
         super().__init__(observation_space, features_dim=hidden_size)
-        self.encoder = HeteroGNNEncoder()
+        self.encoder = HeteroGNNEncoderPong()
         self.model = HeteroGNN(hidden_size, num_layer, obj_type_id, arity_dict)
 
     def forward(self, observations):
Submodule games/pacman contains modified content
Submodule games/pacman d62bf30..82c0b9f:
diff --git a/games/pacman/.DS_Store b/games/pacman/.DS_Store
new file mode 100644
index 0000000..a8095f6
Binary files /dev/null and b/games/pacman/.DS_Store differ
diff --git a/games/pacman/.gitignore b/games/pacman/.gitignore
deleted file mode 100644
index 574e611..0000000
--- a/games/pacman/.gitignore
+++ /dev/null
@@ -1,67 +0,0 @@
-# Byte-compiled / optimized / DLL files
-__pycache__/
-*.py[cod]
-*$py.class
-
-# C extensions
-*.so
-
-# Distribution / packaging
-.Python
-venv/
-build/
-develop-eggs/
-dist/
-downloads/
-eggs/
-.eggs/
-lib/
-lib64/
-parts/
-sdist/
-var/
-*.egg-info/
-.installed.cfg
-*.egg
-MANIFEST
-MANIFEST.in
-
-# PyInstaller
-#  Usually these files are written by a python script from a template
-#  before PyInstaller builds the exe, so as to inject date/other infos into it.
-*.manifest
-*.spec
-
-# Installer logs
-pip-log.txt
-pip-delete-this-directory.txt
-
-# Unit test / coverage reports
-htmlcov/
-.tox/
-.coverage
-.coverage.*
-.cache
-nosetests.xml
-coverage.xml
-*,cover
-.hypothesis/
-
-# Translations
-*.mo
-*.pot
-
-# Django stuff:
-*.log
-
-# Sphinx documentation
-docs/_build/
-
-# PyBuilder
-target/
-
-# pyenv python configuration file
-.python-version
-
-#pycharm
-.idea*
diff --git a/games/pacman/README.md b/games/pacman/README.md
deleted file mode 100644
index 97dbc8a..0000000
--- a/games/pacman/README.md
+++ /dev/null
@@ -1,17 +0,0 @@
-# Pacman
-Classic pacman game built in python using pygame
-
-<img alt="pacman gameplay" src="https://github.com/shivammathur/pacman/raw/master/images/play.png" width="42%"> <img alt="win pacman game" src="https://github.com/shivammathur/pacman/raw/master/images/win.png" width="42%">
-
-## Setup
-```shell script
-pip install requirements.txt
-```
-
-## Run
-```shell script
-python pacman.py   
-```
-
-## References
-https://github.com/hbokmann/Pacman - Improved code and UI
\ No newline at end of file
diff --git a/games/pacman/__init__.py b/games/pacman/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/games/pacman/config.py b/games/pacman/config.py
new file mode 100644
index 0000000..73568ce
--- /dev/null
+++ b/games/pacman/config.py
@@ -0,0 +1,40 @@
+import pygame, sys, os, random
+from pygame.locals import *
+
+# WIN???
+SCRIPT_PATH=sys.path[0]+"/games/pacman"
+
+# NO_GIF_TILES -- tile numbers which do not correspond to a GIF file
+# currently only "23" for the high-score list
+NO_GIF_TILES=[23]
+
+NO_WX=0 # if set, the high-score code will not attempt to ask the user his name
+USER_NAME="User" # USER_NAME=os.getlogin() # the default user name if wx fails to load or NO_WX
+
+# Joystick defaults - maybe add a Preferences dialog in the future?
+JS_DEVNUM=0 # device 0 (pygame joysticks always start at 0). if JS_DEVNUM is not a valid device, will use 0
+JS_XAXIS=0 # axis 0 for left/right (default for most joysticks)
+JS_YAXIS=1 # axis 1 for up/down (default for most joysticks)
+JS_STARTBUTTON=0 # button number to start the game. this is a matter of personal preference, and will vary from device to device
+
+# Must come before pygame.init()
+pygame.mixer.pre_init(22050,16,2,512)
+JS_STARTBUTTON=0 # button number to start the game. this is a matter of personal preference, and will vary from device to device
+pygame.mixer.init()
+
+clock = pygame.time.Clock()
+pygame.init()
+
+window = pygame.display.set_mode((1, 1))
+pygame.display.set_caption("Pacman")
+
+screen = pygame.display.get_surface()
+
+# set up the colors 
+ghostcolor = {}
+ghostcolor[0] = (255, 0, 0, 255)
+ghostcolor[1] = (255, 128, 255, 255)
+ghostcolor[2] = (128, 255, 255, 255)
+ghostcolor[3] = (255, 128, 0, 255)
+ghostcolor[4] = (50, 50, 255, 255) # blue, vulnerable ghost
+ghostcolor[5] = (255, 255, 255, 255) # white, flashing ghost
\ No newline at end of file
diff --git a/games/pacman/fruit.py b/games/pacman/fruit.py
new file mode 100644
index 0000000..51e2b1c
--- /dev/null
+++ b/games/pacman/fruit.py
@@ -0,0 +1,112 @@
+from games.pacman.config import *
+
+class fruit ():
+    def __init__ (self):
+        # when fruit is not in use, it's in the (-1, -1) position off-screen.
+        self.slowTimer = 0
+        self.x = -16
+        self.y = -16
+        self.velX = 0
+        self.velY = 0
+        self.speed = 1
+        self.active = False
+        #self.thisGame = thisGame
+        
+        self.bouncei = 0
+        self.bounceY = 0
+        
+        self.nearestRow = (-1, -1)
+        self.nearestCol = (-1, -1)
+        
+        self.imFruit = {}
+        for i in range(0, 5, 1):
+            self.imFruit[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","fruit " + str(i) + ".gif")).convert()
+        
+        self.currentPath = ""
+        self.fruitType = 1
+        
+    def Draw (self, thisGame):
+        
+        if thisGame.mode == 3 or self.active == False:
+            return False
+        
+        screen.blit (self.imFruit[ self.fruitType ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1] - self.bounceY))
+
+            
+    def Move (self, thisGame):
+        
+        if self.active == False:
+            return False
+        
+        self.bouncei += 1
+        if self.bouncei == 1:
+            self.bounceY = 2
+        elif self.bouncei == 2:
+            self.bounceY = 4
+        elif self.bouncei == 3:
+            self.bounceY = 5
+        elif self.bouncei == 4:
+            self.bounceY = 5
+        elif self.bouncei == 5:
+            self.bounceY = 6
+        elif self.bouncei == 6:
+            self.bounceY = 6
+        elif self.bouncei == 9:
+            self.bounceY = 6
+        elif self.bouncei == 10:
+            self.bounceY = 5
+        elif self.bouncei == 11:
+            self.bounceY = 5
+        elif self.bouncei == 12:
+            self.bounceY = 4
+        elif self.bouncei == 13:
+            self.bounceY = 3
+        elif self.bouncei == 14:
+            self.bounceY = 2
+        elif self.bouncei == 15:
+            self.bounceY = 1
+        elif self.bouncei == 16:
+            self.bounceY = 0
+            self.bouncei = 0
+            #snd_fruitbounce.play()
+        
+        self.slowTimer += 1
+        if self.slowTimer == 2:
+            self.slowTimer = 0
+            
+            self.x += self.velX
+            self.y += self.velY
+            
+            self.nearestRow = int(((self.y + 8) / 16))
+            self.nearestCol = int(((self.x + 8) / 16))
+
+            if (self.x % 16) == 0 and (self.y % 16) == 0:
+                # if the fruit is lined up with the grid again
+                # meaning, it's time to go to the next path item
+                
+                if len(self.currentPath) > 0:
+                    self.currentPath = self.currentPath[1:]
+                    self.FollowNextPathWay()
+            
+                else:
+                    self.x = self.nearestCol * 16
+                    self.y = self.nearestRow * 16
+                    
+                    self.active = False
+                    thisGame.fruitTimer = 0
+            
+    def FollowNextPathWay (self):
+        
+
+        # only follow this pathway if there is a possible path found!
+        if not self.currentPath == False:
+        
+            if len(self.currentPath) > 0:
+                if self.currentPath[0] == "L":
+                    (self.velX, self.velY) = (-self.speed, 0)
+                elif self.currentPath[0] == "R":
+                    (self.velX, self.velY) = (self.speed, 0)
+                elif self.currentPath[0] == "U":
+                    (self.velX, self.velY) = (0, -self.speed)
+                elif self.currentPath[0] == "D":
+                    (self.velX, self.velY) = (0, self.speed)
diff --git a/games/pacman/game.py b/games/pacman/game.py
new file mode 100644
index 0000000..334c813
--- /dev/null
+++ b/games/pacman/game.py
@@ -0,0 +1,214 @@
+from games.pacman.config import *
+import os
+import pygame
+
+class game ():
+
+    def defaulthiscorelist(self):
+            return [ (100000,"David") , (80000,"Andy") , (60000,"Count Pacula") , (40000,"Cleopacra") , (20000,"Brett Favre") , (10000,"Sergei Pachmaninoff") ]
+
+    def gethiscores(self):
+            """If res/hiscore.txt exists, read it. If not, return the default high scores.
+               Output is [ (score,name) , (score,name) , .. ]. Always 6 entries."""
+            try:
+              f=open(os.path.join(SCRIPT_PATH,"res","hiscore.txt"))
+              hs=[]
+              for line in f:
+                while len(line)>0 and (line[0]=="\n" or line[0]=="\r"): line=line[1:]
+                while len(line)>0 and (line[-1]=="\n" or line[-1]=="\r"): line=line[:-1]
+                score=int(line.split(" ")[0])
+                name=line.partition(" ")[2]
+                if score>99999999: score=99999999
+                if len(name)>22: name=name[:22]
+                hs.append((score,name))
+              f.close()
+              if len(hs)>6: hs=hs[:6]
+              while len(hs)<6: hs.append((0,""))
+              return hs
+            except IOError:
+              return self.defaulthiscorelist()
+              
+    def writehiscores(self,hs):
+            """Given a new list, write it to the default file."""
+            fname=os.path.join(SCRIPT_PATH,"res","hiscore.txt")
+            f=open(fname,"w")
+            for line in hs:
+              f.write(str(line[0])+" "+line[1]+"\n")
+            f.close()
+            
+    def getplayername(self):
+            """Ask the player his name, to go on the high-score list."""
+            if NO_WX: return USER_NAME
+            try:
+              import wx
+            except:
+              print("Pacman Error: No module wx. Can not ask the user his name!")
+              print( "     :(       Download wx from http://www.wxpython.org/")
+              print( "     :(       To avoid seeing this error again, set NO_WX in file pacman.pyw.")
+              return USER_NAME
+            app=wx.App(None)
+            dlog=wx.TextEntryDialog(None,"You made the high-score list! Name:")
+            dlog.ShowModal()
+            name=dlog.GetValue()
+            dlog.Destroy()
+            app.Destroy()
+            return name
+              
+    def updatehiscores(self,newscore):
+            """Add newscore to the high score list, if appropriate."""
+            hs=self.gethiscores()
+            for line in hs:
+              if newscore>=line[0]:
+                hs.insert(hs.index(line),(newscore,self.getplayername()))
+                hs.pop(-1)
+                break
+            self.writehiscores(hs)
+
+    def makehiscorelist(self):
+            "Read the High-Score file and convert it to a useable Surface."
+            # My apologies for all the hard-coded constants.... -Andy
+            f=pygame.font.Font(os.path.join(SCRIPT_PATH,"res","VeraMoBd.ttf"),10)
+            scoresurf=pygame.Surface((276,86),pygame.SRCALPHA)
+            scoresurf.set_alpha(200)
+            linesurf=f.render(" "*18+"HIGH SCORES",1,(255,255,0))
+            scoresurf.blit(linesurf,(0,0))
+            hs=self.gethiscores()
+            vpos=0
+            for line in hs:
+              vpos+=12
+              linesurf=f.render(line[1].rjust(22)+str(line[0]).rjust(9),1,(255,255,255))
+              scoresurf.blit(linesurf,(0,vpos))
+            return scoresurf
+            
+    def drawmidgamehiscores(self):
+            """Redraw the high-score list image after pacman dies."""
+            self.imHiscores=self.makehiscorelist()
+
+    def __init__ (self, thisFruit, player, screen):
+        self.player = player
+        self.screen = screen
+        self.thisFruit = thisFruit
+        self.levelNum = 0
+        self.score = 0
+        self.lives = 3
+        
+        # game "mode" variable
+        # 1 = normal
+        # 2 = hit ghost
+        # 3 = game over
+        # 4 = wait to start
+        # 5 = wait after eating ghost
+        # 6 = wait after finishing level
+        self.mode = 0
+        self.modeTimer = 0
+        self.ghostTimer = 0
+        self.ghostValue = 0
+        self.fruitTimer = 0
+        self.fruitScoreTimer = 0
+        self.fruitScorePos = (0, 0)
+        
+        self.SetMode( 4 )
+        
+        # camera variables
+        self.screenPixelPos = (0, 0) # absolute x,y position of the screen from the upper-left corner of the level
+        self.screenNearestTilePos = (0, 0) # nearest-tile position of the screen from the UL corner
+        self.screenPixelOffset = (0, 0) # offset in pixels of the screen from its nearest-tile position
+        
+        self.screenTileSize = (23, 21)
+        self.screenSize = (self.screenTileSize[1] * 16, self.screenTileSize[0] * 16)
+
+        # numerical display digits
+        self.digit = {}
+        for i in range(0, 10, 1):
+            self.digit[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","text",str(i) + ".gif")).convert()
+        self.imLife = pygame.image.load(os.path.join(SCRIPT_PATH,"res","text","life.gif")).convert()
+        self.imGameOver = pygame.image.load(os.path.join(SCRIPT_PATH,"res","text","gameover.gif")).convert()
+        self.imReady = pygame.image.load(os.path.join(SCRIPT_PATH,"res","text","ready.gif")).convert()
+        self.imLogo = pygame.image.load(os.path.join(SCRIPT_PATH,"res","text","logo.gif")).convert()
+        self.imHiscores = self.makehiscorelist()
+        
+    def StartNewGame (self, thisLevel, tileID, tileIDImage, tileIDName):
+        self.levelNum = 1
+        self.score = 0
+        self.lives = 3
+        
+        self.SetMode( 1 )
+        thisLevel.LoadLevel( self.GetLevelNum(), tileID, tileIDImage , tileIDName)
+            
+    def AddToScore (self, amount):
+        
+        extraLifeSet = [25000, 50000, 100000, 150000]
+        
+        for specialScore in extraLifeSet:
+            if self.score < specialScore and self.score + amount >= specialScore:
+                #snd_extralife.play()
+                self.lives += 1
+        
+        self.score += amount
+        
+    
+    def DrawScore (self):
+        self.DrawNumber (self.score, 24 + 16, self.screenSize[1] - 24 )
+            
+        for i in range(0, self.lives, 1):
+            screen.blit (self.imLife, (24 + i * 10 + 16, self.screenSize[1] - 12) )
+            
+        screen.blit (self.thisFruit.imFruit[ self.thisFruit.fruitType ], (4 + 16, self.screenSize[1] - 20) )
+            
+        if self.mode == 3:
+            screen.blit (self.imGameOver, (self.screenSize[0] / 2 - 32, self.screenSize[1] / 2 - 10) )
+        elif self.mode == 4:
+            screen.blit (self.imReady, (self.screenSize[0] / 2 - 20, self.screenSize[1] / 2 + 12) )
+            
+        self.DrawNumber (self.levelNum, 0, self.screenSize[1] - 12 )
+            
+    def DrawNumber (self, number, x, y):
+        strNumber = str(int(number))
+        for i in range(0, len(strNumber), 1):
+            iDigit = int(strNumber[i])
+            screen.blit (self.digit[ iDigit ], (x + i * 9, y) )
+        
+    def SmartMoveScreen (self, thisLevel):
+            
+        possibleScreenX = self.player.x - self.screenTileSize[1] / 2 * 16
+        possibleScreenY = self.player.y - self.screenTileSize[0] / 2 * 16
+        
+        if possibleScreenX < 0:
+            possibleScreenX = 0
+        elif possibleScreenX > thisLevel.lvlWidth * 16 - self.screenSize[0]:
+            possibleScreenX = thisLevel.lvlWidth * 16 - self.screenSize[0]
+            
+        if possibleScreenY < 0:
+            possibleScreenY = 0
+        elif possibleScreenY > thisLevel.lvlHeight * 16 - self.screenSize[1]:
+            possibleScreenY = thisLevel.lvlHeight * 16 - self.screenSize[1]
+        
+        self.MoveScreen( possibleScreenX, possibleScreenY )
+        
+    def MoveScreen (self, newX, newY ):
+        self.screenPixelPos = (newX, newY)
+        self.screenNearestTilePos = (int(newY / 16), int(newX / 16)) # nearest-tile position of the screen from the UL corner
+        self.screenPixelOffset = (newX - self.screenNearestTilePos[1]*16, newY - self.screenNearestTilePos[0]*16)
+        
+    def GetScreenPos (self):
+        return self.screenPixelPos
+        
+    def GetLevelNum (self):
+        return self.levelNum
+    
+    def SetNextLevel (self):
+        self.levelNum += 1
+        
+        self.SetMode( 4 )
+        self.thisLevel.LoadLevel( self.thisGame.GetLevelNum() )
+        
+        self.player.velX = 0
+        self.player.velY = 0
+        self.player.anim_pacmanCurrent = self.player.anim_pacmanS
+        
+        
+    def SetMode (self, newMode):
+        self.mode = newMode
+        self.modeTimer = 0
+        # print " ***** GAME MODE IS NOW ***** " + str(newMode)
+        
\ No newline at end of file
diff --git a/games/pacman/ghost.py b/games/pacman/ghost.py
new file mode 100644
index 0000000..2f7d194
--- /dev/null
+++ b/games/pacman/ghost.py
@@ -0,0 +1,174 @@
+from games.pacman.config import *
+
+class ghost ():
+    def __init__ (self, ghostID, path, screen, player):
+        self.player = player
+        self.screen = screen
+        self.path = path
+        self.x = 0
+        self.y = 0
+        self.velX = 0
+        self.velY = 0
+        self.speed = 1
+        self.ghostTimer = 0
+        self.nearestRow = 0
+        self.nearestCol = 0
+        
+        self.id = ghostID
+        
+        # ghost "state" variable
+        # 1 = normal
+        # 2 = vulnerable
+        # 3 = spectacles
+        self.state = 1
+        
+        self.homeX = 0
+        self.homeY = 0
+        
+        self.currentPath = ""
+        
+        self.anim = {}
+        for i in range(1, 7, 1):
+            self.anim[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","ghost " + str(i) + ".gif")).convert()
+            
+            # change the ghost color in this frame 
+            for y in range(0, 16, 1):
+                for x in range(0, 16, 1):
+                
+                    if self.anim[i].get_at( (x, y) ) == (255, 0, 0, 255):
+                        # default, red ghost body color
+                        self.anim[i].set_at( (x, y), ghostcolor[ self.id ] )
+            
+        self.animFrame = 1
+        self.animDelay = 0
+        
+    def Draw (self, thisGame, tileID, tileIDImage, ghosts):
+        
+        if thisGame.mode == 3:
+            return False
+        
+        
+        # ghost eyes --
+        for y in range(4, 8, 1):
+            for x in range(3, 7, 1):
+                self.anim[ self.animFrame ].set_at( (x, y), (255, 255, 255, 255) )  
+                self.anim[ self.animFrame ].set_at( (x+6, y), (255, 255, 255, 255) )
+                
+                if self.player.x > self.x and self.player.y > self.y:
+                    #player is to lower-right
+                    pupilSet = (5, 6)
+                elif self.player.x < self.x and self.player.y > self.y:
+                    #player is to lower-left
+                    pupilSet = (3, 6)
+                elif self.player.x > self.x and self.player.y < self.y:
+                    #player is to upper-right
+                    pupilSet = (5, 4)
+                elif self.player.x < self.x and self.player.y < self.y:
+                    #player is to upper-left
+                    pupilSet = (3, 4)
+                else:
+                    pupilSet = (4, 6)
+                    
+        for y in range(pupilSet[1], pupilSet[1] + 2, 1):
+            for x in range(pupilSet[0], pupilSet[0] + 2, 1):
+                self.anim[ self.animFrame ].set_at( (x, y), (0, 0, 255, 255) )  
+                self.anim[ self.animFrame ].set_at( (x+6, y), (0, 0, 255, 255) )    
+        # -- end ghost eyes
+        
+        if self.state == 1:
+            # draw regular ghost (this one)
+            self.screen.blit (self.anim[ self.animFrame ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
+        elif self.state == 2:
+            # draw vulnerable ghost
+            
+            if thisGame.ghostTimer > 100:
+                # blue
+                screen.blit (ghosts[4].anim[ self.animFrame ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
+            else:
+                # blue/white flashing
+                tempTimerI = int(thisGame.ghostTimer / 10)
+                if tempTimerI == 1 or tempTimerI == 3 or tempTimerI == 5 or tempTimerI == 7 or tempTimerI == 9:
+                    screen.blit (ghosts[5].anim[ self.animFrame ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
+                else:
+                    screen.blit (ghosts[4].anim[ self.animFrame ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
+            
+        elif self.state == 3:
+            # draw glasses
+            self.screen.blit (tileIDImage[ tileID[ 'glasses' ] ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
+        
+        if thisGame.mode == 6 or thisGame.mode == 7:
+            # don't animate ghost if the level is complete
+            return False
+        
+        self.animDelay += 1
+        
+        if self.animDelay == 2:
+            self.animFrame += 1 
+        
+            if self.animFrame == 7:
+                # wrap to beginning
+                self.animFrame = 1
+                
+            self.animDelay = 0
+            
+    def Move (self, thisLevel, tileID):
+        
+
+        self.x += self.velX
+        self.y += self.velY
+        
+        self.nearestRow = int(((self.y + 8) / 16))
+        self.nearestCol = int(((self.x + 8) / 16))
+
+        if (self.x % 16) == 0 and (self.y % 16) == 0:
+            # if the ghost is lined up with the grid again
+            # meaning, it's time to go to the next path item
+            
+            if (self.currentPath):
+                self.currentPath = self.currentPath[1:]
+                self.FollowNextPathWay(thisLevel, tileID)
+        
+            else:
+                self.x = self.nearestCol * 16
+                self.y = self.nearestRow * 16
+            
+                # chase pac-man
+                self.currentPath = self.path.FindPath( (self.nearestRow, self.nearestCol), (self.player.nearestRow, self.player.nearestCol) )
+                self.FollowNextPathWay(thisLevel, tileID)
+            
+    def FollowNextPathWay(self, thisLevel, tileID, counter=0, max_recursion_depth=900):
+        # Stop recursion if the maximum depth is reached
+        if counter >= max_recursion_depth:
+            return
+
+        # only follow this pathway if there is a possible path found!
+        if not self.currentPath == False:
+            if len(self.currentPath) > 0:
+                if self.currentPath[0] == "L":
+                    (self.velX, self.velY) = (-self.speed, 0)
+                elif self.currentPath[0] == "R":
+                    (self.velX, self.velY) = (self.speed, 0)
+                elif self.currentPath[0] == "U":
+                    (self.velX, self.velY) = (0, -self.speed)
+                elif self.currentPath[0] == "D":
+                    (self.velX, self.velY) = (0, self.speed)
+            else:
+                # this ghost has reached his destination!!
+                if not self.state == 3:
+                    # chase pac-man
+                    self.currentPath = self.path.FindPath((self.nearestRow, self.nearestCol), (self.player.nearestRow, self.player.nearestCol))
+                    self.FollowNextPathWay(thisLevel, tileID, counter+1) 
+                else:
+                    # glasses found way back to ghost box
+                    self.state = 1
+                    self.speed = self.speed / 4
+
+                    # give ghost a path to a random spot (containing a pellet)
+                    (randRow, randCol) = (0, 0)
+
+                    while not thisLevel.GetMapTile(randRow, randCol) == tileID['pellet'] or (randRow, randCol) == (0, 0):
+                        randRow = random.randint(1, thisLevel.lvlHeight - 2)
+                        randCol = random.randint(1, thisLevel.lvlWidth - 2)
+
+                    self.currentPath = self.path.FindPath((self.nearestRow, self.nearestCol), (randRow, randCol))
+                    self.FollowNextPathWay(thisLevel, tileID, counter+1)
\ No newline at end of file
diff --git a/games/pacman/level.py b/games/pacman/level.py
new file mode 100644
index 0000000..43a7900
--- /dev/null
+++ b/games/pacman/level.py
@@ -0,0 +1,897 @@
+from games.pacman.config import *
+
+# class level ():
+    
+#     def __init__ (self, game, player, ghosts, path, Fruit, screen):
+#         self.player = player
+#         self.ghosts = ghosts
+#         self.path = path
+#         self.thisFruit = Fruit
+#         self.lvlWidth = 0
+#         self.lvlHeight = 0
+#         self.edgeLightColor = (255, 255, 0, 255)
+#         self.edgeShadowColor = (255, 150, 0, 255)
+#         self.fillColor = (0, 255, 255, 255)
+#         self.pelletColor = (255, 255, 255, 255)
+#         self.thisLevel = level
+#         # self.snd_pellet = snd_pellet
+#         # self.snd_powerpellet = snd_powerpellet
+#         self.map = {}
+#         self.thisGame = game
+#         self.pellets = 0
+#         self.powerPelletBlinkTimer = 0
+#         self.screen = screen
+        
+#     def SetMapTile (self, row, col, newValue):
+#         self.map[ (row * self.lvlWidth) + col ] = newValue
+        
+#     def GetMapTile (self, row, col):
+#         if row >= 0 and row < self.lvlHeight and col >= 0 and col < self.lvlWidth:
+#             return self.map[ (row * self.lvlWidth) + col ]
+#         else:
+#             return 0
+    
+#     def IsWall (self, row, col):
+    
+#         if row > self.lvlHeight - 1 or row < 0:
+#             return True
+        
+#         if col > self.lvlWidth - 1 or col < 0:
+#             return True
+    
+#         # check the offending tile ID
+#         result = self.GetMapTile(row, col)
+
+#         # if the tile was a wall
+#         if result >= 100 and result <= 199:
+#             return True
+#         else:
+#             return False
+    
+#     def GetWallLocations(self):
+#         wallLocations = []
+#         for row in range(self.lvlHeight):
+#             for col in range(self.lvlWidth):
+#                 if self.IsWall(row, col):
+#                     wallLocations.append((row, col))
+#         return wallLocations 
+    
+#     def GetPelletLocations(self):
+#         pelletLocations = []
+#         for row in range(self.lvlHeight):
+#             for col in range(self.lvlWidth):
+#                 if self.GetMapTile(row, col) == 2:
+#                     pelletLocations.append((row*16, col*16))
+#         return pelletLocations
+    
+#     def GetPowerPelletLocations(self):
+#         powerPelletLocations = []
+#         for row in range(self.lvlHeight):
+#             for col in range(self.lvlWidth):
+#                 if self.GetMapTile(row, col) == 3:
+#                     powerPelletLocations.append((row, col))
+#         return powerPelletLocations
+    
+
+                    
+#     def CheckIfHitWall (self, possiblePlayerX, possiblePlayerY, row, col):
+    
+#         numCollisions = 0
+        
+#         # check each of the 9 surrounding tiles for a collision
+#         for iRow in range(row - 1, row + 2, 1):
+#             for iCol in range(col - 1, col + 2, 1):
+            
+#                 if  (possiblePlayerX - (iCol * 16) < 16) and (possiblePlayerX - (iCol * 16) > -16) and (possiblePlayerY - (iRow * 16) < 16) and (possiblePlayerY - (iRow * 16) > -16):
+                    
+#                     if self.IsWall(iRow, iCol):
+#                         numCollisions += 1
+                        
+#         if numCollisions > 0:
+#             return True
+#         else:
+#             return False
+        
+        
+#     def CheckIfHit (self, playerX, playerY, x, y, cushion):
+    
+#         if (playerX - x < cushion) and (playerX - x > -cushion) and (playerY - y < cushion) and (playerY - y > -cushion):
+#             return True
+#         else:
+#             return False
+        
+#     # check if player has hit a pellet, powerpellet or a wall
+#     def CheckIfHit(self, playerX, playerY, row, col, tileID):
+        
+#             for iRow in range(row - 1, row + 2, 1):
+#                 for iCol in range(col - 1, col + 2, 1):
+                
+#                     if  (playerX - (iCol * 16) < 16) and (playerX - (iCol * 16) > -16) and (playerY - (iRow * 16) < 16) and (playerY - (iRow * 16) > -16):
+#                         # check the offending tile ID
+#                         result = self.GetMapTile(iRow, iCol)
+            
+#                         if result == tileID:
+#                             return True   
+#                         elif result >= 100 and result <= 199:
+#                             return True
+#                         else:
+#                             return False
+
+
+#     def CheckIfHitSomething (self, playerX, playerY, row, col, tileID):
+    
+#         for iRow in range(row - 1, row + 2, 1):
+#             for iCol in range(col - 1, col + 2, 1):
+            
+#                 if  (playerX - (iCol * 16) < 16) and (playerX - (iCol * 16) > -16) and (playerY - (iRow * 16) < 16) and (playerY - (iRow * 16) > -16):
+#                     # check the offending tile ID
+#                     result = self.GetMapTile(iRow, iCol)
+        
+#                     if result == tileID[ 'pellet' ]:
+#                         # got a pellet
+#                         self.SetMapTile(iRow, iCol, 0)
+#                         #self.snd_pellet[self.player.pelletSndNum].play()
+#                         self.player.pelletSndNum = 1 - self.player.pelletSndNum
+                        
+#                         self.pellets -= 1
+                        
+#                         self.thisGame.AddToScore(10)
+                        
+#                         if self.pellets == 0:
+#                             # no more pellets left!
+#                             # WON THE LEVEL
+#                             self.thisGame.SetMode( 6 )
+                            
+                        
+#                     elif result == tileID[ 'pellet-power' ]:
+#                         # got a power pellet
+#                         self.SetMapTile(iRow, iCol, 0)
+#                         #self.snd_powerpellet.play()
+                        
+#                         self.thisGame.AddToScore(100)
+#                         self.thisGame.ghostValue = 200
+                        
+#                         self.thisGame.ghostTimer = 360
+#                         for i in range(0, 4, 1):
+#                             if self.ghosts[i].state == 1:
+#                                 self.ghosts[i].state = 2
+                        
+#                     elif result == tileID[ 'door-h' ]:
+#                         # ran into a horizontal door
+#                         for i in range(0, self.lvlWidth, 1):
+#                             if not i == iCol:
+#                                 if self.thisLevel.GetMapTile(iRow, i) == tileID[ 'door-h' ]:
+#                                     self.player.x = i * 16
+                                    
+#                                     if self.player.velX > 0:
+#                                         self.player.x += 16
+#                                     else:
+#                                         self.player.x -= 16
+                                        
+#                     elif result == tileID[ 'door-v' ]:
+#                         # ran into a vertical door
+#                         for i in range(0, self.lvlHeight, 1):
+#                             if not i == iRow:
+#                                 if self.thisLevel.GetMapTile(i, iCol) == tileID[ 'door-v' ]:
+#                                     self.player.y = i * 16
+                                    
+#                                     if self.player.velY > 0:
+#                                         self.player.y += 16
+#                                     else:
+#                                         self.player.y -= 16
+                                        
+#     def GetGhostBoxPos (self, tileID):
+        
+#         for row in range(0, self.lvlHeight, 1):
+#             for col in range(0, self.lvlWidth, 1):
+#                 if self.GetMapTile(row, col) == tileID[ 'ghost-door' ]:
+#                     return (row, col)
+                
+#         return False
+    
+#     def GetPathwayPairPos (self,  tileID):
+        
+#         doorArray = []
+        
+#         for row in range(0, self.lvlHeight, 1):
+#             for col in range(0, self.lvlWidth, 1):
+#                 if self.GetMapTile(row, col) == tileID[ 'door-h' ]:
+#                     # found a horizontal door
+#                     doorArray.append( (row, col) )
+#                 elif self.GetMapTile(row, col) == tileID[ 'door-v' ]:
+#                     # found a vertical door
+#                     doorArray.append( (row, col) )
+        
+#         if len(doorArray) == 0:
+#             return False
+        
+#         chosenDoor = random.randint(0, len(doorArray) - 1)
+        
+#         if self.GetMapTile( doorArray[chosenDoor][0],doorArray[chosenDoor][1] ) == tileID[ 'door-h' ]:
+#             # horizontal door was chosen
+#             # look for the opposite one
+#             for i in range(0, self.lvlWidth, 1):
+#                 if not i == doorArray[chosenDoor][1]:
+#                     if self.GetMapTile(doorArray[chosenDoor][0], i) == tileID[ 'door-h' ]:
+#                         return doorArray[chosenDoor], (doorArray[chosenDoor][0], i)
+#         else:
+#             # vertical door was chosen
+#             # look for the opposite one
+#             for i in range(0, self.lvlHeight, 1):
+#                 if not i == doorArray[chosenDoor][0]:
+#                     if self.GetMapTile(i, doorArray[chosenDoor][1]) == tileID[ 'door-v' ]:
+#                         return doorArray[chosenDoor], (i, doorArray[chosenDoor][1])
+                    
+#         return False
+        
+#     def PrintMap (self):
+        
+#         for row in range(0, self.lvlHeight, 1):
+#             outputLine = ""
+#             for col in range(0, self.lvlWidth, 1):
+            
+#                 outputLine += str( self.GetMapTile(row, col) ) + ", "
+                
+#             # print outputLine
+            
+#     def DrawMap (self, tileID, tileIDImage):
+        
+#         self.powerPelletBlinkTimer += 1
+#         if self.powerPelletBlinkTimer == 60:
+#             self.powerPelletBlinkTimer = 0
+        
+#         for row in range(-1, self.thisGame.screenTileSize[0] +1, 1):
+#             outputLine = ""
+#             for col in range(-1, self.thisGame.screenTileSize[1] +1, 1):
+
+#                 # row containing tile that actually goes here
+#                 actualRow = self.thisGame.screenNearestTilePos[0] + row
+#                 actualCol = self.thisGame.screenNearestTilePos[1] + col
+
+#                 useTile = self.GetMapTile(actualRow, actualCol)
+#                 if not useTile == 0 and not useTile == tileID['door-h'] and not useTile == tileID['door-v']:
+#                     # if this isn't a blank tile
+
+#                     if useTile == tileID['pellet-power']:
+#                         if self.powerPelletBlinkTimer < 30:
+#                             self.screen.blit (tileIDImage[ useTile ], (col * 16 - self.thisGame.screenPixelOffset[0], row * 16 - self.thisGame.screenPixelOffset[1]) )
+
+#                     elif useTile == tileID['showlogo']:
+#                         self.screen.blit (self.thisGame.imLogo, (col * 16 - self.thisGame.screenPixelOffset[0], row * 16 - self.thisGame.screenPixelOffset[1]) )
+                    
+#                     elif useTile == tileID['hiscores']:
+#                         self.screen.blit(self.thisGame.imHiscores,(col*16-self.thisGame.screenPixelOffset[0],row*16-self.thisGame.screenPixelOffset[1]))
+                    
+              
+#                     else:
+#                         self.screen.blit (tileIDImage[ useTile ], (col * 16 - self.thisGame.screenPixelOffset[0], row * 16 - self.thisGame.screenPixelOffset[1]) )
+    
+    
+#     
+
+
+
+#     def LoadLevel (self, levelNum, tileID, tileIDImage, tileIDName):
+        
+#         self.map = {}
+        
+#         self.pellets = 0
+        
+#         f = open(os.path.join(SCRIPT_PATH,"res","levels",str(levelNum) + ".txt"), 'r')
+#         # ANDY -- edit this
+#         #fileOutput = f.read()
+#         #str_splitByLine = fileOutput.split('\n')
+#         lineNum=-1
+#         rowNum = 0
+#         useLine = False
+#         isReadingLevelData = False
+          
+#         for line in f:
+
+#           lineNum += 1
+        
+#             # print " ------- Level Line " + str(lineNum) + " -------- "
+#           while len(line)>0 and (line[-1]=="\n" or line[-1]=="\r"): line=line[:-1]
+#           while len(line)>0 and (line[0]=="\n" or line[0]=="\r"): line=line[1:]
+#           str_splitBySpace = line.split(' ')
+            
+            
+#           j = str_splitBySpace[0]
+                
+#           if (j == "'" or j == ""):
+#                 # comment / whitespace line
+#                 # print " ignoring comment line.. "
+#                 useLine = False
+#           elif j == "#":
+#                 # special divider / attribute line
+#                 useLine = False
+                
+#                 firstWord = str_splitBySpace[1]
+                
+#                 if firstWord == "lvlwidth":
+#                     self.lvlWidth = int( str_splitBySpace[2] )
+#                     # print "Width is " + str( self.lvlWidth )
+                    
+#                 elif firstWord == "lvlheight":
+#                     self.lvlHeight = int( str_splitBySpace[2] )
+#                     # print "Height is " + str( self.lvlHeight )
+                    
+#                 elif firstWord == "edgecolor":
+#                     # edge color keyword for backwards compatibility (single edge color) mazes
+#                     red = int( str_splitBySpace[2] )
+#                     green = int( str_splitBySpace[3] )
+#                     blue = int( str_splitBySpace[4] )
+#                     self.edgeLightColor = (red, green, blue, 255)
+#                     self.edgeShadowColor = (red, green, blue, 255)
+                    
+#                 elif firstWord == "edgelightcolor":
+#                     red = int( str_splitBySpace[2] )
+#                     green = int( str_splitBySpace[3] )
+#                     blue = int( str_splitBySpace[4] )
+#                     self.edgeLightColor = (red, green, blue, 255)
+                    
+#                 elif firstWord == "edgeshadowcolor":
+#                     red = int( str_splitBySpace[2] )
+#                     green = int( str_splitBySpace[3] )
+#                     blue = int( str_splitBySpace[4] )
+#                     self.edgeShadowColor = (red, green, blue, 255)
+                
+#                 elif firstWord == "fillcolor":
+#                     red = int( str_splitBySpace[2] )
+#                     green = int( str_splitBySpace[3] )
+#                     blue = int( str_splitBySpace[4] )
+#                     self.fillColor = (red, green, blue, 255)
+                    
+#                 elif firstWord == "pelletcolor":
+#                     red = int( str_splitBySpace[2] )
+#                     green = int( str_splitBySpace[3] )
+#                     blue = int( str_splitBySpace[4] )
+#                     self.pelletColor = (red, green, blue, 255)
+                    
+#                 elif firstWord == "fruittype":
+#                     self.thisFruit.fruitType = int( str_splitBySpace[2] )
+                    
+#                 elif firstWord == "startleveldata":
+#                     isReadingLevelData = True
+#                         # print "Level data has begun"
+#                     rowNum = 0
+                    
+#                 elif firstWord == "endleveldata":
+#                     isReadingLevelData = False
+#                     # print "Level data has ended"
+                    
+#           else:
+#                 useLine = True
+                
+                
+#             # this is a map data line   
+#           if useLine == True:
+                
+#                 if isReadingLevelData == True:
+                        
+#                     # print str( len(str_splitBySpace) ) + " tiles in this column"
+                    
+#                     for k in range(0, self.lvlWidth, 1):
+#                         self.SetMapTile(rowNum, k, int(str_splitBySpace[k]) )
+                        
+#                         thisID = int(str_splitBySpace[k])
+#                         if thisID == 4: 
+#                             # starting position for pac-man
+                            
+#                             self.player.homeX = k * 16
+#                             self.player.homeY = rowNum * 16
+#                             self.SetMapTile(rowNum, k, 0 )
+                            
+#                         elif thisID >= 10 and thisID <= 13:
+#                             # one of the self.ghosts
+                            
+#                             self.ghosts[thisID - 10].homeX = k * 16
+#                             self.ghosts[thisID - 10].homeY = rowNum * 16
+#                             self.SetMapTile(rowNum, k, 0 )
+                        
+#                         elif thisID == 2:
+#                             # pellet
+                            
+#                             self.pellets += 1
+                            
+#                     rowNum += 1
+                    
+                
+#         # reload all tiles and set appropriate colors
+#         self.GetCrossRef(tileIDName, tileID, tileIDImage)
+
+#         # load map into the pathfinder object
+#         self.path.ResizeMap( self.lvlHeight, self.lvlWidth )
+        
+#         for row in range(0, self.path.size[0], 1):
+#             for col in range(0, self.path.size[1], 1):
+#                 if self.IsWall( row, col ):
+#                     self.path.SetType( row, col, 1 )
+#                 else:
+#                     self.path.SetType( row, col, 0 )
+        
+#         # do all the level-starting stuff
+#         self.Restart(tileID)
+        
+#     def Restart (self, tileID):
+        
+#         for i in range(0, 4, 1):
+#             # move self.ghosts back to home
+
+#             self.ghosts[i].x = self.ghosts[i].homeX
+#             self.ghosts[i].y = self.ghosts[i].homeY
+#             self.ghosts[i].velX = 0
+#             self.ghosts[i].velY = 0
+#             self.ghosts[i].state = 1
+#             self.ghosts[i].speed = 1
+#             self.ghosts[i].Move(self, tileID)
+            
+#             # give each ghost a path to a random spot (containing a pellet)
+#             (randRow, randCol) = (0, 0)
+
+#             while not self.GetMapTile(randRow, randCol) == tileID[ 'pellet' ] or (randRow, randCol) == (0, 0):
+#                 randRow = random.randint(1, self.lvlHeight - 2)
+#                 randCol = random.randint(1, self.lvlWidth - 2)
+            
+#             # print "Ghost " + str(i) + " headed towards " + str((randRow, randCol))
+#             self.ghosts[i].currentPath = self.path.FindPath( (self.ghosts[i].nearestRow, self.ghosts[i].nearestCol), (randRow, randCol) )
+#             self.ghosts[i].FollowNextPathWay(self, tileID)
+            
+#         self.thisFruit.active = False
+            
+#         self.thisGame.fruitTimer = 0
+
+#         self.player.x = self.player.homeX
+#         self.player.y = self.player.homeY
+#         self.player.velX = 0
+#         self.player.velY = 0
+        
+#         self.player.anim_pacmanCurrent = self.player.anim_pacmanS
+#         self.player.animFrame = 3
+
+
+
+class level ():
+    
+    def __init__ (self, game, player, ghosts, path, Fruit, screen):
+        self.player = player
+        self.ghosts = ghosts
+        self.path = path
+        self.thisFruit = Fruit
+        self.lvlWidth = 0
+        self.lvlHeight = 0
+        self.edgeLightColor = (255, 255, 0, 255)
+        self.edgeShadowColor = (255, 150, 0, 255)
+        self.fillColor = (0, 255, 255, 255)
+        self.pelletColor = (255, 255, 255, 255)
+        self.thisLevel = level
+        # self.snd_pellet = snd_pellet
+        # self.snd_powerpellet = snd_powerpellet
+        self.map = {}
+        self.thisGame = game
+        self.pellets = 0
+        self.powerPelletBlinkTimer = 0
+        self.screen = screen
+        
+    def SetMapTile (self, row, col, newValue):
+        self.map[ (row * self.lvlWidth) + col ] = newValue
+        
+    def GetMapTile (self, row, col):
+        if row >= 0 and row < self.lvlHeight and col >= 0 and col < self.lvlWidth:
+            return self.map[ (row * self.lvlWidth) + col ]
+        else:
+            return 0
+    
+    def IsWall (self, row, col):
+    
+        if row > self.lvlHeight - 1 or row < 0:
+            return True
+        
+        if col > self.lvlWidth - 1 or col < 0:
+            return True
+    
+        # check the offending tile ID
+        result = self.GetMapTile(row, col)
+
+        # if the tile was a wall
+        if result >= 100 and result <= 199:
+            return True
+        else:
+            return False
+    
+                    
+    def CheckIfHitWall (self, possiblePlayerX, possiblePlayerY, row, col):
+    
+        numCollisions = 0
+        
+        # check each of the 9 surrounding tiles for a collision
+        for iRow in range(row - 1, row + 2, 1):
+            for iCol in range(col - 1, col + 2, 1):
+            
+                if  (possiblePlayerX - (iCol * 16) < 16) and (possiblePlayerX - (iCol * 16) > -16) and (possiblePlayerY - (iRow * 16) < 16) and (possiblePlayerY - (iRow * 16) > -16):
+                    
+                    if self.IsWall(iRow, iCol):
+                        numCollisions += 1
+                        
+        if numCollisions > 0:
+            return True
+        else:
+            return False
+        
+        
+    def CheckIfHit (self, playerX, playerY, x, y, cushion):
+    
+        if (playerX - x < cushion) and (playerX - x > -cushion) and (playerY - y < cushion) and (playerY - y > -cushion):
+            return True
+        else:
+            return False
+
+
+    def CheckIfHitSomething (self, playerX, playerY, row, col, tileID):
+    
+        for iRow in range(row - 1, row + 2, 1):
+            for iCol in range(col - 1, col + 2, 1):
+            
+                if  (playerX - (iCol * 16) < 16) and (playerX - (iCol * 16) > -16) and (playerY - (iRow * 16) < 16) and (playerY - (iRow * 16) > -16):
+                    # check the offending tile ID
+                    result = self.GetMapTile(iRow, iCol)
+        
+                    if result == tileID[ 'pellet' ]:
+                        # got a pellet
+                        self.SetMapTile(iRow, iCol, 0)
+                        self.player.pelletSndNum = 1 - self.player.pelletSndNum
+                        
+                        self.pellets -= 1
+                        
+                        self.thisGame.AddToScore(10)
+                        
+                        if self.pellets == 0:
+                            # no more pellets left!
+                            # WON THE LEVEL
+                            self.thisGame.SetMode( 6 )
+                            
+                        
+                    elif result == tileID[ 'pellet-power' ]:
+                        # got a power pellet
+                        self.SetMapTile(iRow, iCol, 0)
+                        
+                        self.thisGame.AddToScore(100)
+                        self.thisGame.ghostValue = 200
+                        
+                        self.thisGame.ghostTimer = 360
+                        for i in range(0, 4, 1):
+                            if self.ghosts[i].state == 1:
+                                self.ghosts[i].state = 2
+                        
+                    elif result == tileID[ 'door-h' ]:
+                        # ran into a horizontal door
+                        for i in range(0, self.lvlWidth, 1):
+                            if not i == iCol:
+                                if self.thisLevel.GetMapTile(iRow, i) == tileID[ 'door-h' ]:
+                                    self.player.x = i * 16
+                                    
+                                    if self.player.velX > 0:
+                                        self.player.x += 16
+                                    else:
+                                        self.player.x -= 16
+                                        
+                    elif result == tileID[ 'door-v' ]:
+                        # ran into a vertical door
+                        for i in range(0, self.lvlHeight, 1):
+                            if not i == iRow:
+                                if self.GetMapTile(i, iCol) == tileID[ 'door-v' ]:
+                                    self.player.y = i * 16
+                                    
+                                    if self.player.velY > 0:
+                                        self.player.y += 16
+                                    else:
+                                        self.player.y -= 16
+                                        
+    def GetGhostBoxPos (self,tileID):
+        
+        for row in range(0, self.lvlHeight, 1):
+            for col in range(0, self.lvlWidth, 1):
+                if self.GetMapTile(row, col) == tileID[ 'ghost-door' ]:
+                    return (row, col)
+                
+        return False
+    
+    def GetPathwayPairPos (self, tileID):
+        
+        doorArray = []
+        
+        for row in range(0, self.lvlHeight, 1):
+            for col in range(0, self.lvlWidth, 1):
+                if self.GetMapTile(row, col) == tileID[ 'door-h' ]:
+                    # found a horizontal door
+                    doorArray.append( (row, col) )
+                elif self.GetMapTile(row, col) == tileID[ 'door-v' ]:
+                    # found a vertical door
+                    doorArray.append( (row, col) )
+        
+        if len(doorArray) == 0:
+            return False
+        
+        chosenDoor = random.randint(0, len(doorArray) - 1)
+        
+        if self.GetMapTile( doorArray[chosenDoor][0],doorArray[chosenDoor][1] ) == tileID[ 'door-h' ]:
+            # horizontal door was chosen
+            # look for the opposite one
+            for i in range(0, self.lvlWidth, 1):
+                if not i == doorArray[chosenDoor][1]:
+                    if self.GetMapTile(doorArray[chosenDoor][0], i) == tileID[ 'door-h' ]:
+                        return doorArray[chosenDoor], (doorArray[chosenDoor][0], i)
+        else:
+            # vertical door was chosen
+            # look for the opposite one
+            for i in range(0, self.lvlHeight, 1):
+                if not i == doorArray[chosenDoor][0]:
+                    if self.GetMapTile(i, doorArray[chosenDoor][1]) == tileID[ 'door-v' ]:
+                        return doorArray[chosenDoor], (i, doorArray[chosenDoor][1])
+                    
+        return False
+        
+    def PrintMap (self):
+        
+        for row in range(0, self.lvlHeight, 1):
+            outputLine = ""
+            for col in range(0, self.lvlWidth, 1):
+            
+                outputLine += str( self.GetMapTile(row, col) ) + ", "
+                
+            # print outputLine
+            
+    def DrawMap (self, tileID, tileIDImage):
+        
+        self.powerPelletBlinkTimer += 1
+        if self.powerPelletBlinkTimer == 60:
+            self.powerPelletBlinkTimer = 0
+        
+        for row in range(-1, self.thisGame.screenTileSize[0] +1, 1):
+            outputLine = ""
+            for col in range(-1, self.thisGame.screenTileSize[1] +1, 1):
+
+                # row containing tile that actually goes here
+                actualRow = self.thisGame.screenNearestTilePos[0] + row
+                actualCol = self.thisGame.screenNearestTilePos[1] + col
+
+                useTile = self.GetMapTile(actualRow, actualCol)
+                if not useTile == 0 and not useTile == tileID['door-h'] and not useTile == tileID['door-v']:
+                    # if this isn't a blank tile
+
+                    if useTile == tileID['pellet-power']:
+                        if self.powerPelletBlinkTimer < 30:
+                            screen.blit (tileIDImage[ useTile ], (col * 16 - self.thisGame.screenPixelOffset[0], row * 16 - self.thisGame.screenPixelOffset[1]) )
+
+                    elif useTile == tileID['showlogo']:
+                        screen.blit (self.thisGame.imLogo, (col * 16 - self.thisGame.screenPixelOffset[0], row * 16 - self.thisGame.screenPixelOffset[1]) )
+                    
+                    elif useTile == tileID['hiscores']:
+                            screen.blit(self.thisGame.imHiscores,(col*16-self.thisGame.screenPixelOffset[0],row*16-self.thisGame.screenPixelOffset[1]))
+                    
+                    else:
+                        screen.blit (tileIDImage[ useTile ], (col * 16 - self.thisGame.screenPixelOffset[0], row * 16 - self.thisGame.screenPixelOffset[1]) )
+    
+    def GetCrossRef(self, tileIDName, tileID, tileIDImage):
+            for key, value in tileIDName.items():
+                thisID = key
+                if thisID not in NO_GIF_TILES:
+                    tileIDImage[thisID] = pygame.image.load(os.path.join(SCRIPT_PATH, "res", "tiles", value + ".gif")).convert()
+                else:
+                    tileIDImage[thisID] = pygame.Surface((16, 16))
+
+                # Change colors in tileIDImage to match maze colors
+                for y in range(16):
+                    for x in range(16):
+                        current_color = tileIDImage[thisID].get_at((x, y))
+                        if current_color == (255, 206, 255, 255):
+                            tileIDImage[thisID].set_at((x, y), self.edgeLightColor)
+                        elif current_color == (132, 0, 132, 255):
+                            tileIDImage[thisID].set_at((x, y), self.fillColor)
+                        elif current_color == (255, 0, 255, 255):
+                            tileIDImage[thisID].set_at((x, y), self.edgeShadowColor)
+                        elif current_color == (128, 0, 128, 255):
+                            tileIDImage[thisID].set_at((x, y), self.pelletColor)
+
+        
+    def LoadLevel(self,levelNum, tileID, tileIDImage, tileIDName):
+        
+        self.map = {}
+        
+        self.pellets = 0
+        
+        f = open(os.path.join(SCRIPT_PATH,"res","levels",str(levelNum) + ".txt"), 'r')
+        # ANDY -- edit this
+        #fileOutput = f.read()
+        #str_splitByLine = fileOutput.split('\n')
+        lineNum=-1
+        rowNum = 0
+        useLine = False
+        isReadingLevelData = False
+          
+        for line in f:
+
+          lineNum += 1
+        
+            # print " ------- Level Line " + str(lineNum) + " -------- "
+          while len(line)>0 and (line[-1]=="\n" or line[-1]=="\r"): line=line[:-1]
+          while len(line)>0 and (line[0]=="\n" or line[0]=="\r"): line=line[1:]
+          str_splitBySpace = line.split(' ')
+            
+            
+          j = str_splitBySpace[0]
+                
+          if (j == "'" or j == ""):
+                # comment / whitespace line
+                # print " ignoring comment line.. "
+                useLine = False
+          elif j == "#":
+                # special divider / attribute line
+                useLine = False
+                
+                firstWord = str_splitBySpace[1]
+                
+                if firstWord == "lvlwidth":
+                    self.lvlWidth = int( str_splitBySpace[2] )
+                    # print "Width is " + str( self.lvlWidth )
+                    
+                elif firstWord == "lvlheight":
+                    self.lvlHeight = int( str_splitBySpace[2] )
+                    # print "Height is " + str( self.lvlHeight )
+                    
+                elif firstWord == "edgecolor":
+                    # edge color keyword for backwards compatibility (single edge color) mazes
+                    red = int( str_splitBySpace[2] )
+                    green = int( str_splitBySpace[3] )
+                    blue = int( str_splitBySpace[4] )
+                    self.edgeLightColor = (red, green, blue, 255)
+                    self.edgeShadowColor = (red, green, blue, 255)
+                    
+                elif firstWord == "edgelightcolor":
+                    red = int( str_splitBySpace[2] )
+                    green = int( str_splitBySpace[3] )
+                    blue = int( str_splitBySpace[4] )
+                    self.edgeLightColor = (red, green, blue, 255)
+                    
+                elif firstWord == "edgeshadowcolor":
+                    red = int( str_splitBySpace[2] )
+                    green = int( str_splitBySpace[3] )
+                    blue = int( str_splitBySpace[4] )
+                    self.edgeShadowColor = (red, green, blue, 255)
+                
+                elif firstWord == "fillcolor":
+                    red = int( str_splitBySpace[2] )
+                    green = int( str_splitBySpace[3] )
+                    blue = int( str_splitBySpace[4] )
+                    self.fillColor = (red, green, blue, 255)
+                    
+                elif firstWord == "pelletcolor":
+                    red = int( str_splitBySpace[2] )
+                    green = int( str_splitBySpace[3] )
+                    blue = int( str_splitBySpace[4] )
+                    self.pelletColor = (red, green, blue, 255)
+                    
+                elif firstWord == "fruittype":
+                    self.thisFruit.fruitType = int( str_splitBySpace[2] )
+                    
+                elif firstWord == "startleveldata":
+                    isReadingLevelData = True
+                        # print "Level data has begun"
+                    rowNum = 0
+                    
+                elif firstWord == "endleveldata":
+                    isReadingLevelData = False
+                    # print "Level data has ended"
+                    
+          else:
+                useLine = True
+                
+                
+            # this is a map data line   
+          if useLine == True:
+                
+                if isReadingLevelData == True:
+                        
+                    # print str( len(str_splitBySpace) ) + " tiles in this column"
+                    
+                    for k in range(0, self.lvlWidth, 1):
+                        self.SetMapTile(rowNum, k, int(str_splitBySpace[k]) )
+                        
+                        thisID = int(str_splitBySpace[k])
+                        if thisID == 4: 
+                            # starting position for pac-man
+                            
+                            self.player.homeX = k * 16
+                            self.player.homeY = rowNum * 16
+                            self.SetMapTile(rowNum, k, 0 )
+                            
+                        elif thisID >= 10 and thisID <= 13:
+                            # one of the ghosts
+                            
+                            self.ghosts[thisID - 10].homeX = k * 16
+                            self.ghosts[thisID - 10].homeY = rowNum * 16
+                            self.SetMapTile(rowNum, k, 0 )
+                        
+                        elif thisID == 2:
+                            # pellet
+                            
+                            self.pellets += 1
+                            
+                    rowNum += 1
+                    
+        
+
+        # reload all tiles and set appropriate colors
+        self.GetCrossRef(tileIDName, tileID, tileIDImage)
+
+        # load map into the pathfinder object
+        self.path.ResizeMap( self.lvlHeight, self.lvlWidth )
+        
+        for row in range(0, self.path.size[0], 1):
+            for col in range(0, self.path.size[1], 1):
+                if self.IsWall( row, col ):
+                    self.path.SetType( row, col, 1 )
+                else:
+                    self.path.SetType( row, col, 0 )
+        
+        # do all the level-starting stuff
+        self.Restart(tileID)
+
+    def GetPelletLocations(self):
+        pelletLocations = []
+        for row in range(self.lvlHeight):
+            for col in range(self.lvlWidth):
+                if self.GetMapTile(row, col) == 2:
+                    pelletLocations.append((row*16, col*16))
+        return pelletLocations 
+    
+
+    def Restart (self, tileID):
+        
+        for i in range(0, 4, 1):
+            # move ghosts back to home
+
+            self.ghosts[i].x = self.ghosts[i].homeX
+            self.ghosts[i].y = self.ghosts[i].homeY
+            self.ghosts[i].velX = 0
+            self.ghosts[i].velY = 0
+            self.ghosts[i].state = 1
+            self.ghosts[i].speed = 1
+            self.ghosts[i].Move(self, tileID)
+            
+            # give each ghost a path to a random spot (containing a pellet)
+            (randRow, randCol) = (0, 0)
+
+            while not self.GetMapTile(randRow, randCol) == tileID[ 'pellet' ] or (randRow, randCol) == (0, 0):
+                randRow = random.randint(1, self.lvlHeight - 2)
+                randCol = random.randint(1, self.lvlWidth - 2)
+            
+            # print "Ghost " + str(i) + " headed towards " + str((randRow, randCol))
+            self.ghosts[i].currentPath = self.path.FindPath( (self.ghosts[i].nearestRow, self.ghosts[i].nearestCol), (randRow, randCol) )
+            self.ghosts[i].FollowNextPathWay(self, tileID)
+            
+        self.thisFruit.active = False
+            
+        self.thisGame.fruitTimer = 0
+
+        self.player.x = self.player.homeX
+        self.player.y = self.player.homeY
+        self.player.velX = 0
+        self.player.velY = 0
+        
+        self.player.anim_pacmanCurrent = self.player.anim_pacmanS
+        self.player.animFrame = 3
+
+
+def CheckIfCloseButton(events):
+    for event in events: 
+        if event.type == pygame.QUIT: 
+            sys.exit(0)
+
+def GetPowerPelletLocations(self):
+    powerPelletLocations = []
+    for row in range(self.lvlHeight):
+        for col in range(self.lvlWidth):
+            if self.GetMapTile(row, col) == 3:
+                powerPelletLocations.append((row, col))
+    return powerPelletLocations
\ No newline at end of file
diff --git a/games/pacman/pacman.py b/games/pacman/pacman.py
index 430e039..70436f3 100644
--- a/games/pacman/pacman.py
+++ b/games/pacman/pacman.py
@@ -1,6 +1,23 @@
+import random
 import pygame
+import numpy as np
+from pygame.math import Vector2
 
+class node ():
+    
+    def __init__ (self):
+        self.g = -1 # movement cost to move from previous node to this one (usually +10)
+        self.h = -1 # estimated movement cost to move from this node to the ending node (remaining horizontal and vertical steps * 10)
+        self.f = -1 # total movement cost of this node (= g + h)
+        # parent node - used to trace path back to the starting node at the end
+        self.parent = (-1, -1)
+        # node type - 0 for empty space, 1 for wall (optionally, 2 for starting node and 3 for end)
+        self.type = -1 
+        # create a 2d grid numpy array of 20x20
 
+
+
+    
 class Color:
     """
     Class to store hex values for colors/
@@ -18,6 +35,21 @@ class Color:
         self.purple = (255, 0, 255)
         self.yellow = (255, 255, 0)
 
+class PowerUp(pygame.sprite.Sprite):
+    def __init__(self, x, y):
+        super().__init__()
+        self.image = pygame.Surface([20, 20])
+        self.image.fill(Color().purple)  # Color indicating special power-up
+        self.rect = self.image.get_rect()
+        self.rect.x = x
+        self.rect.y = y
+        self.type = 'eat_ghosts'  # Specific type for eating ghosts
+        self.duration = 7000  # Lasts for 7 seconds
+
+    def apply_effect(self, player):
+        if self.type == 'eat_ghosts':
+            player.enable_ghost_eating(self.duration)
+
 
 class Wall(pygame.sprite.Sprite):
     def __init__(self, x, y, width, height, color):
@@ -113,6 +145,17 @@ class Player(pygame.sprite.Sprite):
         self.rect.left = x
         self.prev_x = x
         self.prev_y = y
+        self.goal = None
+        self.ghost_eating = False
+        self.position = Vector2(x, y)  # Current position as a vector
+        self.goal = Vector2()  # Goal position initialized to zero vector
+        self.directions = {
+            'up': Vector2(0, -1),
+            'down': Vector2(0, 1),
+            'left': Vector2(-1, 0),
+            'right': Vector2(1, 0)
+        }
+
 
     def prev_direction(self):
         """
@@ -140,7 +183,9 @@ class Player(pygame.sprite.Sprite):
         :param gate: 
         :type gate: 
         """
-
+        for event in pygame.event.get():
+            if event.type == pygame.USEREVENT + 3:  # Timer for ghost eating power-up
+                self.ghost_eating = False
         # Get the old position, in case we need to go back to it
         old_x = self.rect.left
         new_x = old_x + self.change_x
@@ -149,6 +194,7 @@ class Player(pygame.sprite.Sprite):
         old_y = self.rect.top
         new_y = old_y + self.change_y
 
+   
         x_collide = pygame.sprite.spritecollide(self, walls, False)
         if x_collide:
             self.rect.left = old_x
@@ -162,50 +208,79 @@ class Player(pygame.sprite.Sprite):
             gate_hit = pygame.sprite.spritecollide(self, gate, False)
             if gate_hit:
                 self.rect.left = old_x
-                self.rect.top = old_y
+                self.rect.top = old_y 
+    
+    def enable_ghost_eating(self, duration):
+        self.ghost_eating = True
+        pygame.time.set_timer(pygame.USEREVENT + 3, duration)
+
+    
 
 
 class Ghost(Player):
     """
-    Class to handle ghosts
+    Class to handle ghosts, inheriting from Player.
     """
-
-    def ghost_change_speed(self, direction_list, ghost, turn, steps, l):
-        """
-        Change the speed of the ghost
-        :param direction_list: 
-        :type direction_list: 
-        :param ghost: 
-        :type ghost: 
-        :param turn: 
-        :type turn: 
-        :param steps: 
-        :type steps: 
-        :param l: 
-        :type l: 
-        :return: 
-        :rtype: 
-        """
-        try:
-            z = direction_list[turn][2]
-            if steps < z:
-                self.change_x = direction_list[turn][0]
-                self.change_y = direction_list[turn][1]
-                steps += 1
+    def __init__(self, x, y, filename, game):
+        super().__init__(x, y, filename)
+        self.game = game
+
+    def update_behavior(self, pacman):
+        self.mode = "flee" if pacman.ghost_eating else "chase"
+
+    def move(self, pacman):
+        self.update_behavior(pacman)
+        direction = self.chase_pacman() if self.mode == "chase" else self.run_away_from_pacman()
+        if direction:
+            movement = self.calculate_movement(direction)
+            self.change_speed(*movement)
+
+    def chase_pacman(self):
+        return self.goal_direction(self.game.game_map)
+
+    def run_away_from_pacman(self):
+        furthest_point = self.find_furthest_point()
+        self.set_goal(*furthest_point)
+        return self.goal_direction(self.game.game_map)
+
+    def find_furthest_point(self):
+        max_distance = 0
+        furthest_point = (self.rect.x, self.rect.y)
+        for y in range(self.game.path_finder.size[0]):
+            for x in range(self.game.path_finder.size[1]):
+                if self.game.game_map[y][x] == 0:
+                    distance = (Vector2(x, y) - self.position).length_squared()
+                    if distance > max_distance:
+                        max_distance = distance
+                        furthest_point = (x, y)
+        return furthest_point
+
+    def goal_direction(self, game_map):
+        TILEWIDTH = 30
+        distances = []
+        directions = list(self.directions.keys())
+        for direction in directions:
+            next_position = self.position + self.directions[direction] * TILEWIDTH
+            if game_map[int(next_position.y // TILEWIDTH)][int(next_position.x // TILEWIDTH)] == 1:
+                distances.append(float('inf'))
             else:
-                if turn < l:
-                    turn += 1
-                elif ghost == 'ghost_four':
-                    turn = 2
-                else:
-                    turn = 0
-                self.change_x = direction_list[turn][0]
-                self.change_y = direction_list[turn][1]
-                steps = 0
-            return [turn, steps]
-        except IndexError:
-            return [0, 0]
-
+                vec = next_position - self.goal
+                distances.append(vec.length_squared())
+        if min(distances) == float('inf'):
+            return None
+        else:
+            index = distances.index(min(distances))
+            return directions[index]
+
+    def calculate_movement(self, direction):
+        movement_map = {
+            'up': (0, -30),
+            'down': (0, 30),
+            'left': (-30, 0),
+         'right': (30, 0)
+        }
+        return movement_map.get(direction, (0, 0)) 
+    
 
 class Game:
     """
@@ -216,7 +291,10 @@ class Game:
         """
         Constructor Function
         """
-
+        self.cell_size = 30
+        self.grid_width = 20
+        self.grid_height = 20
+        #self.path_finder = path_finder()
         # This is a list of walls. Each is in the form [x, y, width, height]
         self.walls = [
             [0, 0, 6, 600],
@@ -259,111 +337,7 @@ class Game:
             [360, 540, 126, 6],
         ]
 
-        self.ghost_one_directions = [
-            [0, -30, 4],
-            [15, 0, 9],
-            [0, 15, 11],
-            [-15, 0, 23],
-            [0, 15, 7],
-            [15, 0, 3],
-            [0, -15, 3],
-            [15, 0, 19],
-            [0, 15, 3],
-            [15, 0, 3],
-            [0, 15, 3],
-            [15, 0, 3],
-            [0, -15, 15],
-            [-15, 0, 7],
-            [0, 15, 3],
-            [-15, 0, 19],
-            [0, -15, 11],
-            [15, 0, 9],
-        ]
-
-        self.ghost_two_directions = [
-            [0, -15, 4],
-            [15, 0, 9],
-            [0, 15, 11],
-            [15, 0, 3],
-            [0, 15, 7],
-            [-15, 0, 11],
-            [0, 15, 3],
-            [15, 0, 15],
-            [0, -15, 15],
-            [15, 0, 3],
-            [0, -15, 11],
-            [-15, 0, 3],
-            [0, -15, 11],
-            [-15, 0, 3],
-            [0, -15, 3],
-            [-15, 0, 7],
-            [0, -15, 3],
-            [15, 0, 15],
-            [0, 15, 15],
-            [-15, 0, 3],
-            [0, 15, 3],
-            [-15, 0, 3],
-            [0, -15, 7],
-            [-15, 0, 3],
-            [0, 15, 7],
-            [-15, 0, 11],
-            [0, -15, 7],
-            [15, 0, 5],
-        ]
-
-        self.ghost_three_directions = [
-            [30, 0, 2],
-            [0, -15, 4],
-            [15, 0, 10],
-            [0, 15, 7],
-            [15, 0, 3],
-            [0, -15, 3],
-            [15, 0, 3],
-            [0, -15, 15],
-            [-15, 0, 15],
-            [0, 15, 3],
-            [15, 0, 15],
-            [0, 15, 11],
-            [-15, 0, 3],
-            [0, -15, 7],
-            [-15, 0, 11],
-            [0, 15, 3],
-            [-15, 0, 11],
-            [0, 15, 7],
-            [-15, 0, 3],
-            [0, -15, 3],
-            [-15, 0, 3],
-            [0, -15, 15],
-            [15, 0, 15],
-            [0, 15, 3],
-            [-15, 0, 15],
-            [0, 15, 11],
-            [15, 0, 3],
-            [0, -15, 11],
-            [15, 0, 11],
-            [0, 15, 3],
-            [15, 0, 1],
-        ]
-
-        self.ghost_four_directions = [
-            [-30, 0, 2],
-            [0, -15, 4],
-            [15, 0, 5],
-            [0, 15, 7],
-            [-15, 0, 11],
-            [0, -15, 7],
-            [-15, 0, 3],
-            [0, 15, 7],
-            [-15, 0, 7],
-            [0, 15, 15],
-            [15, 0, 15],
-            [0, -15, 3],
-            [-15, 0, 11],
-            [0, -15, 7],
-            [15, 0, 3],
-            [0, -15, 11],
-            [15, 0, 9],
-        ]
+       
 
         self.color = Color()
         # Call this function so the Pygame library can initialize itself
@@ -383,45 +357,7 @@ class Game:
         pygame.font.init()
         self.font = pygame.font.SysFont('arial', 30)
         self.all_sprites_list = None
-
-    def setup_walls(self):
-        """
-        Make the walls. (x_pos, y_pos, width, height)
-        :return:
-        :rtype:
-        """
-        wall_list = pygame.sprite.RenderPlain()
-
-        # Loop through the list. Create the wall, add it to the list
-        for item in self.walls:
-            wall = Wall(item[0], item[1], item[2], item[3], self.color.grey)
-            wall_list.add(wall)
-            self.all_sprites_list.add(wall)
-
-        # return our new list
-        return wall_list
-
-    def setup_gate(self):
-        """
-        Add gates in the walls
-        :return:
-        :rtype:
-        """
-        gate = pygame.sprite.RenderPlain()
-        gate.add(Wall(282, 242, 42, 2, self.color.white))
-        self.all_sprites_list.add(gate)
-        return gate
-
-    def start_game(self):
-        """
-        start the game
-        """
-
-        pl = len(self.ghost_one_directions) - 1
-        bl = len(self.ghost_two_directions) - 1
-        il = len(self.ghost_three_directions) - 1
-        cl = len(self.ghost_four_directions) - 1
-
+        self.power_pellets = pygame.sprite.RenderPlain()
         # default locations for Pacman and ghosts
         w = 303 - 16  # Width
         p_h = 7 * 60 + 19
@@ -431,11 +367,12 @@ class Game:
         c_w = 303 + 32 - 16
 
         self.all_sprites_list = pygame.sprite.RenderPlain()
-        block_list = pygame.sprite.RenderPlain()
-        ghost_list = pygame.sprite.RenderPlain()
-        pacman_collide = pygame.sprite.RenderPlain()
-        wall_list = self.setup_walls()
-        gate = self.setup_gate()
+        self.block_list = pygame.sprite.RenderPlain()
+        self.ghost_list = pygame.sprite.RenderPlain()
+        self.pacman_collide = pygame.sprite.RenderPlain()
+        self.wall_list = self.setup_walls()
+
+        self.gate = self.setup_gate()
 
         p_turn = 0
         p_steps = 0
@@ -449,30 +386,31 @@ class Game:
         c_turn = 0
         c_steps = 0
 
-        # Create the player paddle object
-        pacman = Player(w, p_h, 'images/pacman.png')
-        self.all_sprites_list.add(pacman)
-        pacman_collide.add(pacman)
+        # Create the player  object
+        self.pacman = Player(w, p_h, 'images/pacman.png')
+        self.all_sprites_list.add(self.pacman)
+        self.pacman_collide.add(self.pacman)
 
-        ghost_two = Ghost(w, b_h, 'images/red.png')
-        ghost_list.add(ghost_two)
-        self.all_sprites_list.add(ghost_two)
+        self.ghost_two = Ghost(w, b_h, 'images/red.png', self)
+        self.ghost_list.add(self.ghost_two)
+        self.all_sprites_list.add(self.ghost_two)
 
-        ghost_one = Ghost(w, m_h, 'images/pink.png')
-        ghost_list.add(ghost_one)
-        self.all_sprites_list.add(ghost_one)
+        self.ghost_one = Ghost(w, m_h, 'images/pink.png', self)
+        self.ghost_list.add(self.ghost_one)
+        self.all_sprites_list.add(self.ghost_one)
 
-        ghost_three = Ghost(i_w, m_h, 'images/blue.png')
-        ghost_list.add(ghost_three)
+        ghost_three = Ghost(i_w, m_h, 'images/blue.png',self)
+        self.ghost_list.add(ghost_three)
         self.all_sprites_list.add(ghost_three)
 
-        ghost_four = Ghost(c_w, m_h, 'images/yellow.png')
-        ghost_list.add(ghost_four)
+        ghost_four = Ghost(c_w, m_h, 'images/yellow.png',self)
+        self.ghost_list.add(ghost_four)
         self.all_sprites_list.add(ghost_four)
-
+        grid = [[0 for _ in range(19)] for _ in range(19)]
         # Draw the grid
         for row in range(19):
             for column in range(19):
+                
                 if (row == 7 or row == 8) and (column == 8 or column == 9 or column == 10):
                     continue
                 else:
@@ -482,18 +420,111 @@ class Game:
                     block.rect.x = 30 * column + 6 + 26
                     block.rect.y = 30 * row + 6 + 26
 
-                    b_collide = pygame.sprite.spritecollide(block, wall_list, False)
-                    p_collide = pygame.sprite.spritecollide(block, pacman_collide, False)
+                    b_collide = pygame.sprite.spritecollide(block, self.wall_list, False)
+                    p_collide = pygame.sprite.spritecollide(block, self.pacman_collide, False)
                     if b_collide:
+                        grid[row][column] = 1
+
                         continue
+
                     elif p_collide:
+                        grid[row][column] = 0
                         continue
                     else:
                         # Add the block to the list of objects
-                        block_list.add(block)
+                        grid[row][column] = 0
+                        self.block_list.add(block)
                         self.all_sprites_list.add(block)
+        # create new grid which is 20x20 with edges as 1 from grid
+        
+        new_grid = [[1 if i == 0 or i == 19 or j == 0 or j == 19 else grid[i-1][j-1] for j in range(20)] for i in range(20)] 
+        self.game_map = new_grid
+        self.path_finder.ResizeMap(20, 20)
+        self.update_path_finder_with_walls(new_grid)
+        blocks = list(self.block_list)
+        selected_blocks = random.sample(blocks, 4)
+        self.power_pellet_list = pygame.sprite.RenderPlain()
+# Replace the selected blocks with power pellets
+        for block in selected_blocks:
+            power_pellet = PowerUp(block.rect.x, block.rect.y)  # Assuming you have a PowerPellet class
+            self.power_pellet_list.add(power_pellet)
+    # Add the power pellet to the game (you might need to modify this part based on your game structure)
+            self.all_sprites_list.add(power_pellet)
+        self.bll = len(self.block_list)
+
+
+   
+
+    def update_path_finder_with_walls(self, grid):
+        for i in range(len(grid[0])):
+            for j in range(len(grid[1])):
+                self.path_finder.SetType(i,j, grid[i][j])
+
+
+
+    def get_maze_size(self):
+        max_width = 0
+        max_height = 0
+
+        for wall in self.walls:
+            x, y, width, height = wall
+            # Calculate the furthest extents of the walls
+            max_width = max(max_width, x + width)
+            max_height = max(max_height, y + height)
+
+        return max_width, max_height
+    def setup_walls(self):
+        """
+        Make the walls. (x_pos, y_pos, width, height)
+        :return:
+        :rtype:
+        """
+        wall_list = pygame.sprite.RenderPlain()
+
+        # Loop through the list. Create the wall, add it to the list
+        for item in self.walls:
+            wall = Wall(item[0], item[1], item[2], item[3], self.color.grey)
+            wall_list.add(wall)
+            self.all_sprites_list.add(wall)
 
-        bll = len(block_list)
+        # return our new list
+        return wall_list
+
+    def setup_gate(self):
+        """
+        Add gates in the walls
+        :return:
+        :rtype:
+        """
+        gate = pygame.sprite.RenderPlain()
+        gate.add(Wall(282, 242, 42, 2, self.color.white))
+        self.all_sprites_list.add(gate)
+        return gate 
+    
+
+    def setup_power_pellets(self):
+        # Define power pellet locations and add them to the game
+        locations = [(100, 200), (500, 300), (300, 100)]  # Example locations
+        for x, y in locations:
+            pellet = PowerUp(x, y)
+            self.power_pellets.add(pellet)
+            self.all_sprites_list.add(pellet) 
+
+
+    def start_game(self):
+        """
+        start the game
+        """
+
+       
+
+        
+                
+       
+
+        # Get the unique row indices
+
+        
         score = 0
         done = False
         while not done:
@@ -504,89 +535,88 @@ class Game:
 
                 if event.type == pygame.KEYDOWN:
                     if event.key == pygame.K_LEFT:
-                        pacman.change_speed(-30, 0)
+                        self.pacman.change_speed(-30, 0)
                     if event.key == pygame.K_RIGHT:
-                        pacman.change_speed(30, 0)
+                        self.pacman.change_speed(30, 0)
                     if event.key == pygame.K_UP:
-                        pacman.change_speed(0, -30)
+                        self.pacman.change_speed(0, -30)
                     if event.key == pygame.K_DOWN:
-                        pacman.change_speed(0, 30)
+                        self.pacman.change_speed(0, 30)
 
                 if event.type == pygame.KEYUP:
                     if event.key == pygame.K_LEFT:
-                        pacman.change_speed(30, 0)
+                        self.pacman.change_speed(30, 0)
                     if event.key == pygame.K_RIGHT:
-                        pacman.change_speed(-30, 0)
+                        self.pacman.change_speed(-30, 0)
                     if event.key == pygame.K_UP:
-                        pacman.change_speed(0, 30)
+                        self.pacman.change_speed(0, 30)
                     if event.key == pygame.K_DOWN:
-                        pacman.change_speed(0, -30)
-
-            pacman.update(wall_list, gate)
-            returned = ghost_one.ghost_change_speed(self.ghost_one_directions, False, p_turn, p_steps, pl)
-            p_turn = returned[0]
-            p_steps = returned[1]
-            ghost_one.ghost_change_speed(self.ghost_one_directions, False, p_turn, p_steps, pl)
-            ghost_one.update(wall_list, False)
-
-            returned = ghost_two.ghost_change_speed(self.ghost_two_directions, False, b_turn, b_steps, bl)
-            b_turn = returned[0]
-            b_steps = returned[1]
-            ghost_two.ghost_change_speed(self.ghost_two_directions, False, b_turn, b_steps, bl)
-            ghost_two.update(wall_list, False)
-
-            returned = ghost_three.ghost_change_speed(self.ghost_three_directions, False, i_turn, i_steps, il)
-            i_turn = returned[0]
-            i_steps = returned[1]
-            ghost_three.ghost_change_speed(self.ghost_three_directions, False, i_turn, i_steps, il)
-            ghost_three.update(wall_list, False)
-
-            returned = ghost_four.ghost_change_speed(self.ghost_four_directions, 'ghost_four', c_turn, c_steps, cl)
-            c_turn = returned[0]
-            c_steps = returned[1]
-            ghost_four.ghost_change_speed(self.ghost_four_directions, 'ghost_four', c_turn, c_steps, cl)
-            ghost_four.update(wall_list, False)
-
+                        self.pacman.change_speed(0, -30)
+
+            self.pacman.update(self.wall_list, self.gate) 
+
+            # Assuming new_grid is your grid
+            
+
+            # Check if the two grids are the same
+            # print(f"new_grid_np: {new_grid_np}")
+            # print(f"path_finder_grid: {path_finder_grid}")
+            # print(f"Are the grids equal? {are_grids_equal}")
+        # whic
+            #self.ghost_one.move(self.pacman)
+            self.ghost_two.move(self.pacman)
+            # ghost_three.move(pacman)
+            # ghost_four.move(pacman)
+
+            # ghost_one.update(wall_list, None)
+            self.ghost_two.update(self.wall_list, None)
+            print(f"Ghost Two position: {self.ghost_two.rect.x}, {self.ghost_two.rect.y}")
+            print("Is Ghost Two in all_sprites_list?", self.ghost_two in self.all_sprites_list)
+            print("Is Ghost Two in ghost_list?", self.ghost_two in self.ghost_list)
+            # ghost_three.update(wall_list, None)
+            # ghost_four.update(wall_list, None)
             # See if the pacman block has collided with anything.
-            blocks_hit_list = pygame.sprite.spritecollide(pacman, block_list, True)
-
+            blocks_hit_list = pygame.sprite.spritecollide(self.pacman, self.block_list, True) 
+            power_pellets_hit_list = pygame.sprite.spritecollide(self.pacman, self.power_pellet_list, True)
+            # check if pacman hits any power pellet
+            # if pellet is hit 
             # Check the list of collisions.
             if len(blocks_hit_list) > 0:
                 score += len(blocks_hit_list)
 
             self.screen.fill(self.color.black)
 
-            wall_list.draw(self.screen)
-            gate.draw(self.screen)
+            self.wall_list.draw(self.screen)
+            self.gate.draw(self.screen)
             self.all_sprites_list.draw(self.screen)
-            ghost_list.draw(self.screen)
+            self.ghost_list.draw(self.screen)
 
-            text = self.font.render(str(score) + '/' + str(bll), True, self.color.white)
+            text = self.font.render(str(score) + '/' + str(self.bll), True, self.color.white)
             self.screen.blit(text, [270, 254])
 
-            if score == bll:
+            if score == self.bll:
                 self.do_next(
                     'Congratulations, you won!',
                     145,
-                    block_list,
-                    ghost_list,
-                    pacman_collide,
-                    wall_list,
-                    gate,
+                    self.block_list,
+                    self.ghost_list,
+                    self.pacman_collide,
+                    self.wall_list,
+                    self.gate,
                 )
                 return
 
-            ghost_hit_list = pygame.sprite.spritecollide(pacman, ghost_list, False)
+            ghost_hit_list = pygame.sprite.spritecollide(self.pacman, self.ghost_list, False)
 
             if ghost_hit_list:
                 self.do_next(
                     'Game Over',
                     235,
-                    block_list,
-                    ghost_list,
-                    pacman_collide,
-                    wall_list,
-                    gate,
+                    self.block_list,
+                    self.ghost_list,
+                    self.pacman_collide,
+                    self.wall_list,
+                    self.gate,
                 )
                 return
 
@@ -653,4 +683,4 @@ if __name__ == '__main__':
     # main function
     game = Game()
     game.start_game()
-    pygame.quit()
+    pygame.quit()
\ No newline at end of file
diff --git a/games/pacman/pacman_env.py b/games/pacman/pacman_env.py
new file mode 100644
index 0000000..7f003bd
--- /dev/null
+++ b/games/pacman/pacman_env.py
@@ -0,0 +1,393 @@
+import gymnasium as gym
+from gymnasium import spaces
+import pygame
+import numpy as np
+import os
+import sys
+from pygame.locals import *
+import time
+# Import your game modules
+from games.pacman.player import pacman
+from games.pacman.ghost import ghost
+from games.pacman.path import path_finder
+from games.pacman.level import level
+from games.pacman.game import game
+from games.pacman.fruit import fruit
+from games.pacman.config import *
+import networkx as nx
+
+import gymnasium as gym
+from gymnasium import spaces
+import pygame
+import numpy as np
+import os
+import networkx as nx
+import torch
+
+# Import your game modules
+from games.pacman.player import pacman
+from games.pacman.ghost import ghost
+from games.pacman.path import path_finder
+from games.pacman.level import level
+from games.pacman.game import game
+from games.pacman.fruit import fruit
+from games.pacman.config import *
+
+class PacmanEnv(gym.Env):
+    metadata = {'render.modes': ['human', 'rgb_array']}
+    
+    def __init__(self, render_mode='human', observation_type='pixel'):
+        super(PacmanEnv, self).__init__()
+
+        self.render_mode = render_mode
+        self.observation_type = observation_type
+
+        # Action space (4 directions)
+        self.action_space = spaces.Discrete(4)  # [Up, Down, Left, Right]
+
+        # Observation space
+        self.frame_stack = 4
+        self.window_width = 336
+        self.window_height = 368  # Updated to match the actual game window height
+        if observation_type == 'pixel':
+            self.observation_space = spaces.Box(low=0, high=255,
+                                                shape=(self.window_height, self.window_width, 3 * self.frame_stack),
+                                                dtype=np.uint8)
+        else:
+            self.observation_space = spaces.Box(low=-np.inf, high=np.inf, shape=(111, 8), dtype=np.float32)  # Adjust based on fixed object size
+
+        # Initialize the game
+        pygame.init()
+        self.window = pygame.display.set_mode((1, 1))
+        pygame.display.set_caption("Pacman")
+        self.screen = pygame.display.get_surface()
+        self.frame_buffer = np.zeros((self.window_height, self.window_width, 3 * self.frame_stack), dtype=np.uint8)
+
+        self.tileID = {}
+        self.tileIDName = {}
+        self.tileIDImage = {}
+        self.NO_GIF_TILES = set()
+        self.path = path_finder()
+        self.player = pacman(self.path, self.screen)
+        self.ghosts = {i: ghost(i, self.path, self.screen, self.player) for i in range(6)}
+        self.fruit = fruit()
+        self.game = game(self.fruit, self.player, self.screen)
+        self.level = level(self.game, self.player, self.ghosts, self.path, self.fruit, self.screen)
+
+        self.load_resources()
+
+    def load_resources(self):
+        lineNum = 0
+        self.SCRIPT_PATH = os.path.dirname(__file__)
+        res_path = os.path.join(self.SCRIPT_PATH, "res")
+        # Load background images
+        self.img_Background = pygame.image.load(os.path.join(res_path, "backgrounds", "1.gif")).convert()
+        
+        f = open(os.path.join(self.SCRIPT_PATH, "res", "crossref.txt"), 'r')
+
+        # Load tile images and other assets by initializing the cross-reference data structures
+        for i in f.readlines():
+            while len(i) > 0 and (i[-1] == '\n' or i[-1] == '\r'):
+                i = i[:-1]
+            while len(i) > 0 and (i[0] == '\n' or i[0] == '\r'):
+                i = i[1:]
+            str_splitBySpace = i.split(' ')
+            
+            j = str_splitBySpace[0]
+                
+            if j == "'" or j == "" or j == "#":
+                useLine = False
+            else:
+                useLine = True
+            
+            if useLine == True:
+                self.tileIDName[int(str_splitBySpace[0])] = str_splitBySpace[1]
+                self.tileID[str_splitBySpace[1]] = int(str_splitBySpace[0])
+                
+                thisID = int(str_splitBySpace[0])
+                if thisID not in self.NO_GIF_TILES:
+                    self.tileIDImage[thisID] = pygame.image.load(os.path.join(self.SCRIPT_PATH, "res", "tiles", str_splitBySpace[1] + ".gif")).convert()
+                else:
+                    self.tileIDImage[thisID] = pygame.Surface((16, 16))
+                
+                # Change colors in tileIDImage to match maze colors
+                for y in range(0, 16, 1):
+                    for x in range(0, 16, 1):
+                        if self.tileIDImage[thisID].get_at((x, y)) == (255, 206, 255, 255):
+                            self.tileIDImage[thisID].set_at((x, y), self.level.edgeLightColor)
+                        elif self.tileIDImage[thisID].get_at((x, y)) == (132, 0, 132, 255):
+                            self.tileIDImage[thisID].set_at((x, y), self.level.fillColor)
+                        elif self.tileIDImage[thisID].get_at((x, y)) == (255, 0, 255, 255):
+                            self.tileIDImage[thisID].set_at((x, y), self.level.edgeShadowColor)
+                        elif self.tileIDImage[thisID].get_at((x, y)) == (128, 0, 128, 255):
+                            self.tileIDImage[thisID].set_at((x, y), self.level.pelletColor)
+            lineNum += 1
+
+    def reset(self):
+        # Reset the game
+        self.player = pacman(self.path, self.screen)
+        self.ghosts = {i: ghost(i, self.path, self.screen, self.player) for i in range(6)}
+        self.fruit = fruit()
+        self.game = game(self.fruit, self.player, self.screen)
+        self.level = level(self.game, self.player, self.ghosts, self.path, self.fruit, self.screen)
+        self.load_resources()
+
+        self.clock = pygame.time.Clock()
+        self.game.StartNewGame(self.level, self.tileID, self.tileIDImage, self.tileIDName)
+        self.level.LoadLevel(self.game.GetLevelNum(), self.tileID, self.tileIDImage, self.tileIDName)
+        self.window = pygame.display.set_mode(self.game.screenSize, pygame.DOUBLEBUF | pygame.HWSURFACE)
+        self.frame_buffer = np.zeros((self.window_height, self.window_width, 3 * self.frame_stack), dtype=np.uint8)
+
+        if self.observation_type == 'pixel':
+            return self._get_observation(), {}
+        else:
+            return self.get_object_data(), {}
+
+    def step(self, action):
+        reward = 0
+        done = False
+        # Map action to game controls
+        if self.game.mode == 1:
+            if action == 0 and not self.level.CheckIfHitWall(self.player.x + self.player.speed, self.player.y, self.player.nearestRow, self.player.nearestCol):
+                self.player.velX = self.player.speed
+                self.player.velY = 0
+            elif action == 1 and not self.level.CheckIfHitWall(self.player.x - self.player.speed, self.player.y, self.player.nearestRow, self.player.nearestCol):
+                self.player.velX = -self.player.speed
+                self.player.velY = 0
+            elif action == 2 and not self.level.CheckIfHitWall(self.player.x, self.player.y + self.player.speed, self.player.nearestRow, self.player.nearestCol):
+                self.player.velX = 0
+                self.player.velY = self.player.speed
+            elif action == 3 and not self.level.CheckIfHitWall(self.player.x, self.player.y - self.player.speed, self.player.nearestRow, self.player.nearestCol):
+                self.player.velX = 0
+                self.player.velY = -self.player.speed
+
+            score = self.game.score
+            self.game.modeTimer += 1
+            self.player.Move(self.game, self.level, self.ghosts, self.fruit, self.tileID)
+            for ghost in self.ghosts.values():
+                ghost.Move(self.level, self.tileID)
+           
+            new_score = self.game.score
+            reward = new_score - score  # Reward for eating pellets
+
+        elif self.game.mode == 2:
+            reward = -100
+            # self.game.modeTimer += 1
+            # if self.game.modeTimer == 90:
+            self.level.Restart(self.tileID)
+            self.game.lives -= 1
+            if self.game.lives == -1:
+                done = True
+            
+        elif self.game.mode == 5:
+            reward = 100
+            self.game.mode = 1
+        
+        elif self.game.mode == 6:
+            reward = 1000
+            done = True
+
+        if self.observation_type == 'pixel':
+            observation = self._get_observation()
+        else:
+            observation = self.get_object_data()
+
+        return observation, reward, done, {}
+
+      # Return initial state
+    def _get_observation(self):
+        # You can also choose to return other representations of the game state
+        frame = pygame.surfarray.array3d(pygame.display.get_surface())
+        frame = frame.transpose((1, 0, 2))  # Correct the shape to (height, width, channels)
+        # Update frame buffer
+        self.frame_buffer = np.roll(self.frame_buffer, -3, axis=2)
+        self.frame_buffer[:, :, -3:] = frame
+        return self.frame_buffer
+
+    def get_object_data(self):
+        max_ghosts = 4  # Maximum number of ghosts
+        max_pellets = self.level.pellets  # Maximum number of pellets
+        max_power_pellets = 4  # Maximum number of power pellets
+
+        # Initialize fixed-size arrays for objects
+        pacman_features = [self.player.x, self.player.y, self.player.velX, self.player.velY, 1, 0, 0, 0]
+        
+        ghost_features = [[0, 0, 0, 0, 0, 0, 0, 0] for _ in range(max_ghosts)]
+        for i, ghost in enumerate(self.ghosts.values()):
+            if i < max_ghosts:
+                ghost_features[i] = [ghost.x, ghost.y, ghost.velX, ghost.velY, 0, 1, 0, 0]
+
+        pellet_features = [[0, 0, 0, 0, 0, 0, 0, 0] for _ in range(max_pellets)]
+        current_pellets = self.level.GetPelletLocations()
+        for i, pellet in enumerate(current_pellets):
+            if i < max_pellets:
+                pellet_features[i] = [pellet[0], pellet[1], 0, 0, 0, 0, 1, 0]
+
+        power_pellet_features = [[0, 0, 0, 0, 0, 0, 0, 0] for _ in range(max_power_pellets)]
+        current_power_pellets = self.level.GetPowerPelletLocations()
+        for i, power_pellet in enumerate(current_power_pellets):
+            if i < max_power_pellets:
+                power_pellet_features[i] = [power_pellet[0], power_pellet[1], 0, 0, 0, 0, 0, 1]
+
+        # Combine all features into a single tensor
+        features = [pacman_features] + ghost_features + pellet_features + power_pellet_features
+
+        return torch.tensor(features, dtype=torch.float32)
+    def get_graph_data(self):
+        # Initialize a NetworkX graph
+        graph = nx.Graph()
+
+        # Define object features and add nodes
+        pacman_features = [self.player.x, self.player.y, self.player.velX, self.player.velY, 1, 0, 0, 0]
+        graph.add_node("pacman", type="object", features=pacman_features)
+
+        ghost_features = [[ghost.x, ghost.y, ghost.velX, ghost.velY,0,1,0,0] for ghost in self.ghosts.values()]
+        for i, features in enumerate(ghost_features):
+            graph.add_node(f"ghost_{i}", type="object", features=features)
+
+        pellet_features = [[pellet[0], pellet[1],0,0,0,0,1,0] for pellet in self.level.GetPelletLocations()]
+        for i, features in enumerate(pellet_features):
+            graph.add_node(f"pellet_{i}", type="object", features=features)
+
+        power_pellet_features = [[pellet[0], pellet[1],0,0,0,0,0,1] for pellet in self.level.GetPowerPelletLocations()]
+        for i, features in enumerate(power_pellet_features):
+            graph.add_node(f"power_pellet_{i}", type="object", features=features)
+
+        # Combine object positions
+        object_positions = {
+            "pacman": pacman_features[:2],
+        }
+        for i, ghost in enumerate(self.ghosts.values()):
+            object_positions[f"ghost_{i}"] = ghost_features[i][:2]
+        for i, pellet in enumerate(self.level.GetPelletLocations()):
+            object_positions[f"pellet_{i}"] = pellet_features[i][:2]
+        for i, power_pellet in enumerate(self.level.GetPowerPelletLocations()):
+            object_positions[f"power_pellet_{i}"] = power_pellet_features[i][:2]
+
+        # Proximity threshold for creating atoms
+        #proximity_threshold = self.proximity_threshold
+
+        # Create atom nodes and edges based on proximity
+        atom_index = len(object_positions)  # Start indexing atoms after all objects
+
+        # Determine wall proximity around Pac-Man
+        walls = {
+            'up': self.level.CheckIfHitWall(self.player.x, self.player.y - self.player.velY, self.player.y - 1, self.player.x),
+            'down': self.level.CheckIfHitWall(self.player.x, self.player.y + self.player.velY, self.player.y + 1, self.player.x),
+            'left': self.level.CheckIfHitWall(self.player.x - self.player.velX, self.player.y, self.player.y, self.player.x - 1),
+            'right': self.level.CheckIfHitWall(self.player.x + self.player.velX, self.player.y, self.player.y, self.player.x + 1)
+        }
+
+        standard_feature_vector_size = len(pacman_features)
+        empty_feature_vector = [0] *(2* standard_feature_vector_size)
+
+        # Add wall direction atoms and edges for Pac-Man
+        for direction, hit in walls.items():
+            if hit:
+                atom_node = f"Wall{direction.capitalize()}_{atom_index}"
+                graph.add_node(atom_node, type="atom", features=empty_feature_vector, predicate=f"Wall{direction.capitalize()}")
+                graph.add_edge("pacman", atom_node, position=0)
+                atom_index += 1
+
+        # Add distance and direction atoms and edges for ghosts
+        for i, ghost_pos in enumerate(ghost_features):
+            distance = np.linalg.norm(np.array(pacman_features[:2]) - np.array(ghost_pos[:2]))
+            direction = np.array(pacman_features[:2]) - np.array(ghost_pos[:2])
+            
+            atom_node_distance = f"Distance_Pacman_Ghost_{i}_{atom_index}"
+            graph.add_node(atom_node_distance,features=empty_feature_vector, type="atom", predicate="Distance")
+            graph.add_edge("pacman", atom_node_distance, position=0)
+            graph.add_edge(f"ghost_{i}", atom_node_distance, position=1)
+            
+            atom_index += 1
+
+            if pacman_features[0] == ghost_pos[0]:
+                atom_node_same_row = f"SameRow_Pacman_Ghost_{i}_{atom_index}"
+                graph.add_node(atom_node_same_row, features=empty_feature_vector,type="atom", predicate="SameRow")
+                graph.add_edge("pacman", atom_node_same_row, position=0)
+                graph.add_edge(f"ghost_{i}", atom_node_same_row, position=1)
+                atom_index += 1
+
+            if pacman_features[1] == ghost_pos[1]:
+                atom_node_same_column = f"SameColumn_Pacman_Ghost_{i}_{atom_index}"
+                graph.add_node(atom_node_same_column, features=empty_feature_vector, type="atom", predicate="SameColumn")
+                graph.add_edge("pacman", atom_node_same_column, position=0)
+                graph.add_edge(f"ghost_{i}", atom_node_same_column, position=1)
+                atom_index += 1
+
+        # Add distance and direction atoms and edges for pellets
+        for i, pellet_pos in enumerate(pellet_features):
+            distance = np.linalg.norm(np.array(pacman_features[:2]) - np.array(pellet_pos[:2]))
+            
+            atom_node_distance = f"Distance_Pacman_Pellet_{i}_{atom_index}"
+            graph.add_node(atom_node_distance, features=empty_feature_vector,type="atom", predicate="Distance")
+            graph.add_edge("pacman", atom_node_distance, position=0)
+            graph.add_edge(f"pellet_{i}", atom_node_distance, position=1)
+            
+            atom_index += 1
+
+        # Add distance and direction atoms and edges for power pellets
+        for i, power_pellet_pos in enumerate(power_pellet_features):
+            distance = np.linalg.norm(np.array(pacman_features[:2]) - np.array(power_pellet_pos[:2]))
+            
+            atom_node_distance = f"Distance_Pacman_PowerPellet_{i}_{atom_index}"
+            graph.add_node(atom_node_distance,features=empty_feature_vector, type="atom", predicate="Distance")
+            graph.add_edge("pacman", atom_node_distance, position=0)
+            graph.add_edge(f"power_pellet_{i}", atom_node_distance, position=1)
+            
+            atom_index += 1
+
+        # Create a GraphConverter object
+        #converter = GraphConverter()
+
+        # Convert the NetworkX graph to a PyG Data object
+        #data = converter.to_pyg_data(graph)
+        return graph
+    
+
+    
+    def render(self, mode='human'):
+        self.screen.blit(self.img_Background, (0, 0))
+        self.level.DrawMap(self.tileID, self.tileIDImage)
+        
+        if self.game.fruitScoreTimer > 0:
+            if self.game.modeTimer % 2 == 0:
+                self.game.DrawNumber (2500, self.fruit.x - self.game.screenPixelPos[0] - 16, self.fruit.y - self.screenPixelPos[1] + 4)
+
+        for i in range(0, 4, 1):
+            self.ghosts[i].Draw(self.game,self.tileID, self.tileIDImage, self.ghosts)
+        self.fruit.Draw(self.game)
+        self.player.Draw(self.game)
+        if mode == 'human':
+            
+            pygame.display.flip()
+        elif mode == 'rgb_array':
+            return pygame.surfarray.array3d(pygame.display.get_surface())
+
+    def close(self):
+        pygame.quit()
+
+# Usage Example
+if __name__ == "__main__":
+    env = PacmanEnv()
+    obs = env.reset()
+    done = False
+
+    while not done:
+        #env.render()  # Ensure the environment is rendered every loop
+        action = env.action_space.sample()
+        
+        obs, reward, done, info = env.step(action)
+        env.render()
+        if reward<0:
+            print("Ghost collision")
+        #print(f"Action: {action}, Reward: {reward}")
+        #time.sleep(0.1)  # Add a delay to make changes observable
+
+        if done:
+            print("Game Over. Restarting...")
+            obs = env.reset()
+            done = False
+
+    env.close() 
+
diff --git a/games/pacman/pacman_new.py b/games/pacman/pacman_new.py
new file mode 100644
index 0000000..2b5c7d1
--- /dev/null
+++ b/games/pacman/pacman_new.py
@@ -0,0 +1,1590 @@
+#! /usr/bin/python
+
+# pacman.pyw
+# By David Reilly
+
+# Modified by Andy Sommerville, 8 October 2007:
+# - Changed hard-coded DOS paths to os.path calls
+# - Added constant SCRIPT_PATH (so you don't need to have pacman.pyw and res in your cwd, as long
+# -   as those two are in the same directory)
+# - Changed text-file reading to accomodate any known EOLn method (\n, \r, or \r\n)
+# - I (happily) don't have a Windows box to test this. Blocks marked "WIN???"
+# -   should be examined if this doesn't run in Windows
+# - Added joystick support (configure by changing JS_* constants)
+# - Added a high-score list. Depends on wx for querying the user's name
+
+import pygame, sys, os, random
+from pygame.locals import *
+
+# WIN???
+SCRIPT_PATH=sys.path[0]
+
+# NO_GIF_TILES -- tile numbers which do not correspond to a GIF file
+# currently only "23" for the high-score list
+NO_GIF_TILES=[23]
+
+NO_WX=0 # if set, the high-score code will not attempt to ask the user his name
+USER_NAME="User" # USER_NAME=os.getlogin() # the default user name if wx fails to load or NO_WX
+
+# Joystick defaults - maybe add a Preferences dialog in the future?
+JS_DEVNUM=0 # device 0 (pygame joysticks always start at 0). if JS_DEVNUM is not a valid device, will use 0
+JS_XAXIS=0 # axis 0 for left/right (default for most joysticks)
+JS_YAXIS=1 # axis 1 for up/down (default for most joysticks)
+JS_STARTBUTTON=0 # button number to start the game. this is a matter of personal preference, and will vary from device to device
+
+# Must come before pygame.init()
+pygame.mixer.pre_init(22050,16,2,512)
+JS_STARTBUTTON=0 # button number to start the game. this is a matter of personal preference, and will vary from device to device
+pygame.mixer.init()
+
+clock = pygame.time.Clock()
+pygame.init()
+
+window = pygame.display.set_mode((1, 1))
+pygame.display.set_caption("Pacman")
+
+screen = pygame.display.get_surface()
+
+img_Background = pygame.image.load(os.path.join(SCRIPT_PATH,"res","backgrounds","1.gif")).convert()
+
+snd_pellet = {}
+snd_pellet[0] = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","pellet1.wav"))
+snd_pellet[1] = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","pellet2.wav"))
+snd_powerpellet = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","powerpellet.wav"))
+snd_eatgh = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","eatgh2.wav"))
+snd_fruitbounce = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","fruitbounce.wav"))
+snd_eatfruit = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","eatfruit.wav"))
+snd_extralife = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","extralife.wav"))
+
+ghostcolor = {}
+ghostcolor[0] = (255, 0, 0, 255)
+ghostcolor[1] = (255, 128, 255, 255)
+ghostcolor[2] = (128, 255, 255, 255)
+ghostcolor[3] = (255, 128, 0, 255)
+ghostcolor[4] = (50, 50, 255, 255) # blue, vulnerable ghost
+ghostcolor[5] = (255, 255, 255, 255) # white, flashing ghost
+
+#      ___________________
+# ___/  class definitions  \_______________________________________________
+
+class game ():
+
+    def defaulthiscorelist(self):
+            return [ (100000,"David") , (80000,"Andy") , (60000,"Count Pacula") , (40000,"Cleopacra") , (20000,"Brett Favre") , (10000,"Sergei Pachmaninoff") ]
+
+    def gethiscores(self):
+            """If res/hiscore.txt exists, read it. If not, return the default high scores.
+               Output is [ (score,name) , (score,name) , .. ]. Always 6 entries."""
+            try:
+              f=open(os.path.join(SCRIPT_PATH,"res","hiscore.txt"))
+              hs=[]
+              for line in f:
+                while len(line)>0 and (line[0]=="\n" or line[0]=="\r"): line=line[1:]
+                while len(line)>0 and (line[-1]=="\n" or line[-1]=="\r"): line=line[:-1]
+                score=int(line.split(" ")[0])
+                name=line.partition(" ")[2]
+                if score>99999999: score=99999999
+                if len(name)>22: name=name[:22]
+                hs.append((score,name))
+              f.close()
+              if len(hs)>6: hs=hs[:6]
+              while len(hs)<6: hs.append((0,""))
+              return hs
+            except IOError:
+              return self.defaulthiscorelist()
+              
+    def writehiscores(self,hs):
+            """Given a new list, write it to the default file."""
+            fname=os.path.join(SCRIPT_PATH,"res","hiscore.txt")
+            f=open(fname,"w")
+            for line in hs:
+              f.write(str(line[0])+" "+line[1]+"\n")
+            f.close()
+            
+    def getplayername(self):
+            """Ask the player his name, to go on the high-score list."""
+            if NO_WX: return USER_NAME
+            try:
+              import wx
+            except:
+              print("Pacman Error: No module wx. Can not ask the user his name!")
+              print( "     :(       Download wx from http://www.wxpython.org/")
+              print( "     :(       To avoid seeing this error again, set NO_WX in file pacman.pyw.")
+              return USER_NAME
+            app=wx.App(None)
+            dlog=wx.TextEntryDialog(None,"You made the high-score list! Name:")
+            dlog.ShowModal()
+            name=dlog.GetValue()
+            dlog.Destroy()
+            app.Destroy()
+            return name
+              
+    def updatehiscores(self,newscore):
+            """Add newscore to the high score list, if appropriate."""
+            hs=self.gethiscores()
+            for line in hs:
+              if newscore>=line[0]:
+                hs.insert(hs.index(line),(newscore,self.getplayername()))
+                hs.pop(-1)
+                break
+            self.writehiscores(hs)
+
+    def makehiscorelist(self):
+            "Read the High-Score file and convert it to a useable Surface."
+            # My apologies for all the hard-coded constants.... -Andy
+            f=pygame.font.Font(os.path.join(SCRIPT_PATH,"res","VeraMoBd.ttf"),10)
+            scoresurf=pygame.Surface((276,86),pygame.SRCALPHA)
+            scoresurf.set_alpha(200)
+            linesurf=f.render(" "*18+"HIGH SCORES",1,(255,255,0))
+            scoresurf.blit(linesurf,(0,0))
+            hs=self.gethiscores()
+            vpos=0
+            for line in hs:
+              vpos+=12
+              linesurf=f.render(line[1].rjust(22)+str(line[0]).rjust(9),1,(255,255,255))
+              scoresurf.blit(linesurf,(0,vpos))
+            return scoresurf
+            
+    def drawmidgamehiscores(self):
+            """Redraw the high-score list image after pacman dies."""
+            self.imHiscores=self.makehiscorelist()
+
+    def __init__ (self):
+        self.levelNum = 0
+        self.score = 0
+        self.lives = 3
+        
+        # game "mode" variable
+        # 1 = normal
+        # 2 = hit ghost
+        # 3 = game over
+        # 4 = wait to start
+        # 5 = wait after eating ghost
+        # 6 = wait after finishing level
+        self.mode = 0
+        self.modeTimer = 0
+        self.ghostTimer = 0
+        self.ghostValue = 0
+        self.fruitTimer = 0
+        self.fruitScoreTimer = 0
+        self.fruitScorePos = (0, 0)
+        
+        self.SetMode( 3 )
+        
+        # camera variables
+        self.screenPixelPos = (0, 0) # absolute x,y position of the screen from the upper-left corner of the level
+        self.screenNearestTilePos = (0, 0) # nearest-tile position of the screen from the UL corner
+        self.screenPixelOffset = (0, 0) # offset in pixels of the screen from its nearest-tile position
+        
+        self.screenTileSize = (23, 21)
+        self.screenSize = (self.screenTileSize[1] * 16, self.screenTileSize[0] * 16)
+
+        # numerical display digits
+        self.digit = {}
+        for i in range(0, 10, 1):
+            self.digit[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","text",str(i) + ".gif")).convert()
+        self.imLife = pygame.image.load(os.path.join(SCRIPT_PATH,"res","text","life.gif")).convert()
+        self.imGameOver = pygame.image.load(os.path.join(SCRIPT_PATH,"res","text","gameover.gif")).convert()
+        self.imReady = pygame.image.load(os.path.join(SCRIPT_PATH,"res","text","ready.gif")).convert()
+        self.imLogo = pygame.image.load(os.path.join(SCRIPT_PATH,"res","text","logo.gif")).convert()
+        self.imHiscores = self.makehiscorelist()
+        
+    def StartNewGame (self):
+        self.levelNum = 1
+        self.score = 0
+        self.lives = 3
+        
+        self.SetMode( 4 )
+        thisLevel.LoadLevel( thisGame.GetLevelNum() )
+            
+    def AddToScore (self, amount):
+        
+        extraLifeSet = [25000, 50000, 100000, 150000]
+        
+        for specialScore in extraLifeSet:
+            if self.score < specialScore and self.score + amount >= specialScore:
+                snd_extralife.play()
+                thisGame.lives += 1
+        
+        self.score += amount
+        
+    
+    def DrawScore (self):
+        self.DrawNumber (self.score, 24 + 16, self.screenSize[1] - 24 )
+            
+        for i in range(0, self.lives, 1):
+            screen.blit (self.imLife, (24 + i * 10 + 16, self.screenSize[1] - 12) )
+            
+        screen.blit (thisFruit.imFruit[ thisFruit.fruitType ], (4 + 16, self.screenSize[1] - 20) )
+            
+        if self.mode == 3:
+            screen.blit (self.imGameOver, (self.screenSize[0] / 2 - 32, self.screenSize[1] / 2 - 10) )
+        elif self.mode == 4:
+            screen.blit (self.imReady, (self.screenSize[0] / 2 - 20, self.screenSize[1] / 2 + 12) )
+            
+        self.DrawNumber (self.levelNum, 0, self.screenSize[1] - 12 )
+            
+    def DrawNumber (self, number, x, y):
+        strNumber = str(int(number))
+        for i in range(0, len(strNumber), 1):
+            iDigit = int(strNumber[i])
+            screen.blit (self.digit[ iDigit ], (x + i * 9, y) )
+        
+    def SmartMoveScreen (self):
+            
+        possibleScreenX = player.x - self.screenTileSize[1] / 2 * 16
+        possibleScreenY = player.y - self.screenTileSize[0] / 2 * 16
+        
+        if possibleScreenX < 0:
+            possibleScreenX = 0
+        elif possibleScreenX > thisLevel.lvlWidth * 16 - self.screenSize[0]:
+            possibleScreenX = thisLevel.lvlWidth * 16 - self.screenSize[0]
+            
+        if possibleScreenY < 0:
+            possibleScreenY = 0
+        elif possibleScreenY > thisLevel.lvlHeight * 16 - self.screenSize[1]:
+            possibleScreenY = thisLevel.lvlHeight * 16 - self.screenSize[1]
+        
+        thisGame.MoveScreen( possibleScreenX, possibleScreenY )
+        
+    def MoveScreen (self, newX, newY ):
+        self.screenPixelPos = (newX, newY)
+        self.screenNearestTilePos = (int(newY / 16), int(newX / 16)) # nearest-tile position of the screen from the UL corner
+        self.screenPixelOffset = (newX - self.screenNearestTilePos[1]*16, newY - self.screenNearestTilePos[0]*16)
+        
+    def GetScreenPos (self):
+        return self.screenPixelPos
+        
+    def GetLevelNum (self):
+        return self.levelNum
+    
+    def SetNextLevel (self):
+        self.levelNum += 1
+        
+        self.SetMode( 4 )
+        thisLevel.LoadLevel( thisGame.GetLevelNum() )
+        
+        player.velX = 0
+        player.velY = 0
+        player.anim_pacmanCurrent = player.anim_pacmanS
+        
+        
+    def SetMode (self, newMode):
+        self.mode = newMode
+        self.modeTimer = 0
+        # print " ***** GAME MODE IS NOW ***** " + str(newMode)
+        
+class node ():
+    
+    def __init__ (self):
+        self.g = -1 # movement cost to move from previous node to this one (usually +10)
+        self.h = -1 # estimated movement cost to move from this node to the ending node (remaining horizontal and vertical steps * 10)
+        self.f = -1 # total movement cost of this node (= g + h)
+        # parent node - used to trace path back to the starting node at the end
+        self.parent = (-1, -1)
+        # node type - 0 for empty space, 1 for wall (optionally, 2 for starting node and 3 for end)
+        self.type = -1
+        
+class path_finder ():
+    
+    def __init__ (self):
+        # map is a 1-DIMENSIONAL array.
+        # use the Unfold( (row, col) ) function to convert a 2D coordinate pair
+        # into a 1D index to use with this array.
+        self.map = {}
+        self.size = (-1, -1) # rows by columns
+        
+        self.pathChainRev = ""
+        self.pathChain = ""
+                
+        # starting and ending nodes
+        self.start = (-1, -1)
+        self.end = (-1, -1)
+        
+        # current node (used by algorithm)
+        self.current = (-1, -1)
+        
+        # open and closed lists of nodes to consider (used by algorithm)
+        self.openList = []
+        self.closedList = []
+        
+        # used in algorithm (adjacent neighbors path finder is allowed to consider)
+        self.neighborSet = [ (0, -1), (0, 1), (-1, 0), (1, 0) ]
+        
+    def ResizeMap (self, numRows, numCols):
+        self.map = {}
+        self.size = (numRows, numCols)
+
+        # initialize path_finder map to a 2D array of empty nodes
+        for row in range(0, self.size[0], 1):
+            for col in range(0, self.size[1], 1):
+                self.Set( row, col, node() )
+                self.SetType( row, col, 0 )
+        
+    def CleanUpTemp (self):
+        
+        # this resets variables needed for a search (but preserves the same map / maze)
+    
+        self.pathChainRev = ""
+        self.pathChain = ""
+        self.current = (-1, -1)
+        self.openList = []
+        self.closedList = []
+        
+    def FindPath (self, startPos, endPos ):
+        
+        self.CleanUpTemp()
+        
+        # (row, col) tuples
+        self.start = startPos
+        self.end = endPos
+        
+        # add start node to open list
+        self.AddToOpenList( self.start )
+        self.SetG ( self.start, 0 )
+        self.SetH ( self.start, 0 )
+        self.SetF ( self.start, 0 )
+        
+        doContinue = True
+        
+        while (doContinue == True):
+        
+            thisLowestFNode = self.GetLowestFNode()
+
+            if not thisLowestFNode == self.end and not thisLowestFNode == False:
+                self.current = thisLowestFNode
+                self.RemoveFromOpenList( self.current )
+                self.AddToClosedList( self.current )
+                
+                for offset in self.neighborSet:
+                    thisNeighbor = (self.current[0] + offset[0], self.current[1] + offset[1])
+                    
+                    if not thisNeighbor[0] < 0 and not thisNeighbor[1] < 0 and not thisNeighbor[0] > self.size[0] - 1 and not thisNeighbor[1] > self.size[1] - 1 and not self.GetType( thisNeighbor ) == 1:
+                        cost = self.GetG( self.current ) + 10
+                        
+                        if self.IsInOpenList( thisNeighbor ) and cost < self.GetG( thisNeighbor ):
+                            self.RemoveFromOpenList( thisNeighbor )
+                            
+                        #if self.IsInClosedList( thisNeighbor ) and cost < self.GetG( thisNeighbor ):
+                        #   self.RemoveFromClosedList( thisNeighbor )
+                            
+                        if not self.IsInOpenList( thisNeighbor ) and not self.IsInClosedList( thisNeighbor ):
+                            self.AddToOpenList( thisNeighbor )
+                            self.SetG( thisNeighbor, cost )
+                            self.CalcH( thisNeighbor )
+                            self.CalcF( thisNeighbor )
+                            self.SetParent( thisNeighbor, self.current )
+            else:
+                doContinue = False
+                        
+        if thisLowestFNode == False:
+            return False
+                        
+        # reconstruct path
+        self.current = self.end
+        while not self.current == self.start:
+            # build a string representation of the path using R, L, D, U
+            if self.current[1] > self.GetParent(self.current)[1]:
+                self.pathChainRev += 'R' 
+            elif self.current[1] < self.GetParent(self.current)[1]:
+                self.pathChainRev += 'L'
+            elif self.current[0] > self.GetParent(self.current)[0]:
+                self.pathChainRev += 'D'
+            elif self.current[0] < self.GetParent(self.current)[0]:
+                self.pathChainRev += 'U'
+            self.current = self.GetParent(self.current)
+            self.SetType( self.current[0],self.current[1], 4)
+            
+        # because pathChainRev was constructed in reverse order, it needs to be reversed!
+        for i in range(len(self.pathChainRev) - 1, -1, -1):
+            self.pathChain += self.pathChainRev[i]
+        
+        # set start and ending positions for future reference
+        self.SetType( self.start[0],self.start[1], 2)
+        self.SetType( self.end[0],self.start[1], 3)
+        
+        return self.pathChain
+
+    def Unfold (self, row,col):
+        # this function converts a 2D array coordinate pair (row, col)
+        # to a 1D-array index, for the object's 1D map array.
+        return (row * self.size[1]) + col
+    
+    def Set (self, row,col, newNode):
+        # sets the value of a particular map cell (usually refers to a node object)
+        self.map[ self.Unfold(row, col) ] = newNode
+        
+    def GetType (self,val):
+        row,col = val
+        return self.map[ self.Unfold(row, col) ].type
+        
+    def SetType (self,row,col, newValue):
+        self.map[ self.Unfold(row, col) ].type = newValue
+
+    def GetF (self, val):
+        row,col = val
+        return self.map[ self.Unfold(row, col) ].f
+
+    def GetG (self, val):
+        row,col = val
+        return self.map[ self.Unfold(row, col) ].g
+    
+    def GetH (self, val):
+        row,col = val
+        return self.map[ self.Unfold(row, col) ].h
+        
+    def SetG (self, val, newValue ):
+        row,col = val
+        self.map[ self.Unfold(row, col) ].g = newValue
+
+    def SetH (self, val, newValue ):
+        row,col = val
+        self.map[ self.Unfold(row, col) ].h = newValue
+        
+    def SetF (self, val, newValue ):
+        row,col = val
+        self.map[ self.Unfold(row, col) ].f = newValue
+        
+    def CalcH (self, val):
+        row,col = val
+        self.map[ self.Unfold(row, col) ].h = abs(row - self.end[0]) + abs(col - self.end[0])
+        
+    def CalcF (self, val):
+        row,col = val
+        unfoldIndex = self.Unfold(row, col)
+        self.map[unfoldIndex].f = self.map[unfoldIndex].g + self.map[unfoldIndex].h
+    
+    def AddToOpenList (self, val):
+        row,col = val
+        self.openList.append( (row, col) )
+        
+    def RemoveFromOpenList (self, val ):
+        row,col = val
+        self.openList.remove( (row, col) )
+        
+    def IsInOpenList (self, val ):
+        row,col = val
+        if self.openList.count( (row, col) ) > 0:
+            return True
+        else:
+            return False
+        
+    def GetLowestFNode (self):
+        lowestValue = 1000 # start arbitrarily high
+        lowestPair = (-1, -1)
+        
+        for iOrderedPair in self.openList:
+            if self.GetF( iOrderedPair ) < lowestValue:
+                lowestValue = self.GetF( iOrderedPair )
+                lowestPair = iOrderedPair
+        
+        if not lowestPair == (-1, -1):
+            return lowestPair
+        else:
+            return False
+        
+    def AddToClosedList (self, val ):
+        row,col = val
+        self.closedList.append( (row, col) )
+        
+    def IsInClosedList (self, val ):
+        row,col = val
+        if self.closedList.count( (row, col) ) > 0:
+            return True
+        else:
+            return False
+
+    def SetParent (self, val, val2 ):
+        row,col = val
+        parentRow,parentCol = val2
+        self.map[ self.Unfold(row, col) ].parent = (parentRow, parentCol)
+
+    def GetParent (self, val ):
+        row,col = val
+        return self.map[ self.Unfold(row, col) ].parent
+        
+    def draw (self):
+        for row in range(0, self.size[0], 1):
+            for col in range(0, self.size[1], 1):
+            
+                thisTile = self.GetType((row, col))
+                screen.blit (tileIDImage[ thisTile ], (col * 32, row * 32))
+        
+class ghost ():
+    def __init__ (self, ghostID):
+        self.x = 0
+        self.y = 0
+        self.velX = 0
+        self.velY = 0
+        self.speed = 1
+        
+        self.nearestRow = 0
+        self.nearestCol = 0
+        
+        self.id = ghostID
+        
+        # ghost "state" variable
+        # 1 = normal
+        # 2 = vulnerable
+        # 3 = spectacles
+        self.state = 1
+        
+        self.homeX = 0
+        self.homeY = 0
+        
+        self.currentPath = ""
+        
+        self.anim = {}
+        for i in range(1, 7, 1):
+            self.anim[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","ghost " + str(i) + ".gif")).convert()
+            
+            # change the ghost color in this frame
+            for y in range(0, 16, 1):
+                for x in range(0, 16, 1):
+                
+                    if self.anim[i].get_at( (x, y) ) == (255, 0, 0, 255):
+                        # default, red ghost body color
+                        self.anim[i].set_at( (x, y), ghostcolor[ self.id ] )
+            
+        self.animFrame = 1
+        self.animDelay = 0
+        
+    def Draw (self):
+        
+        if thisGame.mode == 3:
+            return False
+        
+        
+        # ghost eyes --
+        for y in range(4, 8, 1):
+            for x in range(3, 7, 1):
+                self.anim[ self.animFrame ].set_at( (x, y), (255, 255, 255, 255) )  
+                self.anim[ self.animFrame ].set_at( (x+6, y), (255, 255, 255, 255) )
+                
+                if player.x > self.x and player.y > self.y:
+                    #player is to lower-right
+                    pupilSet = (5, 6)
+                elif player.x < self.x and player.y > self.y:
+                    #player is to lower-left
+                    pupilSet = (3, 6)
+                elif player.x > self.x and player.y < self.y:
+                    #player is to upper-right
+                    pupilSet = (5, 4)
+                elif player.x < self.x and player.y < self.y:
+                    #player is to upper-left
+                    pupilSet = (3, 4)
+                else:
+                    pupilSet = (4, 6)
+                    
+        for y in range(pupilSet[1], pupilSet[1] + 2, 1):
+            for x in range(pupilSet[0], pupilSet[0] + 2, 1):
+                self.anim[ self.animFrame ].set_at( (x, y), (0, 0, 255, 255) )  
+                self.anim[ self.animFrame ].set_at( (x+6, y), (0, 0, 255, 255) )    
+        # -- end ghost eyes
+        
+        if self.state == 1:
+            # draw regular ghost (this one)
+            screen.blit (self.anim[ self.animFrame ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
+        elif self.state == 2:
+            # draw vulnerable ghost
+            
+            if thisGame.ghostTimer > 100:
+                # blue
+                screen.blit (ghosts[4].anim[ self.animFrame ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
+            else:
+                # blue/white flashing
+                tempTimerI = int(thisGame.ghostTimer / 10)
+                if tempTimerI == 1 or tempTimerI == 3 or tempTimerI == 5 or tempTimerI == 7 or tempTimerI == 9:
+                    screen.blit (ghosts[5].anim[ self.animFrame ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
+                else:
+                    screen.blit (ghosts[4].anim[ self.animFrame ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
+            
+        elif self.state == 3:
+            # draw glasses
+            screen.blit (tileIDImage[ tileID[ 'glasses' ] ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
+        
+        if thisGame.mode == 6 or thisGame.mode == 7:
+            # don't animate ghost if the level is complete
+            return False
+        
+        self.animDelay += 1
+        
+        if self.animDelay == 2:
+            self.animFrame += 1 
+        
+            if self.animFrame == 7:
+                # wrap to beginning
+                self.animFrame = 1
+                
+            self.animDelay = 0
+            
+    def Move (self):
+        
+
+        self.x += self.velX
+        self.y += self.velY
+        
+        self.nearestRow = int(((self.y + 8) / 16))
+        self.nearestCol = int(((self.x + 8) / 16))
+
+        if (self.x % 16) == 0 and (self.y % 16) == 0:
+            # if the ghost is lined up with the grid again
+            # meaning, it's time to go to the next path item
+            
+            if (self.currentPath):
+                self.currentPath = self.currentPath[1:]
+                self.FollowNextPathWay()
+        
+            else:
+                self.x = self.nearestCol * 16
+                self.y = self.nearestRow * 16
+            
+                # chase pac-man
+                self.currentPath = path.FindPath( (self.nearestRow, self.nearestCol), (player.nearestRow, player.nearestCol) )
+                self.FollowNextPathWay()
+            
+    def FollowNextPathWay (self):
+        
+        # print "Ghost " + str(self.id) + " rem: " + self.currentPath
+        
+        # only follow this pathway if there is a possible path found!
+        if not self.currentPath == False:
+        
+            if len(self.currentPath) > 0:
+                if self.currentPath[0] == "L":
+                    (self.velX, self.velY) = (-self.speed, 0)
+                elif self.currentPath[0] == "R":
+                    (self.velX, self.velY) = (self.speed, 0)
+                elif self.currentPath[0] == "U":
+                    (self.velX, self.velY) = (0, -self.speed)
+                elif self.currentPath[0] == "D":
+                    (self.velX, self.velY) = (0, self.speed)
+                    
+            else:
+                # this ghost has reached his destination!!
+                
+                if not self.state == 3:
+                    # chase pac-man
+                    self.currentPath = path.FindPath( (self.nearestRow, self.nearestCol), (player.nearestRow, player.nearestCol) )
+                    self.FollowNextPathWay()
+                
+                else:
+                    # glasses found way back to ghost box
+                    self.state = 1
+                    self.speed = self.speed / 4
+                    
+                    # give ghost a path to a random spot (containing a pellet)
+                    (randRow, randCol) = (0, 0)
+
+                    while not thisLevel.GetMapTile(randRow, randCol) == tileID[ 'pellet' ] or (randRow, randCol) == (0, 0):
+                        randRow = random.randint(1, thisLevel.lvlHeight - 2)
+                        randCol = random.randint(1, thisLevel.lvlWidth - 2)
+
+                    self.currentPath = path.FindPath( (self.nearestRow, self.nearestCol), (randRow, randCol) )
+                    self.FollowNextPathWay()
+
+class fruit ():
+    def __init__ (self):
+        # when fruit is not in use, it's in the (-1, -1) position off-screen.
+        self.slowTimer = 0
+        self.x = -16
+        self.y = -16
+        self.velX = 0
+        self.velY = 0
+        self.speed = 1
+        self.active = False
+        
+        self.bouncei = 0
+        self.bounceY = 0
+        
+        self.nearestRow = (-1, -1)
+        self.nearestCol = (-1, -1)
+        
+        self.imFruit = {}
+        for i in range(0, 5, 1):
+            self.imFruit[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","fruit " + str(i) + ".gif")).convert()
+        
+        self.currentPath = ""
+        self.fruitType = 1
+        
+    def Draw (self):
+        
+        if thisGame.mode == 3 or self.active == False:
+            return False
+        
+        screen.blit (self.imFruit[ self.fruitType ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1] - self.bounceY))
+
+            
+    def Move (self):
+        
+        if self.active == False:
+            return False
+        
+        self.bouncei += 1
+        if self.bouncei == 1:
+            self.bounceY = 2
+        elif self.bouncei == 2:
+            self.bounceY = 4
+        elif self.bouncei == 3:
+            self.bounceY = 5
+        elif self.bouncei == 4:
+            self.bounceY = 5
+        elif self.bouncei == 5:
+            self.bounceY = 6
+        elif self.bouncei == 6:
+            self.bounceY = 6
+        elif self.bouncei == 9:
+            self.bounceY = 6
+        elif self.bouncei == 10:
+            self.bounceY = 5
+        elif self.bouncei == 11:
+            self.bounceY = 5
+        elif self.bouncei == 12:
+            self.bounceY = 4
+        elif self.bouncei == 13:
+            self.bounceY = 3
+        elif self.bouncei == 14:
+            self.bounceY = 2
+        elif self.bouncei == 15:
+            self.bounceY = 1
+        elif self.bouncei == 16:
+            self.bounceY = 0
+            self.bouncei = 0
+            snd_fruitbounce.play()
+        
+        self.slowTimer += 1
+        if self.slowTimer == 2:
+            self.slowTimer = 0
+            
+            self.x += self.velX
+            self.y += self.velY
+            
+            self.nearestRow = int(((self.y + 8) / 16))
+            self.nearestCol = int(((self.x + 8) / 16))
+
+            if (self.x % 16) == 0 and (self.y % 16) == 0:
+                # if the fruit is lined up with the grid again
+                # meaning, it's time to go to the next path item
+                
+                if len(self.currentPath) > 0:
+                    self.currentPath = self.currentPath[1:]
+                    self.FollowNextPathWay()
+            
+                else:
+                    self.x = self.nearestCol * 16
+                    self.y = self.nearestRow * 16
+                    
+                    self.active = False
+                    thisGame.fruitTimer = 0
+            
+    def FollowNextPathWay (self):
+        
+
+        # only follow this pathway if there is a possible path found!
+        if not self.currentPath == False:
+        
+            if len(self.currentPath) > 0:
+                if self.currentPath[0] == "L":
+                    (self.velX, self.velY) = (-self.speed, 0)
+                elif self.currentPath[0] == "R":
+                    (self.velX, self.velY) = (self.speed, 0)
+                elif self.currentPath[0] == "U":
+                    (self.velX, self.velY) = (0, -self.speed)
+                elif self.currentPath[0] == "D":
+                    (self.velX, self.velY) = (0, self.speed)
+
+class pacman ():
+    
+    def __init__ (self):
+        self.x = 0
+        self.y = 0
+        self.velX = 0
+        self.velY = 0
+        self.speed = 2
+        
+        self.nearestRow = 0
+        self.nearestCol = 0
+        
+        self.homeX = 0
+        self.homeY = 0
+        
+        self.anim_pacmanL = {}
+        self.anim_pacmanR = {}
+        self.anim_pacmanU = {}
+        self.anim_pacmanD = {}
+        self.anim_pacmanS = {}
+        self.anim_pacmanCurrent = {}
+        
+        for i in range(1, 9, 1):
+            self.anim_pacmanL[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","pacman-l " + str(i) + ".gif")).convert()
+            self.anim_pacmanR[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","pacman-r " + str(i) + ".gif")).convert()
+            self.anim_pacmanU[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","pacman-u " + str(i) + ".gif")).convert()
+            self.anim_pacmanD[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","pacman-d " + str(i) + ".gif")).convert()
+            self.anim_pacmanS[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","pacman.gif")).convert()
+
+        self.pelletSndNum = 0
+        
+    def Move (self):
+        
+        self.nearestRow = int(((self.y + 8) / 16))
+        self.nearestCol = int(((self.x + 8) / 16))
+
+        # make sure the current velocity will not cause a collision before moving
+        if not thisLevel.CheckIfHitWall(self.x + self.velX, self.y + self.velY, self.nearestRow, self.nearestCol):
+            # it's ok to Move
+            self.x += self.velX
+            self.y += self.velY
+            print(self.x, self.y, self.velX, self.velY, self.nearestRow, self.nearestCol)
+            # check for collisions with other tiles (pellets, etc)
+            thisLevel.CheckIfHitSomething(self.x, self.y, self.nearestRow, self.nearestCol)
+            
+            # check for collisions with the ghosts
+            for i in range(0, 4, 1):
+                if thisLevel.CheckIfHit( self.x, self.y, ghosts[i].x, ghosts[i].y, 8):
+                    # hit a ghost
+                    
+                    if ghosts[i].state == 1:
+                        # ghost is normal
+                        thisGame.SetMode( 2 )
+                        
+                    elif ghosts[i].state == 2:
+                        # ghost is vulnerable
+                        # give them glasses
+                        # make them run
+                        thisGame.AddToScore(thisGame.ghostValue)
+                        thisGame.ghostValue = thisGame.ghostValue * 2
+                        snd_eatgh.play()
+                        
+                        ghosts[i].state = 3
+                        ghosts[i].speed = ghosts[i].speed * 4
+                        # and send them to the ghost box
+                        ghosts[i].x = ghosts[i].nearestCol * 16
+                        ghosts[i].y = ghosts[i].nearestRow * 16
+                        ghosts[i].currentPath = path.FindPath( (ghosts[i].nearestRow, ghosts[i].nearestCol), (thisLevel.GetGhostBoxPos()[0]+1, thisLevel.GetGhostBoxPos()[1]) )
+                        ghosts[i].FollowNextPathWay()
+                        
+                        # set game mode to brief pause after eating
+                        thisGame.SetMode( 5 )
+                        
+            # check for collisions with the fruit
+            if thisFruit.active == True:
+                if thisLevel.CheckIfHit( self.x, self.y, thisFruit.x, thisFruit.y, 8):
+                    thisGame.AddToScore(2500)
+                    thisFruit.active = False
+                    thisGame.fruitTimer = 0
+                    thisGame.fruitScoreTimer = 120
+                    snd_eatfruit.play()
+        
+        else:
+            # we're going to hit a wall -- stop moving
+            self.velX = 0
+            self.velY = 0
+            
+        # deal with power-pellet ghost timer
+        if thisGame.ghostTimer > 0:
+            thisGame.ghostTimer -= 1
+            
+            if thisGame.ghostTimer == 0:
+                for i in range(0, 4, 1):
+                    if ghosts[i].state == 2:
+                        ghosts[i].state = 1
+                self.ghostValue = 0
+                
+        # deal with fruit timer
+        thisGame.fruitTimer += 1
+        if thisGame.fruitTimer == 500:
+            pathwayPair = thisLevel.GetPathwayPairPos()
+            
+            if not pathwayPair == False:
+            
+                pathwayEntrance = pathwayPair[0]
+                pathwayExit = pathwayPair[1]
+                
+                thisFruit.active = True
+                
+                thisFruit.nearestRow = pathwayEntrance[0]
+                thisFruit.nearestCol = pathwayEntrance[1]
+                
+                thisFruit.x = thisFruit.nearestCol * 16
+                thisFruit.y = thisFruit.nearestRow * 16
+                
+                thisFruit.currentPath = path.FindPath( (thisFruit.nearestRow, thisFruit.nearestCol), pathwayExit )
+                thisFruit.FollowNextPathWay()
+            
+        if thisGame.fruitScoreTimer > 0:
+            thisGame.fruitScoreTimer -= 1
+            
+        
+    def Draw (self):
+        
+        if thisGame.mode == 3:
+            return False
+        
+        # set the current frame array to match the direction pacman is facing
+        if self.velX > 0:
+            self.anim_pacmanCurrent = self.anim_pacmanR
+        elif self.velX < 0:
+            self.anim_pacmanCurrent = self.anim_pacmanL
+        elif self.velY > 0:
+            self.anim_pacmanCurrent = self.anim_pacmanD
+        elif self.velY < 0:
+            self.anim_pacmanCurrent = self.anim_pacmanU
+            
+        screen.blit (self.anim_pacmanCurrent[ self.animFrame ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
+        
+        if thisGame.mode == 1:
+            if not self.velX == 0 or not self.velY == 0:
+                # only Move mouth when pacman is moving
+                self.animFrame += 1 
+            
+            if self.animFrame == 9:
+                # wrap to beginning
+                self.animFrame = 1
+            
+class level ():
+    
+    def __init__ (self):
+        self.lvlWidth = 0
+        self.lvlHeight = 0
+        self.edgeLightColor = (255, 255, 0, 255)
+        self.edgeShadowColor = (255, 150, 0, 255)
+        self.fillColor = (0, 255, 255, 255)
+        self.pelletColor = (255, 255, 255, 255)
+        
+        self.map = {}
+        
+        self.pellets = 0
+        self.powerPelletBlinkTimer = 0
+        
+    def SetMapTile (self, row, col, newValue):
+        self.map[ (row * self.lvlWidth) + col ] = newValue
+        
+    def GetMapTile (self, row, col):
+        if row >= 0 and row < self.lvlHeight and col >= 0 and col < self.lvlWidth:
+            return self.map[ (row * self.lvlWidth) + col ]
+        else:
+            return 0
+    
+    def IsWall (self, row, col):
+    
+        if row > thisLevel.lvlHeight - 1 or row < 0:
+            return True
+        
+        if col > thisLevel.lvlWidth - 1 or col < 0:
+            return True
+    
+        # check the offending tile ID
+        result = thisLevel.GetMapTile(row, col)
+
+        # if the tile was a wall
+        if result >= 100 and result <= 199:
+            return True
+        else:
+            return False
+    
+                    
+    def CheckIfHitWall (self, possiblePlayerX, possiblePlayerY, row, col):
+    
+        numCollisions = 0
+        
+        # check each of the 9 surrounding tiles for a collision
+        for iRow in range(row - 1, row + 2, 1):
+            for iCol in range(col - 1, col + 2, 1):
+            
+                if  (possiblePlayerX - (iCol * 16) < 16) and (possiblePlayerX - (iCol * 16) > -16) and (possiblePlayerY - (iRow * 16) < 16) and (possiblePlayerY - (iRow * 16) > -16):
+                    
+                    if self.IsWall(iRow, iCol):
+                        numCollisions += 1
+                        
+        if numCollisions > 0:
+            return True
+        else:
+            return False
+        
+        
+    def CheckIfHit (self, playerX, playerY, x, y, cushion):
+    
+        if (playerX - x < cushion) and (playerX - x > -cushion) and (playerY - y < cushion) and (playerY - y > -cushion):
+            return True
+        else:
+            return False
+
+
+    def CheckIfHitSomething (self, playerX, playerY, row, col):
+    
+        for iRow in range(row - 1, row + 2, 1):
+            for iCol in range(col - 1, col + 2, 1):
+            
+                if  (playerX - (iCol * 16) < 16) and (playerX - (iCol * 16) > -16) and (playerY - (iRow * 16) < 16) and (playerY - (iRow * 16) > -16):
+                    # check the offending tile ID
+                    result = thisLevel.GetMapTile(iRow, iCol)
+        
+                    if result == tileID[ 'pellet' ]:
+                        # got a pellet
+                        thisLevel.SetMapTile(iRow, iCol, 0)
+                        snd_pellet[player.pelletSndNum].play()
+                        player.pelletSndNum = 1 - player.pelletSndNum
+                        
+                        thisLevel.pellets -= 1
+                        
+                        thisGame.AddToScore(10)
+                        
+                        if thisLevel.pellets == 0:
+                            # no more pellets left!
+                            # WON THE LEVEL
+                            thisGame.SetMode( 6 )
+                            
+                        
+                    elif result == tileID[ 'pellet-power' ]:
+                        # got a power pellet
+                        thisLevel.SetMapTile(iRow, iCol, 0)
+                        snd_powerpellet.play()
+                        
+                        thisGame.AddToScore(100)
+                        thisGame.ghostValue = 200
+                        
+                        thisGame.ghostTimer = 360
+                        for i in range(0, 4, 1):
+                            if ghosts[i].state == 1:
+                                ghosts[i].state = 2
+                        
+                    elif result == tileID[ 'door-h' ]:
+                        # ran into a horizontal door
+                        for i in range(0, thisLevel.lvlWidth, 1):
+                            if not i == iCol:
+                                if thisLevel.GetMapTile(iRow, i) == tileID[ 'door-h' ]:
+                                    player.x = i * 16
+                                    
+                                    if player.velX > 0:
+                                        player.x += 16
+                                    else:
+                                        player.x -= 16
+                                        
+                    elif result == tileID[ 'door-v' ]:
+                        # ran into a vertical door
+                        for i in range(0, thisLevel.lvlHeight, 1):
+                            if not i == iRow:
+                                if thisLevel.GetMapTile(i, iCol) == tileID[ 'door-v' ]:
+                                    player.y = i * 16
+                                    
+                                    if player.velY > 0:
+                                        player.y += 16
+                                    else:
+                                        player.y -= 16
+                                        
+    def GetGhostBoxPos (self):
+        
+        for row in range(0, self.lvlHeight, 1):
+            for col in range(0, self.lvlWidth, 1):
+                if self.GetMapTile(row, col) == tileID[ 'ghost-door' ]:
+                    return (row, col)
+                
+        return False
+    
+    def GetPathwayPairPos (self):
+        
+        doorArray = []
+        
+        for row in range(0, self.lvlHeight, 1):
+            for col in range(0, self.lvlWidth, 1):
+                if self.GetMapTile(row, col) == tileID[ 'door-h' ]:
+                    # found a horizontal door
+                    doorArray.append( (row, col) )
+                elif self.GetMapTile(row, col) == tileID[ 'door-v' ]:
+                    # found a vertical door
+                    doorArray.append( (row, col) )
+        
+        if len(doorArray) == 0:
+            return False
+        
+        chosenDoor = random.randint(0, len(doorArray) - 1)
+        
+        if self.GetMapTile( doorArray[chosenDoor][0],doorArray[chosenDoor][1] ) == tileID[ 'door-h' ]:
+            # horizontal door was chosen
+            # look for the opposite one
+            for i in range(0, thisLevel.lvlWidth, 1):
+                if not i == doorArray[chosenDoor][1]:
+                    if thisLevel.GetMapTile(doorArray[chosenDoor][0], i) == tileID[ 'door-h' ]:
+                        return doorArray[chosenDoor], (doorArray[chosenDoor][0], i)
+        else:
+            # vertical door was chosen
+            # look for the opposite one
+            for i in range(0, thisLevel.lvlHeight, 1):
+                if not i == doorArray[chosenDoor][0]:
+                    if thisLevel.GetMapTile(i, doorArray[chosenDoor][1]) == tileID[ 'door-v' ]:
+                        return doorArray[chosenDoor], (i, doorArray[chosenDoor][1])
+                    
+        return False
+        
+    def PrintMap (self):
+        
+        for row in range(0, self.lvlHeight, 1):
+            outputLine = ""
+            for col in range(0, self.lvlWidth, 1):
+            
+                outputLine += str( self.GetMapTile(row, col) ) + ", "
+                
+            # print outputLine
+            
+    def DrawMap (self):
+        
+        self.powerPelletBlinkTimer += 1
+        if self.powerPelletBlinkTimer == 60:
+            self.powerPelletBlinkTimer = 0
+        
+        for row in range(-1, thisGame.screenTileSize[0] +1, 1):
+            outputLine = ""
+            for col in range(-1, thisGame.screenTileSize[1] +1, 1):
+
+                # row containing tile that actually goes here
+                actualRow = thisGame.screenNearestTilePos[0] + row
+                actualCol = thisGame.screenNearestTilePos[1] + col
+
+                useTile = self.GetMapTile(actualRow, actualCol)
+                if not useTile == 0 and not useTile == tileID['door-h'] and not useTile == tileID['door-v']:
+                    # if this isn't a blank tile
+
+                    if useTile == tileID['pellet-power']:
+                        if self.powerPelletBlinkTimer < 30:
+                            screen.blit (tileIDImage[ useTile ], (col * 16 - thisGame.screenPixelOffset[0], row * 16 - thisGame.screenPixelOffset[1]) )
+
+                    elif useTile == tileID['showlogo']:
+                        screen.blit (thisGame.imLogo, (col * 16 - thisGame.screenPixelOffset[0], row * 16 - thisGame.screenPixelOffset[1]) )
+                    
+                    elif useTile == tileID['hiscores']:
+                            screen.blit(thisGame.imHiscores,(col*16-thisGame.screenPixelOffset[0],row*16-thisGame.screenPixelOffset[1]))
+                    
+                    else:
+                        screen.blit (tileIDImage[ useTile ], (col * 16 - thisGame.screenPixelOffset[0], row * 16 - thisGame.screenPixelOffset[1]) )
+        
+    def LoadLevel (self, levelNum):
+        
+        self.map = {}
+        
+        self.pellets = 0
+        
+        f = open(os.path.join(SCRIPT_PATH,"res","levels",str(levelNum) + ".txt"), 'r')
+        # ANDY -- edit this
+        #fileOutput = f.read()
+        #str_splitByLine = fileOutput.split('\n')
+        lineNum=-1
+        rowNum = 0
+        useLine = False
+        isReadingLevelData = False
+          
+        for line in f:
+
+          lineNum += 1
+        
+            # print " ------- Level Line " + str(lineNum) + " -------- "
+          while len(line)>0 and (line[-1]=="\n" or line[-1]=="\r"): line=line[:-1]
+          while len(line)>0 and (line[0]=="\n" or line[0]=="\r"): line=line[1:]
+          str_splitBySpace = line.split(' ')
+            
+            
+          j = str_splitBySpace[0]
+                
+          if (j == "'" or j == ""):
+                # comment / whitespace line
+                # print " ignoring comment line.. "
+                useLine = False
+          elif j == "#":
+                # special divider / attribute line
+                useLine = False
+                
+                firstWord = str_splitBySpace[1]
+                
+                if firstWord == "lvlwidth":
+                    self.lvlWidth = int( str_splitBySpace[2] )
+                    # print "Width is " + str( self.lvlWidth )
+                    
+                elif firstWord == "lvlheight":
+                    self.lvlHeight = int( str_splitBySpace[2] )
+                    # print "Height is " + str( self.lvlHeight )
+                    
+                elif firstWord == "edgecolor":
+                    # edge color keyword for backwards compatibility (single edge color) mazes
+                    red = int( str_splitBySpace[2] )
+                    green = int( str_splitBySpace[3] )
+                    blue = int( str_splitBySpace[4] )
+                    self.edgeLightColor = (red, green, blue, 255)
+                    self.edgeShadowColor = (red, green, blue, 255)
+                    
+                elif firstWord == "edgelightcolor":
+                    red = int( str_splitBySpace[2] )
+                    green = int( str_splitBySpace[3] )
+                    blue = int( str_splitBySpace[4] )
+                    self.edgeLightColor = (red, green, blue, 255)
+                    
+                elif firstWord == "edgeshadowcolor":
+                    red = int( str_splitBySpace[2] )
+                    green = int( str_splitBySpace[3] )
+                    blue = int( str_splitBySpace[4] )
+                    self.edgeShadowColor = (red, green, blue, 255)
+                
+                elif firstWord == "fillcolor":
+                    red = int( str_splitBySpace[2] )
+                    green = int( str_splitBySpace[3] )
+                    blue = int( str_splitBySpace[4] )
+                    self.fillColor = (red, green, blue, 255)
+                    
+                elif firstWord == "pelletcolor":
+                    red = int( str_splitBySpace[2] )
+                    green = int( str_splitBySpace[3] )
+                    blue = int( str_splitBySpace[4] )
+                    self.pelletColor = (red, green, blue, 255)
+                    
+                elif firstWord == "fruittype":
+                    thisFruit.fruitType = int( str_splitBySpace[2] )
+                    
+                elif firstWord == "startleveldata":
+                    isReadingLevelData = True
+                        # print "Level data has begun"
+                    rowNum = 0
+                    
+                elif firstWord == "endleveldata":
+                    isReadingLevelData = False
+                    # print "Level data has ended"
+                    
+          else:
+                useLine = True
+                
+                
+            # this is a map data line   
+          if useLine == True:
+                
+                if isReadingLevelData == True:
+                        
+                    # print str( len(str_splitBySpace) ) + " tiles in this column"
+                    
+                    for k in range(0, self.lvlWidth, 1):
+                        self.SetMapTile(rowNum, k, int(str_splitBySpace[k]) )
+                        
+                        thisID = int(str_splitBySpace[k])
+                        if thisID == 4: 
+                            # starting position for pac-man
+                            
+                            player.homeX = k * 16
+                            player.homeY = rowNum * 16
+                            self.SetMapTile(rowNum, k, 0 )
+                            
+                        elif thisID >= 10 and thisID <= 13:
+                            # one of the ghosts
+                            
+                            ghosts[thisID - 10].homeX = k * 16
+                            ghosts[thisID - 10].homeY = rowNum * 16
+                            self.SetMapTile(rowNum, k, 0 )
+                        
+                        elif thisID == 2:
+                            # pellet
+                            
+                            self.pellets += 1
+                            
+                    rowNum += 1
+                    
+                
+        # reload all tiles and set appropriate colors
+        GetCrossRef()
+
+        # load map into the pathfinder object
+        path.ResizeMap( self.lvlHeight, self.lvlWidth )
+        
+        for row in range(0, path.size[0], 1):
+            for col in range(0, path.size[1], 1):
+                if self.IsWall( row, col ):
+                    path.SetType( row, col, 1 )
+                else:
+                    path.SetType( row, col, 0 )
+        
+        # do all the level-starting stuff
+        self.Restart()
+        
+    def Restart (self):
+        
+        for i in range(0, 4, 1):
+            # move ghosts back to home
+
+            ghosts[i].x = ghosts[i].homeX
+            ghosts[i].y = ghosts[i].homeY
+            ghosts[i].velX = 0
+            ghosts[i].velY = 0
+            ghosts[i].state = 1
+            ghosts[i].speed = 1
+            ghosts[i].Move()
+            
+            # give each ghost a path to a random spot (containing a pellet)
+            (randRow, randCol) = (0, 0)
+
+            while not self.GetMapTile(randRow, randCol) == tileID[ 'pellet' ] or (randRow, randCol) == (0, 0):
+                randRow = random.randint(1, self.lvlHeight - 2)
+                randCol = random.randint(1, self.lvlWidth - 2)
+            
+            # print "Ghost " + str(i) + " headed towards " + str((randRow, randCol))
+            ghosts[i].currentPath = path.FindPath( (ghosts[i].nearestRow, ghosts[i].nearestCol), (randRow, randCol) )
+            ghosts[i].FollowNextPathWay()
+            
+        thisFruit.active = False
+            
+        thisGame.fruitTimer = 0
+
+        player.x = player.homeX
+        player.y = player.homeY
+        player.velX = 0
+        player.velY = 0
+        
+        player.anim_pacmanCurrent = player.anim_pacmanS
+        player.animFrame = 3
+
+
+def CheckIfCloseButton(events):
+    for event in events: 
+        if event.type == pygame.QUIT: 
+            sys.exit(0)
+
+
+def CheckInputs(): 
+    
+    if thisGame.mode == 1:
+        if pygame.key.get_pressed()[ pygame.K_RIGHT ] or (js!=None and js.get_axis(JS_XAXIS)>0):
+            if not thisLevel.CheckIfHitWall(player.x + player.speed, player.y, player.nearestRow, player.nearestCol): 
+                player.velX = player.speed
+                player.velY = 0
+                
+        elif pygame.key.get_pressed()[ pygame.K_LEFT ] or (js!=None and js.get_axis(JS_XAXIS)<0):
+            if not thisLevel.CheckIfHitWall(player.x - player.speed, player.y, player.nearestRow, player.nearestCol): 
+                player.velX = -player.speed
+                player.velY = 0
+            
+        elif pygame.key.get_pressed()[ pygame.K_DOWN ] or (js!=None and js.get_axis(JS_YAXIS)>0):
+            if not thisLevel.CheckIfHitWall(player.x, player.y + player.speed, player.nearestRow, player.nearestCol): 
+                player.velX = 0
+                player.velY = player.speed
+            
+        elif pygame.key.get_pressed()[ pygame.K_UP ] or (js!=None and js.get_axis(JS_YAXIS)<0):
+            if not thisLevel.CheckIfHitWall(player.x, player.y - player.speed, player.nearestRow, player.nearestCol):
+                player.velX = 0
+                player.velY = -player.speed
+                
+    if pygame.key.get_pressed()[ pygame.K_ESCAPE ]:
+        sys.exit(0)
+            
+    elif thisGame.mode == 3:
+        if pygame.key.get_pressed()[ pygame.K_RETURN ] or (js!=None and js.get_button(JS_STARTBUTTON)):
+            thisGame.StartNewGame()
+            
+
+    
+#      _____________________________________________
+# ___/  function: Get ID-Tilename Cross References  \______________________________________ 
+    
+def GetCrossRef ():
+
+    f = open(os.path.join(SCRIPT_PATH,"res","crossref.txt"), 'r')
+    # ANDY -- edit
+    #fileOutput = f.read()
+    #str_splitByLine = fileOutput.split('\n')
+
+    lineNum = 0
+    useLine = False
+
+    for i in f.readlines():
+        # print " ========= Line " + str(lineNum) + " ============ "
+        while len(i)>0 and (i[-1]=='\n' or i[-1]=='\r'): i=i[:-1]
+        while len(i)>0 and (i[0]=='\n' or i[0]=='\r'): i=i[1:]
+        str_splitBySpace = i.split(' ')
+        
+        j = str_splitBySpace[0]
+            
+        if (j == "'" or j == "" or j == "#"):
+            # comment / whitespace line
+            # print " ignoring comment line.. "
+            useLine = False
+        else:
+            # print str(wordNum) + ". " + j
+            useLine = True
+        
+        if useLine == True:
+            tileIDName[ int(str_splitBySpace[0]) ] = str_splitBySpace[1]
+            tileID[ str_splitBySpace[1] ] = int(str_splitBySpace[0])
+            
+            thisID = int(str_splitBySpace[0])
+            if not thisID in NO_GIF_TILES:
+                tileIDImage[ thisID ] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","tiles",str_splitBySpace[1] + ".gif")).convert()
+            else:
+                    tileIDImage[ thisID ] = pygame.Surface((16,16))
+            
+            # change colors in tileIDImage to match maze colors
+            for y in range(0, 16, 1):
+                for x in range(0, 16, 1):
+                
+                    if tileIDImage[ thisID ].get_at( (x, y) ) == (255, 206, 255, 255):
+                        # wall edge
+                        tileIDImage[ thisID ].set_at( (x, y), thisLevel.edgeLightColor )
+                        
+                    elif tileIDImage[ thisID ].get_at( (x, y) ) == (132, 0, 132, 255):
+                        # wall fill
+                        tileIDImage[ thisID ].set_at( (x, y), thisLevel.fillColor ) 
+                        
+                    elif tileIDImage[ thisID ].get_at( (x, y) ) == (255, 0, 255, 255):
+                        # pellet color
+                        tileIDImage[ thisID ].set_at( (x, y), thisLevel.edgeShadowColor )   
+                        
+                    elif tileIDImage[ thisID ].get_at( (x, y) ) == (128, 0, 128, 255):
+                        # pellet color
+                        tileIDImage[ thisID ].set_at( (x, y), thisLevel.pelletColor )   
+                
+            # print str_splitBySpace[0] + " is married to " + str_splitBySpace[1]
+        lineNum += 1
+
+
+#      __________________
+# ___/  main code block  \_____________________________________________________
+
+# create the pacman
+player = pacman()
+
+# create a path_finder object
+path = path_finder()
+
+# create ghost objects
+ghosts = {}
+for i in range(0, 6, 1):
+    # remember, ghost[4] is the blue, vulnerable ghost
+    ghosts[i] = ghost(i)
+    
+# create piece of fruit
+thisFruit = fruit()
+
+tileIDName = {} # gives tile name (when the ID# is known)
+tileID = {} # gives tile ID (when the name is known)
+tileIDImage = {} # gives tile image (when the ID# is known)
+
+# create game and level objects and load first level
+thisGame = game()
+thisLevel = level()
+thisLevel.LoadLevel( thisGame.GetLevelNum() )
+
+window = pygame.display.set_mode( thisGame.screenSize, pygame.DOUBLEBUF | pygame.HWSURFACE )
+
+# initialise the joystick
+if pygame.joystick.get_count()>0:
+  if JS_DEVNUM<pygame.joystick.get_count(): js=pygame.joystick.Joystick(JS_DEVNUM)
+  else: js=pygame.joystick.Joystick(0)
+  js.init()
+else: js=None
+
+while True: 
+
+    CheckIfCloseButton( pygame.event.get() )
+    
+    if thisGame.mode == 1:
+        # normal gameplay mode
+        CheckInputs()
+        
+        thisGame.modeTimer += 1
+        player.Move()
+        for i in range(0, 4, 1):
+            ghosts[i].Move()
+        thisFruit.Move()
+            
+    elif thisGame.mode == 2:
+        # waiting after getting hit by a ghost
+        thisGame.modeTimer += 1
+        
+        if thisGame.modeTimer == 90:
+            thisLevel.Restart()
+            
+            thisGame.lives -= 1
+            if thisGame.lives == -1:
+                thisGame.updatehiscores(thisGame.score)
+                thisGame.SetMode( 3 )
+                thisGame.drawmidgamehiscores()
+            else:
+                thisGame.SetMode( 4 )
+                
+    elif thisGame.mode == 3:
+        # game over
+        CheckInputs()
+            
+    elif thisGame.mode == 4:
+        # waiting to start
+        thisGame.modeTimer += 1
+        
+        if thisGame.modeTimer == 90:
+            thisGame.SetMode( 1 )
+            player.velX = player.speed
+            
+    elif thisGame.mode == 5:
+        # brief pause after munching a vulnerable ghost
+        thisGame.modeTimer += 1
+        
+        if thisGame.modeTimer == 30:
+            thisGame.SetMode( 1 )
+            
+    elif thisGame.mode == 6:
+        # pause after eating all the pellets
+        thisGame.modeTimer += 1
+        
+        if thisGame.modeTimer == 60:
+            thisGame.SetMode( 7 )
+            oldEdgeLightColor = thisLevel.edgeLightColor
+            oldEdgeShadowColor = thisLevel.edgeShadowColor
+            oldFillColor = thisLevel.fillColor
+            
+    elif thisGame.mode == 7:
+        # flashing maze after finishing level
+        thisGame.modeTimer += 1
+        
+        whiteSet = [10, 30, 50, 70]
+        normalSet = [20, 40, 60, 80]
+        
+        if not whiteSet.count(thisGame.modeTimer) == 0:
+            # member of white set
+            thisLevel.edgeLightColor = (255, 255, 255, 255)
+            thisLevel.edgeShadowColor = (255, 255, 255, 255)
+            thisLevel.fillColor = (0, 0, 0, 255)
+            GetCrossRef()
+        elif not normalSet.count(thisGame.modeTimer) == 0:
+            # member of normal set
+            thisLevel.edgeLightColor = oldEdgeLightColor
+            thisLevel.edgeShadowColor = oldEdgeShadowColor
+            thisLevel.fillColor = oldFillColor
+            GetCrossRef()
+        elif thisGame.modeTimer == 150:
+            thisGame.SetMode ( 8 )
+            
+    elif thisGame.mode == 8:
+        # blank screen before changing levels
+        thisGame.modeTimer += 1
+        if thisGame.modeTimer == 10:
+            thisGame.SetNextLevel()
+
+    thisGame.SmartMoveScreen()
+    
+    screen.blit(img_Background, (0, 0))
+    
+    if not thisGame.mode == 8:
+        thisLevel.DrawMap()
+        
+        if thisGame.fruitScoreTimer > 0:
+            if thisGame.modeTimer % 2 == 0:
+                thisGame.DrawNumber (2500, thisFruit.x - thisGame.screenPixelPos[0] - 16, thisFruit.y - thisGame.screenPixelPos[1] + 4)
+
+        for i in range(0, 4, 1):
+            ghosts[i].Draw()
+        thisFruit.Draw()
+        player.Draw()
+        
+        if thisGame.mode == 3:
+                screen.blit(thisGame.imHiscores,(32,256))
+        
+    if thisGame.mode == 5:
+        thisGame.DrawNumber (thisGame.ghostValue / 2, player.x - thisGame.screenPixelPos[0] - 4, player.y - thisGame.screenPixelPos[1] + 6)
+    
+    
+    
+    thisGame.DrawScore()
+    
+    pygame.display.flip()
+    
+    clock.tick (60)
\ No newline at end of file
diff --git a/games/pacman/pacman_old.py b/games/pacman/pacman_old.py
new file mode 100644
index 0000000..fc711fe
--- /dev/null
+++ b/games/pacman/pacman_old.py
@@ -0,0 +1,970 @@
+import pygame
+import random
+import numpy as np
+
+class node ():
+    
+    def __init__ (self):
+        self.g = -1 # movement cost to move from previous node to this one (usually +10)
+        self.h = -1 # estimated movement cost to move from this node to the ending node (remaining horizontal and vertical steps * 10)
+        self.f = -1 # total movement cost of this node (= g + h)
+        # parent node - used to trace path back to the starting node at the end
+        self.parent = (-1, -1)
+        # node type - 0 for empty space, 1 for wall (optionally, 2 for starting node and 3 for end)
+        self.type = -1 
+
+
+class path_finder ():
+    
+    def __init__ (self):
+        # map is a 1-DIMENSIONAL array.
+        # use the Unfold( (row, col) ) function to convert a 2D coordinate pair
+        # into a 1D index to use with this array.
+        self.map = {}
+        self.size = (-1, -1) # rows by columns
+        
+        self.pathChainRev = ""
+        self.pathChain = ""
+                
+        # starting and ending nodes
+        self.start = (-1, -1)
+        self.end = (-1, -1)
+        
+        # current node (used by algorithm)
+        self.current = (-1, -1)
+        
+        # open and closed lists of nodes to consider (used by algorithm)
+        self.openList = []
+        self.closedList = []
+        
+        # used in algorithm (adjacent neighbors path finder is allowed to consider)
+        self.neighborSet = [ (0, -1), (0, 1), (-1, 0), (1, 0) ]
+        
+    def ResizeMap (self, numRows, numCols):
+        self.map = {}
+        self.size = (numRows, numCols)
+
+        # initialize path_finder map to a 2D array of empty nodes
+        for row in range(0, self.size[0], 1):
+            for col in range(0, self.size[1], 1):
+                self.Set( row, col, node() )
+                self.SetType( row, col, 0 )
+        
+    def CleanUpTemp (self):
+        
+        # this resets variables needed for a search (but preserves the same map / maze)
+    
+        self.pathChainRev = ""
+        self.pathChain = ""
+        self.current = (-1, -1)
+        self.openList = []
+        self.closedList = []
+        
+    def FindPath (self, startPos, endPos ):
+        
+        self.CleanUpTemp()
+        
+        # (row, col) tuples
+        self.start = startPos
+        self.end = endPos
+        
+        # add start node to open list
+        self.AddToOpenList( self.start )
+        self.SetG ( self.start, 0 )
+        self.SetH ( self.start, 0 )
+        self.SetF ( self.start, 0 )
+        
+        doContinue = True
+        
+        while (doContinue == True):
+        
+            thisLowestFNode = self.GetLowestFNode()
+
+            if not thisLowestFNode == self.end and not thisLowestFNode == False:
+                self.current = thisLowestFNode
+                self.RemoveFromOpenList( self.current )
+                self.AddToClosedList( self.current )
+                
+                for offset in self.neighborSet:
+                    thisNeighbor = (self.current[0] + offset[0], self.current[1] + offset[1])
+                    
+                    if not thisNeighbor[0] < 0 and not thisNeighbor[1] < 0 and not thisNeighbor[0] > self.size[0] - 1 and not thisNeighbor[1] > self.size[1] - 1 and not self.GetType( thisNeighbor ) == 1:
+                        cost = self.GetG( self.current ) + 10
+                        
+                        if self.IsInOpenList( thisNeighbor ) and cost < self.GetG( thisNeighbor ):
+                            self.RemoveFromOpenList( thisNeighbor )
+                            
+                        #if self.IsInClosedList( thisNeighbor ) and cost < self.GetG( thisNeighbor ):
+                        #   self.RemoveFromClosedList( thisNeighbor )
+                            
+                        if not self.IsInOpenList( thisNeighbor ) and not self.IsInClosedList( thisNeighbor ):
+                            self.AddToOpenList( thisNeighbor )
+                            self.SetG( thisNeighbor, cost )
+                            self.CalcH( thisNeighbor )
+                            self.CalcF( thisNeighbor )
+                            self.SetParent( thisNeighbor, self.current )
+            else:
+                doContinue = False
+                        
+        if thisLowestFNode == False:
+            return False
+                        
+        # reconstruct path
+        self.current = self.end
+        while not self.current == self.start:
+            # build a string representation of the path using R, L, D, U
+            if self.current[1] > self.GetParent(self.current)[1]:
+                self.pathChainRev += 'R' 
+            elif self.current[1] < self.GetParent(self.current)[1]:
+                self.pathChainRev += 'L'
+            elif self.current[0] > self.GetParent(self.current)[0]:
+                self.pathChainRev += 'D'
+            elif self.current[0] < self.GetParent(self.current)[0]:
+                self.pathChainRev += 'U'
+            self.current = self.GetParent(self.current)
+            self.SetType( self.current[0],self.current[1], 4)
+            
+        # because pathChainRev was constructed in reverse order, it needs to be reversed!
+        for i in range(len(self.pathChainRev) - 1, -1, -1):
+            self.pathChain += self.pathChainRev[i]
+        
+        # set start and ending positions for future reference
+        self.SetType( self.start[0],self.start[1], 2)
+        self.SetType( self.end[0],self.start[1], 3)
+        
+        return self.pathChain
+
+    def Unfold (self, row,col):
+        # this function converts a 2D array coordinate pair (row, col)
+        # to a 1D-array index, for the object's 1D map array.
+        return (row * self.size[1]) + col
+    
+    def Set (self, row,col, newNode):
+        # sets the value of a particular map cell (usually refers to a node object)
+        self.map[ self.Unfold(row, col) ] = newNode
+        
+    def GetType (self,val):
+        row,col = val
+        return self.map[ self.Unfold(row, col) ].type
+        
+    def SetType (self,row,col, newValue):
+        self.map[ self.Unfold(row, col) ].type = newValue
+
+    def GetF (self, val):
+        row,col = val
+        return self.map[ self.Unfold(row, col) ].f
+
+    def GetG (self, val):
+        row,col = val
+        return self.map[ self.Unfold(row, col) ].g
+    
+    def GetH (self, val):
+        row,col = val
+        return self.map[ self.Unfold(row, col) ].h
+        
+    def SetG (self, val, newValue ):
+        row,col = val
+        self.map[ self.Unfold(row, col) ].g = newValue
+
+    def SetH (self, val, newValue ):
+        row,col = val
+        self.map[ self.Unfold(row, col) ].h = newValue
+        
+    def SetF (self, val, newValue ):
+        row,col = val
+        self.map[ self.Unfold(row, col) ].f = newValue
+        
+    def CalcH (self, val):
+        row,col = val
+        self.map[ self.Unfold(row, col) ].h = abs(row - self.end[0]) + abs(col - self.end[0])
+        
+    def CalcF (self, val):
+        row,col = val
+        unfoldIndex = self.Unfold(row, col)
+        self.map[unfoldIndex].f = self.map[unfoldIndex].g + self.map[unfoldIndex].h
+    
+    def AddToOpenList (self, val):
+        row,col = val
+        self.openList.append( (row, col) )
+        
+    def RemoveFromOpenList (self, val ):
+        row,col = val
+        self.openList.remove( (row, col) )
+        
+    def IsInOpenList (self, val ):
+        row,col = val
+        if self.openList.count( (row, col) ) > 0:
+            return True
+        else:
+            return False
+        
+    def GetLowestFNode (self):
+        lowestValue = 1000 # start arbitrarily high
+        lowestPair = (-1, -1)
+        
+        for iOrderedPair in self.openList:
+            if self.GetF( iOrderedPair ) < lowestValue:
+                lowestValue = self.GetF( iOrderedPair )
+                lowestPair = iOrderedPair
+        
+        if not lowestPair == (-1, -1):
+            return lowestPair
+        else:
+            return False
+        
+    def AddToClosedList (self, val ):
+        row,col = val
+        self.closedList.append( (row, col) )
+        
+    def IsInClosedList (self, val ):
+        row,col = val
+        if self.closedList.count( (row, col) ) > 0:
+            return True
+        else:
+            return False
+
+    def SetParent (self, val, val2 ):
+        row,col = val
+        parentRow,parentCol = val2
+        self.map[ self.Unfold(row, col) ].parent = (parentRow, parentCol)
+
+    def GetParent (self, val ):
+        row,col = val
+        return self.map[ self.Unfold(row, col) ].parent
+        
+    
+        
+class Color:
+    """
+    Class to store hex values for colors/
+    """
+    def __init__(self):
+        """
+        Constructor Function
+        """
+        self.black = (0, 0, 0)
+        self.grey = (100, 100, 100)
+        self.white = (255, 255, 255)
+        self.blue = (0, 0, 255)
+        self.green = (0, 255, 0)
+        self.red = (255, 0, 0)
+        self.purple = (255, 0, 255)
+        self.yellow = (255, 255, 0)
+
+class PowerUp(pygame.sprite.Sprite):
+    def __init__(self, x, y):
+        super().__init__()
+        self.image = pygame.Surface([20, 20])
+        self.image.fill(Color().purple)  # Color indicating special power-up
+        self.rect = self.image.get_rect()
+        self.rect.x = x
+        self.rect.y = y
+        self.type = 'eat_ghosts'  # Specific type for eating ghosts
+        self.duration = 7000  # Lasts for 7 seconds
+
+    def apply_effect(self, player):
+        if self.type == 'eat_ghosts':
+            player.enable_ghost_eating(self.duration)
+
+
+class Wall(pygame.sprite.Sprite):
+    def __init__(self, x, y, width, height, color):
+        """
+        Constructor function
+        :param x:
+        :type x:
+        :param y:
+        :type y:
+        :param width:
+        :type width:
+        :param height:
+        :type height:
+        :param color:
+        :type color:
+        """
+
+        # Call the parent's constructor
+        pygame.sprite.Sprite.__init__(self)
+
+        # Make a wall, of the size specified in the parameters
+        self.image = pygame.Surface([width, height])
+        self.image.fill(color)
+
+        # Make our top-left corner the passed-in location.
+        self.rect = self.image.get_rect()
+        self.rect.top = y
+        self.rect.left = x
+
+
+class Block(pygame.sprite.Sprite):
+    """
+    This class represents the ball
+    It derives from the "Sprite" class in Pygame
+    """
+
+    def __init__(self, color, width, height):
+        """
+        Constructor. Pass in the color of the block and its x and y position
+        :param color:
+        :type color:
+        :param width:
+        :type width:
+        :param height:
+        :type height:
+        """
+
+        # Call the parent class (Sprite) constructor
+        pygame.sprite.Sprite.__init__(self)
+
+        # Create an image of the block, and fill it with a color.
+        # This could also be an image loaded from the disk.
+        self.color = Color()
+        self.image = pygame.Surface([width, height])
+        self.image.fill(self.color.white)
+        self.image.set_colorkey(self.color.white)
+        pygame.draw.ellipse(self.image, color, [0, 0, width, height])
+
+        # Fetch the rectangle object that has the dimensions of the image.
+        # Update the position of this object by setting the values
+        # of rect.x and rect.y
+        self.rect = self.image.get_rect()
+
+
+class Player(pygame.sprite.Sprite):
+    """
+    This class represents the bar at the bottom that the player controls
+    """
+
+    change_x = 0
+    change_y = 0
+
+    def __init__(self, x, y, filename):
+        """
+        Constructor function
+        :param x:
+        :type x:
+        :param y:
+        :type y:
+        :param filename:
+        :type filename:
+        """
+
+        # Call the parent's constructor
+        pygame.sprite.Sprite.__init__(self)
+
+        # Set height, width
+        self.image = pygame.image.load(filename).convert()
+
+        # Make our top-left corner the passed-in location.
+        self.rect = self.image.get_rect()
+        self.rect.top = y
+        self.rect.left = x
+        self.prev_x = x
+        self.prev_y = y
+        self.goal = None
+
+    def prev_direction(self):
+        """
+        Clear the speed of the player
+        """
+        self.prev_x = self.change_x
+        self.prev_y = self.change_y
+
+    def change_speed(self, x, y):
+        """
+        Change the speed of the player
+        :param x:
+        :type x:
+        :param y:
+        :type y:
+        """
+        self.change_x += x
+        self.change_y += y
+
+    def update(self, walls, gate):
+        """
+        Find a new position for the player
+        :param walls: 
+        :type walls: 
+        :param gate: 
+        :type gate: 
+        """
+        for event in pygame.event.get():
+            if event.type == pygame.USEREVENT + 3:  # Timer for ghost eating power-up
+                self.ghost_eating = False
+        # Get the old position, in case we need to go back to it
+        old_x = self.rect.left
+        new_x = old_x + self.change_x
+        self.rect.left = new_x
+
+        old_y = self.rect.top
+        new_y = old_y + self.change_y
+
+        x_collide = pygame.sprite.spritecollide(self, walls, False)
+        if x_collide:
+            self.rect.left = old_x
+        else:
+            self.rect.top = new_y
+            y_collide = pygame.sprite.spritecollide(self, walls, False)
+            if y_collide:
+                self.rect.top = old_y
+
+        if gate:
+            gate_hit = pygame.sprite.spritecollide(self, gate, False)
+            if gate_hit:
+                self.rect.left = old_x
+                self.rect.top = old_y 
+    
+    def enable_ghost_eating(self, duration):
+        self.ghost_eating = True
+        pygame.time.set_timer(pygame.USEREVENT + 3, duration)
+
+
+
+class Ghost(Player):
+    def __init__(self, x, y, filename):
+        """
+        Constructor Function
+        """
+        super().__init__(x, y, filename)
+        self.ghost_eating = False 
+        self.goal = None
+    """
+    Class to handle ghosts
+    """
+    def flee_or_chase(self, player):
+        """
+        Determine if the ghost should flee from or chase the player
+        :param player: the player character, Pacman
+        """
+        if player.ghost_eating:
+            self.run_away_from_pacman(player)
+        else:
+            self.chase_pacman(player)
+
+    def run_away_from_pacman(self, player):
+        """
+        Set direction away from Pacman
+        :param player: the player character, Pacman
+        """
+        pacman_x, pacman_y = player.rect.center
+        ghost_x, ghost_y = self.rect.center
+        dx, dy = pacman_x - ghost_x, pacman_y - ghost_y
+        # Ghost moves in the opposite direction of Pacman
+        self.change_x = -5 if dx > 0 else 5
+        self.change_y = -5 if dy > 0 else 5
+
+    def chase_pacman(self, player):
+        """
+        Set direction towards Pacman
+        :param player: the player character, Pacman
+        """
+        pacman_x, pacman_y = player.rect.center
+        ghost_x, ghost_y = self.rect.center
+        dx, dy = pacman_x - ghost_x, pacman_y - ghost_y
+        # Ghost reduces the distance to Pacman
+        self.change_x = 5 if dx > 0 else -5
+        self.change_y = 5 if dy > 0 else -5
+
+    def ghost_change_speed(self, direction_list, ghost, turn, steps, l):
+        """
+        Change the speed of the ghost
+        :param direction_list: 
+        :type direction_list: 
+        :param ghost: 
+        :type ghost: 
+        :param turn: 
+        :type turn: 
+        :param steps: 
+        :type steps: 
+        :param l: 
+        :type l: 
+        :return: 
+        :rtype: 
+        """
+        try:
+            z = direction_list[turn][2]
+            if steps < z:
+                self.change_x = direction_list[turn][0]
+                self.change_y = direction_list[turn][1]
+                steps += 1
+            else:
+                if turn < l:
+                    turn += 1
+                elif ghost == 'ghost_four':
+                    turn = 2
+                else:
+                    turn = 0
+                self.change_x = direction_list[turn][0]
+                self.change_y = direction_list[turn][1]
+                steps = 0
+            return [turn, steps]
+        except IndexError:
+            return [0, 0]
+
+
+class Game:
+    """
+    Class to run the game.
+    """
+
+    def __init__(self):
+        """
+        Constructor Function
+        """
+
+        # This is a list of walls. Each is in the form [x, y, width, height]
+        self.walls = [
+            [0, 0, 6, 600],
+            [0, 0, 600, 6],
+            [0, 600, 606, 6],
+            [600, 0, 6, 606],
+            [300, 0, 6, 66],
+            [60, 60, 186, 6],
+            [360, 60, 186, 6],
+            [60, 120, 66, 6],
+            [60, 120, 6, 126],
+            [180, 120, 246, 6],
+            [300, 120, 6, 66],
+            [480, 120, 66, 6],
+            [540, 120, 6, 126],
+            [120, 180, 126, 6],
+            [120, 180, 6, 126],
+            [360, 180, 126, 6],
+            [480, 180, 6, 126],
+            [180, 240, 6, 126],
+            [180, 360, 246, 6],
+            [420, 240, 6, 126],
+            [240, 240, 42, 6],
+            [324, 240, 42, 6],
+            [240, 240, 6, 66],
+            [240, 300, 126, 6],
+            [360, 240, 6, 66],
+            [0, 300, 66, 6],
+            [540, 300, 66, 6],
+            [60, 360, 66, 6],
+            [60, 360, 6, 186],
+            [480, 360, 66, 6],
+            [540, 360, 6, 186],
+            [120, 420, 366, 6],
+            [120, 420, 6, 66],
+            [480, 420, 6, 66],
+            [180, 480, 246, 6],
+            [300, 480, 6, 66],
+            [120, 540, 126, 6],
+            [360, 540, 126, 6],
+        ]
+
+        self.ghost_one_directions = [
+            [0, -30, 4],
+            [15, 0, 9],
+            [0, 15, 11],
+            [-15, 0, 23],
+            [0, 15, 7],
+            [15, 0, 3],
+            [0, -15, 3],
+            [15, 0, 19],
+            [0, 15, 3],
+            [15, 0, 3],
+            [0, 15, 3],
+            [15, 0, 3],
+            [0, -15, 15],
+            [-15, 0, 7],
+            [0, 15, 3],
+            [-15, 0, 19],
+            [0, -15, 11],
+            [15, 0, 9],
+        ]
+
+        self.ghost_two_directions = [
+            [0, -15, 4],
+            [15, 0, 9],
+            [0, 15, 11],
+            [15, 0, 3],
+            [0, 15, 7],
+            [-15, 0, 11],
+            [0, 15, 3],
+            [15, 0, 15],
+            [0, -15, 15],
+            [15, 0, 3],
+            [0, -15, 11],
+            [-15, 0, 3],
+            [0, -15, 11],
+            [-15, 0, 3],
+            [0, -15, 3],
+            [-15, 0, 7],
+            [0, -15, 3],
+            [15, 0, 15],
+            [0, 15, 15],
+            [-15, 0, 3],
+            [0, 15, 3],
+            [-15, 0, 3],
+            [0, -15, 7],
+            [-15, 0, 3],
+            [0, 15, 7],
+            [-15, 0, 11],
+            [0, -15, 7],
+            [15, 0, 5],
+        ]
+
+        self.ghost_three_directions = [
+            [30, 0, 2],
+            [0, -15, 4],
+            [15, 0, 10],
+            [0, 15, 7],
+            [15, 0, 3],
+            [0, -15, 3],
+            [15, 0, 3],
+            [0, -15, 15],
+            [-15, 0, 15],
+            [0, 15, 3],
+            [15, 0, 15],
+            [0, 15, 11],
+            [-15, 0, 3],
+            [0, -15, 7],
+            [-15, 0, 11],
+            [0, 15, 3],
+            [-15, 0, 11],
+            [0, 15, 7],
+            [-15, 0, 3],
+            [0, -15, 3],
+            [-15, 0, 3],
+            [0, -15, 15],
+            [15, 0, 15],
+            [0, 15, 3],
+            [-15, 0, 15],
+            [0, 15, 11],
+            [15, 0, 3],
+            [0, -15, 11],
+            [15, 0, 11],
+            [0, 15, 3],
+            [15, 0, 1],
+        ]
+
+        self.ghost_four_directions = [
+            [-30, 0, 2],
+            [0, -15, 4],
+            [15, 0, 5],
+            [0, 15, 7],
+            [-15, 0, 11],
+            [0, -15, 7],
+            [-15, 0, 3],
+            [0, 15, 7],
+            [-15, 0, 7],
+            [0, 15, 15],
+            [15, 0, 15],
+            [0, -15, 3],
+            [-15, 0, 11],
+            [0, -15, 7],
+            [15, 0, 3],
+            [0, -15, 11],
+            [15, 0, 9],
+        ]
+
+        self.color = Color()
+        # Call this function so the Pygame library can initialize itself
+        pygame.init()
+
+        # Create an 606x606 sized screen
+        self.screen = pygame.display.set_mode([606, 606])
+
+        # Set the title of the window
+        pygame.display.set_caption('Pacman')
+
+        # Create a surface we can draw on
+        background = pygame.Surface(self.screen.get_size())
+        background = background.convert()
+        background.fill(self.color.black)
+        self.clock = pygame.time.Clock()
+        pygame.font.init()
+        self.font = pygame.font.SysFont('arial', 30)
+        self.all_sprites_list = None
+        self.power_pellets = pygame.sprite.RenderPlain()
+    def setup_walls(self):
+        """
+        Make the walls. (x_pos, y_pos, width, height)
+        :return:
+        :rtype:
+        """
+        wall_list = pygame.sprite.RenderPlain()
+
+        # Loop through the list. Create the wall, add it to the list
+        for item in self.walls:
+            wall = Wall(item[0], item[1], item[2], item[3], self.color.grey)
+            wall_list.add(wall)
+            self.all_sprites_list.add(wall)
+
+        # return our new list
+        return wall_list
+
+    def setup_gate(self):
+        """
+        Add gates in the walls
+        :return:
+        :rtype:
+        """
+        gate = pygame.sprite.RenderPlain()
+        gate.add(Wall(282, 242, 42, 2, self.color.white))
+        self.all_sprites_list.add(gate)
+        return gate
+    def setup_power_pellets(self):
+        # Define power pellet locations and add them to the game
+        locations = [(100, 200), (500, 300), (300, 100)]  # Example locations
+        for x, y in locations:
+            pellet = PowerUp(x, y)
+            self.power_pellets.add(pellet)
+            self.all_sprites_list.add(pellet) 
+    def start_game(self):
+        """
+        start the game
+        """
+
+        pl = len(self.ghost_one_directions) - 1
+        bl = len(self.ghost_two_directions) - 1
+        il = len(self.ghost_three_directions) - 1
+        cl = len(self.ghost_four_directions) - 1
+
+        # default locations for Pacman and ghosts
+        w = 303 - 16  # Width
+        p_h = 7 * 60 + 19
+        m_h = 4 * 60 + 19
+        b_h = 3 * 60 + 19
+        i_w = 303 - 16 - 32
+        c_w = 303 + 32 - 16
+
+        self.all_sprites_list = pygame.sprite.RenderPlain()
+        block_list = pygame.sprite.RenderPlain()
+        ghost_list = pygame.sprite.RenderPlain()
+        pacman_collide = pygame.sprite.RenderPlain()
+        wall_list = self.setup_walls()
+
+        gate = self.setup_gate()
+
+        p_turn = 0
+        p_steps = 0
+
+        b_turn = 0
+        b_steps = 0
+
+        i_turn = 0
+        i_steps = 0
+
+        c_turn = 0
+        c_steps = 0
+
+        # Create the player  object
+        pacman = Player(w, p_h, 'images/pacman.png')
+        self.all_sprites_list.add(pacman)
+        pacman_collide.add(pacman)
+
+        ghost_two = Ghost(w, b_h, 'images/red.png')
+        ghost_list.add(ghost_two)
+        self.all_sprites_list.add(ghost_two)
+
+        ghost_one = Ghost(w, m_h, 'images/pink.png')
+        ghost_list.add(ghost_one)
+        self.all_sprites_list.add(ghost_one)
+
+        ghost_three = Ghost(i_w, m_h, 'images/blue.png')
+        ghost_list.add(ghost_three)
+        self.all_sprites_list.add(ghost_three)
+
+        ghost_four = Ghost(c_w, m_h, 'images/yellow.png')
+        ghost_list.add(ghost_four)
+        self.all_sprites_list.add(ghost_four)
+
+        # Draw the grid
+        for row in range(19):
+            for column in range(19):
+                if (row == 7 or row == 8) and (column == 8 or column == 9 or column == 10):
+                    continue
+                else:
+                    block = Block(self.color.yellow, 4, 4)
+
+                    # Set a random location for the block
+                    block.rect.x = 30 * column + 6 + 26
+                    block.rect.y = 30 * row + 6 + 26
+
+                    b_collide = pygame.sprite.spritecollide(block, wall_list, False)
+                    p_collide = pygame.sprite.spritecollide(block, pacman_collide, False)
+                    if b_collide:
+                        continue
+                    elif p_collide:
+                        continue
+                    else:
+                        # Add the block to the list of objects
+                        block_list.add(block)
+                        self.all_sprites_list.add(block)
+        # Randomly select four blocks
+        blocks = list(block_list)
+        selected_blocks = random.sample(blocks, 4)
+
+# Replace the selected blocks with power pellets
+        for block in selected_blocks:
+            power_pellet = PowerUp(block.rect.x, block.rect.y)  # Assuming you have a PowerPellet class
+            
+    # Add the power pellet to the game (you might need to modify this part based on your game structure)
+            self.all_sprites_list.add(power_pellet)
+        bll = len(block_list)
+        score = 0
+        done = False
+        while not done:
+            # Events
+            for event in pygame.event.get():
+                if event.type == pygame.QUIT:
+                    done = True
+
+                if event.type == pygame.KEYDOWN:
+                    if event.key == pygame.K_LEFT:
+                        pacman.change_speed(-30, 0)
+                    if event.key == pygame.K_RIGHT:
+                        pacman.change_speed(30, 0)
+                    if event.key == pygame.K_UP:
+                        pacman.change_speed(0, -30)
+                    if event.key == pygame.K_DOWN:
+                        pacman.change_speed(0, 30)
+
+                if event.type == pygame.KEYUP:
+                    if event.key == pygame.K_LEFT:
+                        pacman.change_speed(30, 0)
+                    if event.key == pygame.K_RIGHT:
+                        pacman.change_speed(-30, 0)
+                    if event.key == pygame.K_UP:
+                        pacman.change_speed(0, 30)
+                    if event.key == pygame.K_DOWN:
+                        pacman.change_speed(0, -30)
+
+            pacman.update(wall_list, gate)
+            returned = ghost_one.ghost_change_speed(self.ghost_one_directions, False, p_turn, p_steps, pl)
+            p_turn = returned[0]
+            p_steps = returned[1]
+            ghost_one.ghost_change_speed(self.ghost_one_directions, False, p_turn, p_steps, pl)
+            ghost_one.update(wall_list, False)
+
+            returned = ghost_two.ghost_change_speed(self.ghost_two_directions, False, b_turn, b_steps, bl)
+            b_turn = returned[0]
+            b_steps = returned[1]
+            ghost_two.ghost_change_speed(self.ghost_two_directions, False, b_turn, b_steps, bl)
+            ghost_two.update(wall_list, False)
+
+            returned = ghost_three.ghost_change_speed(self.ghost_three_directions, False, i_turn, i_steps, il)
+            i_turn = returned[0]
+            i_steps = returned[1]
+            ghost_three.ghost_change_speed(self.ghost_three_directions, False, i_turn, i_steps, il)
+            ghost_three.update(wall_list, False)
+
+            returned = ghost_four.ghost_change_speed(self.ghost_four_directions, 'ghost_four', c_turn, c_steps, cl)
+            c_turn = returned[0]
+            c_steps = returned[1]
+            ghost_four.ghost_change_speed(self.ghost_four_directions, 'ghost_four', c_turn, c_steps, cl)
+            ghost_four.update(wall_list, False)
+
+            # See if the pacman block has collided with anything.
+            blocks_hit_list = pygame.sprite.spritecollide(pacman, block_list, True) 
+            # check if pacman hits any power pellet
+            pellet_hit_list = pygame.sprite.spritecollide(pacman, self.power_pellets,True)
+            # if pellet is hit 
+            # Check the list of collisions.
+            if len(blocks_hit_list) > 0:
+                score += len(blocks_hit_list)
+
+            self.screen.fill(self.color.black)
+
+            wall_list.draw(self.screen)
+            gate.draw(self.screen)
+            self.all_sprites_list.draw(self.screen)
+            ghost_list.draw(self.screen)
+
+            text = self.font.render(str(score) + '/' + str(bll), True, self.color.white)
+            self.screen.blit(text, [270, 254])
+
+            if score == bll:
+                self.do_next(
+                    'Congratulations, you won!',
+                    145,
+                    block_list,
+                    ghost_list,
+                    pacman_collide,
+                    wall_list,
+                    gate,
+                )
+                return
+
+            ghost_hit_list = pygame.sprite.spritecollide(pacman, ghost_list, False)
+
+            if ghost_hit_list:
+                self.do_next(
+                    'Game Over',
+                    235,
+                    block_list,
+                    ghost_list,
+                    pacman_collide,
+                    wall_list,
+                    gate,
+                )
+                return
+
+            pygame.display.flip()
+
+            self.clock.tick(10)
+
+    def do_next(self, message, left, block_list, ghost_list, pacman_collide, wall_list, gate):
+        """
+        Go to next configuration in the game
+        :param message:
+        :type message:
+        :param left:
+        :type left:
+        :param block_list:
+        :type block_list:
+        :param ghost_list:
+        :type ghost_list:
+        :param pacman_collide:
+        :type pacman_collide:
+        :param wall_list:
+        :type wall_list:
+        :param gate:
+        :type gate:
+        """
+        while True:
+            for event in pygame.event.get():
+                if event.type == pygame.QUIT:
+                    pygame.quit()
+                    return
+                if event.type == pygame.KEYDOWN:
+                    if event.key == pygame.K_ESCAPE:
+                        pygame.quit()
+                        return
+                    if event.key == pygame.K_RETURN:
+                        del self.all_sprites_list
+                        del block_list
+                        del ghost_list
+                        del pacman_collide
+                        del wall_list
+                        del gate
+                        self.start_game()
+                        return
+
+            # Grey background
+            w_surface = pygame.Surface((400, 200))  # the size of your rect
+            w_surface.fill((255, 255, 255))  # this fills the entire surface
+            self.screen.blit(w_surface, (100, 200))  # (0,0) are the top-left coordinates
+
+            # Won or lost
+            text1 = self.font.render(message, True, self.color.black)
+            self.screen.blit(text1, [left, 233])
+
+            text2 = self.font.render('To play again, press ENTER.', True, self.color.black)
+            self.screen.blit(text2, [135, 300])
+            text3 = self.font.render('To quit, press ESCAPE.', True, self.color.black)
+            self.screen.blit(text3, [165, 340])
+
+            pygame.display.flip()
+            self.clock.tick(10)
+
+
+if __name__ == '__main__':
+    # main function
+    game = Game()
+    game.start_game()
+    pygame.quit()
\ No newline at end of file
diff --git a/games/pacman/pacman_test.py b/games/pacman/pacman_test.py
new file mode 100644
index 0000000..e43febc
--- /dev/null
+++ b/games/pacman/pacman_test.py
@@ -0,0 +1,366 @@
+#! /usr/bin/python
+
+# pacman.pyw
+# By David Reilly
+
+# Modified by Andy Sommerville, 8 October 2007:
+# - Changed hard-coded DOS paths to os.path calls
+# - Added constant SCRIPT_PATH (so you don't need to have pacman.pyw and res in your cwd, as long
+# -   as those two are in the same directory)
+# - Changed text-file reading to accomodate any known EOLn method (\n, \r, or \r\n)
+# - I (happily) don't have a Windows box to test this. Blocks marked "WIN???"
+# -   should be examined if this doesn't run in Windows
+# - Added joystick support (configure by changing JS_* constants)
+# - Added a high-score list. Depends on wx for querying the user's name
+
+import pygame, sys, os, random
+from pygame.locals import *
+from games.pacman.player import pacman
+from games.pacman.ghost import ghost
+from games.pacman.path import path_finder
+from games.pacman.level import level
+from games.pacman.game import game
+from games.pacman.fruit import fruit
+from games.pacman.config import *
+
+
+window = pygame.display.set_mode((1, 1))
+pygame.display.set_caption("Pacman")
+
+screen = pygame.display.get_surface()
+
+img_Background = pygame.image.load(os.path.join(SCRIPT_PATH,"res","backgrounds","1.gif")).convert()
+
+snd_pellet = {}
+snd_pellet[0] = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","pellet1.wav"))
+snd_pellet[1] = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","pellet2.wav"))
+snd_powerpellet = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","powerpellet.wav"))
+snd_eatgh = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","eatgh2.wav"))
+snd_fruitbounce = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","fruitbounce.wav"))
+snd_eatfruit = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","eatfruit.wav"))
+snd_extralife = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","extralife.wav"))
+
+
+
+#      ___________________
+# ___/  class definitions  \_______________________________________________
+
+def CheckIfCloseButton(events):
+    for event in events: 
+        if event.type == pygame.QUIT: 
+            sys.exit(0)
+
+
+def CheckInputs(): 
+    
+    if thisGame.mode == 1:
+        if pygame.key.get_pressed()[ pygame.K_RIGHT ] or (js!=None and js.get_axis(JS_XAXIS)>0):
+            if not thisLevel.CheckIfHitWall(player.x + player.speed, player.y, player.nearestRow, player.nearestCol): 
+                player.velX = player.speed
+                player.velY = 0
+                
+        elif pygame.key.get_pressed()[ pygame.K_LEFT ] or (js!=None and js.get_axis(JS_XAXIS)<0):
+            if not thisLevel.CheckIfHitWall(player.x - player.speed, player.y, player.nearestRow, player.nearestCol): 
+                player.velX = -player.speed
+                player.velY = 0
+            
+        elif pygame.key.get_pressed()[ pygame.K_DOWN ] or (js!=None and js.get_axis(JS_YAXIS)>0):
+            if not thisLevel.CheckIfHitWall(player.x, player.y + player.speed, player.nearestRow, player.nearestCol): 
+                player.velX = 0
+                player.velY = player.speed
+            
+        elif pygame.key.get_pressed()[ pygame.K_UP ] or (js!=None and js.get_axis(JS_YAXIS)<0):
+            if not thisLevel.CheckIfHitWall(player.x, player.y - player.speed, player.nearestRow, player.nearestCol):
+                player.velX = 0
+                player.velY = -player.speed
+                
+    if pygame.key.get_pressed()[ pygame.K_ESCAPE ]:
+        sys.exit(0)
+            
+    elif thisGame.mode == 4 :
+        if pygame.key.get_pressed()[ pygame.K_RETURN ] or (js!=None and js.get_button(JS_STARTBUTTON)):
+            thisGame.StartNewGame(thisLevel, tileID, tileIDImage, tileIDName)
+            
+    
+def GetCrossRef ():
+
+    f = open(os.path.join(SCRIPT_PATH,"res","crossref.txt"), 'r')
+    # ANDY -- edit
+    #fileOutput = f.read()
+    #str_splitByLine = fileOutput.split('\n')
+
+    lineNum = 0
+    useLine = False
+
+    for i in f.readlines():
+        # print " ========= Line " + str(lineNum) + " ============ "
+        while len(i)>0 and (i[-1]=='\n' or i[-1]=='\r'): i=i[:-1]
+        while len(i)>0 and (i[0]=='\n' or i[0]=='\r'): i=i[1:]
+        str_splitBySpace = i.split(' ')
+        
+        j = str_splitBySpace[0]
+            
+        if (j == "'" or j == "" or j == "#"):
+            # comment / whitespace line
+            # print " ignoring comment line.. "
+            useLine = False
+        else:
+            # print str(wordNum) + ". " + j
+            useLine = True
+        
+        if useLine == True:
+            tileIDName[ int(str_splitBySpace[0]) ] = str_splitBySpace[1]
+            tileID[ str_splitBySpace[1] ] = int(str_splitBySpace[0])
+            
+            thisID = int(str_splitBySpace[0])
+            if not thisID in NO_GIF_TILES:
+                tileIDImage[ thisID ] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","tiles",str_splitBySpace[1] + ".gif")).convert()
+            else:
+                    tileIDImage[ thisID ] = pygame.Surface((16,16))
+            
+            # change colors in tileIDImage to match maze colors
+            for y in range(0, 16, 1):
+                for x in range(0, 16, 1):
+                
+                    if tileIDImage[ thisID ].get_at( (x, y) ) == (255, 206, 255, 255):
+                        # wall edge
+                        tileIDImage[ thisID ].set_at( (x, y), thisLevel.edgeLightColor )
+                        
+                    elif tileIDImage[ thisID ].get_at( (x, y) ) == (132, 0, 132, 255):
+                        # wall fill
+                        tileIDImage[ thisID ].set_at( (x, y), thisLevel.fillColor ) 
+                        
+                    elif tileIDImage[ thisID ].get_at( (x, y) ) == (255, 0, 255, 255):
+                        # pellet color
+                        tileIDImage[ thisID ].set_at( (x, y), thisLevel.edgeShadowColor )   
+                        
+                    elif tileIDImage[ thisID ].get_at( (x, y) ) == (128, 0, 128, 255):
+                        # pellet color
+                        tileIDImage[ thisID ].set_at( (x, y), thisLevel.pelletColor )   
+                
+            # print str_splitBySpace[0] + " is married to " + str_splitBySpace[1]
+        lineNum += 1
+
+    
+#      _____________________________
+#      __________________
+# ___/  main code block  \_____________________________________________________
+# create a path_finder object
+
+f = open(os.path.join(SCRIPT_PATH,"res","crossref.txt"), 'r')
+# ANDY -- edit
+#fileOutput = f.read()
+#str_splitByLine = fileOutput.split('\n')
+
+lineNum = 0
+useLine = False
+
+tileIDName = {} # gives tile name (when the ID# is known)
+tileID = {} # gives tile ID (when the name is known)
+tileIDImage = {} # gives tile image (when the ID# is known)
+
+
+path = path_finder()
+
+# create pacman object
+player = pacman(path, screen)
+
+# create ghost objects
+ghosts = {}
+for i in range(0, 6, 1):
+    # remember, ghost[4] is the blue, vulnerable ghost
+    ghosts[i] = ghost(i, path, screen, player)
+    
+# create piece of fruit
+thisFruit = fruit() 
+
+
+
+
+
+# create game and level objects and load first level
+thisGame = game(thisFruit, player, screen)
+thisLevel = level( thisGame, player, ghosts, path, thisFruit, screen)
+for i in f.readlines():
+    # print " ========= Line " + str(lineNum) + " ============ "
+    while len(i)>0 and (i[-1]=='\n' or i[-1]=='\r'): i=i[:-1]
+    while len(i)>0 and (i[0]=='\n' or i[0]=='\r'): i=i[1:]
+    str_splitBySpace = i.split(' ')
+    
+    j = str_splitBySpace[0]
+        
+    if (j == "'" or j == "" or j == "#"):
+        # comment / whitespace line
+        # print " ignoring comment line.. "
+        useLine = False
+    else:
+        # print str(wordNum) + ". " + j
+        useLine = True
+    
+    if useLine == True:
+        tileIDName[ int(str_splitBySpace[0]) ] = str_splitBySpace[1]
+        tileID[ str_splitBySpace[1] ] = int(str_splitBySpace[0])
+        
+        thisID = int(str_splitBySpace[0])
+        if not thisID in NO_GIF_TILES:
+            tileIDImage[ thisID ] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","tiles",str_splitBySpace[1] + ".gif")).convert()
+        else:
+                tileIDImage[ thisID ] = pygame.Surface((16,16))
+        
+        # change colors in tileIDImage to match maze colors
+        for y in range(0, 16, 1):
+            for x in range(0, 16, 1):
+            
+                if tileIDImage[ thisID ].get_at( (x, y) ) == (255, 206, 255, 255):
+                    # wall edge
+                    tileIDImage[ thisID ].set_at( (x, y), thisLevel.edgeLightColor )
+                    
+                elif tileIDImage[ thisID ].get_at( (x, y) ) == (132, 0, 132, 255):
+                    # wall fill
+                    tileIDImage[ thisID ].set_at( (x, y), thisLevel.fillColor ) 
+                    
+                elif tileIDImage[ thisID ].get_at( (x, y) ) == (255, 0, 255, 255):
+                    # pellet color
+                    tileIDImage[ thisID ].set_at( (x, y), thisLevel.edgeShadowColor )   
+                    
+                elif tileIDImage[ thisID ].get_at( (x, y) ) == (128, 0, 128, 255):
+                    # pellet color
+                    tileIDImage[ thisID ].set_at( (x, y), thisLevel.pelletColor )   
+            
+        # print str_splitBySpace[0] + " is married to " + str_splitBySpace[1]
+    lineNum += 1
+thisLevel.LoadLevel( thisGame.GetLevelNum(), tileID, tileIDImage, tileIDName )
+thisGame.StartNewGame( thisLevel, tileID, tileIDImage, tileIDName )
+
+window = pygame.display.set_mode( thisGame.screenSize, pygame.DOUBLEBUF | pygame.HWSURFACE )
+
+# initialise the joystick
+if pygame.joystick.get_count()>0:
+  if JS_DEVNUM<pygame.joystick.get_count(): js=pygame.joystick.Joystick(JS_DEVNUM)
+  else: js=pygame.joystick.Joystick(0)
+  js.init()
+else: js=None   
+
+while True: 
+
+    CheckIfCloseButton( pygame.event.get() )
+    
+    if thisGame.mode == 1:
+        # normal gameplay mode
+        CheckInputs()
+        
+        thisGame.modeTimer += 1
+        player.Move(thisGame, thisLevel, ghosts, thisFruit, tileID)
+        
+        for i in range(0, 4, 1):
+            ghosts[i].Move(thisLevel, tileID)
+        thisFruit.Move(thisGame)
+            
+    elif thisGame.mode == 2:
+        # waiting after getting hit by a ghost
+        thisGame.modeTimer += 1
+        
+        if thisGame.modeTimer == 90:
+            # close the game
+            #pygame.quit()
+            thisLevel.Restart(tileID)
+            
+            thisGame.lives -= 1
+            if thisGame.lives == -1:
+                thisGame.updatehiscores(thisGame.score)
+                thisGame.SetMode( 3 )
+                thisGame.drawmidgamehiscores()
+            else:
+                thisGame.SetMode( 4 )
+                
+    elif thisGame.mode == 3:
+        # game over
+        print("Game Over")
+        running = False
+        #pygame.quit()
+        CheckInputs()
+            
+    elif thisGame.mode == 4:
+        # waiting to start
+        print("Waiting to start")
+        thisGame.modeTimer += 1
+        
+        if thisGame.modeTimer == 90:
+            thisGame.SetMode( 1 )
+            player.velX = player.speed
+            
+    elif thisGame.mode == 5:
+        # brief pause after munching a vulnerable ghost
+        thisGame.modeTimer += 1
+        
+        if thisGame.modeTimer == 30:
+            thisGame.SetMode( 1 )
+            
+    elif thisGame.mode == 6:
+        # pause after eating all the pellets
+        thisGame.modeTimer += 1
+        
+        if thisGame.modeTimer == 60:
+            thisGame.SetMode( 7 )
+            oldEdgeLightColor = thisLevel.edgeLightColor
+            oldEdgeShadowColor = thisLevel.edgeShadowColor
+            oldFillColor = thisLevel.fillColor
+            
+    elif thisGame.mode == 7:
+        # flashing maze after finishing level
+        thisGame.modeTimer += 1
+        
+        whiteSet = [10, 30, 50, 70]
+        normalSet = [20, 40, 60, 80]
+        
+        if not whiteSet.count(thisGame.modeTimer) == 0:
+            # member of white set
+            thisLevel.edgeLightColor = (255, 255, 255, 255)
+            thisLevel.edgeShadowColor = (255, 255, 255, 255)
+            thisLevel.fillColor = (0, 0, 0, 255)
+            GetCrossRef()
+        elif not normalSet.count(thisGame.modeTimer) == 0:
+            # member of normal set
+            thisLevel.edgeLightColor = oldEdgeLightColor
+            thisLevel.edgeShadowColor = oldEdgeShadowColor
+            thisLevel.fillColor = oldFillColor
+            GetCrossRef()
+        elif thisGame.modeTimer == 150:
+            thisGame.SetMode ( 8 )
+            
+    elif thisGame.mode == 8:
+        # blank screen before changing levels
+        thisGame.modeTimer += 1
+        if thisGame.modeTimer == 10:
+            thisGame.SetNextLevel()
+
+    thisGame.SmartMoveScreen(thisLevel)
+    
+    screen.blit(img_Background, (0, 0))
+    
+    if not thisGame.mode == 8:
+        thisLevel.DrawMap(tileID, tileIDImage)
+        
+        if thisGame.fruitScoreTimer > 0:
+            if thisGame.modeTimer % 2 == 0:
+                thisGame.DrawNumber (2500, thisFruit.x - thisGame.screenPixelPos[0] - 16, thisFruit.y - thisGame.screenPixelPos[1] + 4)
+
+        for i in range(0, 4, 1):
+            ghosts[i].Draw(thisGame, tileID, tileIDImage, ghosts)
+        thisFruit.Draw(thisGame)
+        player.Draw(thisGame)
+        
+        if thisGame.mode == 3:
+                screen.blit(thisGame.imHiscores,(32,256))
+        
+    if thisGame.mode == 5:
+        thisGame.DrawNumber (thisGame.ghostValue / 2, player.x - thisGame.screenPixelPos[0] - 4, player.y - thisGame.screenPixelPos[1] + 6)
+    
+    
+    
+    thisGame.DrawScore()
+    
+    pygame.display.flip()
+    
+    clock.tick (60)
+
diff --git a/games/pacman/path.py b/games/pacman/path.py
new file mode 100644
index 0000000..bd3d8a6
--- /dev/null
+++ b/games/pacman/path.py
@@ -0,0 +1,238 @@
+from games.pacman.config import *
+
+class node ():
+    
+    def __init__ (self):
+        self.g = -1 # movement cost to move from previous node to this one (usually +10)
+        self.h = -1 # estimated movement cost to move from this node to the ending node (remaining horizontal and vertical steps * 10)
+        self.f = -1 # total movement cost of this node (= g + h)
+        # parent node - used to trace path back to the starting node at the end
+        self.parent = (-1, -1)
+        # node type - 0 for empty space, 1 for wall (optionally, 2 for starting node and 3 for end)
+        self.type = -1
+        
+class path_finder ():
+    
+    def __init__ (self,):
+        # map is a 1-DIMENSIONAL array.
+        # use the Unfold( (row, col) ) function to convert a 2D coordinate pair
+        # into a 1D index to use with this array.
+        self.map = {}
+        self.size = (-1, -1) # rows by columns
+        
+        self.pathChainRev = ""
+        self.pathChain = ""
+                
+        # starting and ending nodes
+        self.start = (-1, -1)
+        self.end = (-1, -1)
+        
+        # current node (used by algorithm)
+        self.current = (-1, -1)
+        
+        # open and closed lists of nodes to consider (used by algorithm)
+        self.openList = []
+        self.closedList = []
+        
+        # used in algorithm (adjacent neighbors path finder is allowed to consider)
+        self.neighborSet = [ (0, -1), (0, 1), (-1, 0), (1, 0) ]
+        
+    def ResizeMap (self, numRows, numCols):
+        self.map = {}
+        self.size = (numRows, numCols)
+
+        # initialize path_finder map to a 2D array of empty nodes
+        for row in range(0, self.size[0], 1):
+            for col in range(0, self.size[1], 1):
+                self.Set( row, col, node() )
+                self.SetType( row, col, 0 )
+        
+    def CleanUpTemp (self):
+        
+        # this resets variables needed for a search (but preserves the same map / maze)
+    
+        self.pathChainRev = ""
+        self.pathChain = ""
+        self.current = (-1, -1)
+        self.openList = []
+        self.closedList = []
+        
+    def FindPath (self, startPos, endPos ):
+        
+        self.CleanUpTemp()
+        
+        # (row, col) tuples
+        self.start = startPos
+        self.end = endPos
+        
+        # add start node to open list
+        self.AddToOpenList( self.start )
+        self.SetG ( self.start, 0 )
+        self.SetH ( self.start, 0 )
+        self.SetF ( self.start, 0 )
+        
+        doContinue = True
+        
+        while (doContinue == True):
+        
+            thisLowestFNode = self.GetLowestFNode()
+
+            if not thisLowestFNode == self.end and not thisLowestFNode == False:
+                self.current = thisLowestFNode
+                self.RemoveFromOpenList( self.current )
+                self.AddToClosedList( self.current )
+                
+                for offset in self.neighborSet:
+                    thisNeighbor = (self.current[0] + offset[0], self.current[1] + offset[1])
+                    
+                    if not thisNeighbor[0] < 0 and not thisNeighbor[1] < 0 and not thisNeighbor[0] > self.size[0] - 1 and not thisNeighbor[1] > self.size[1] - 1 and not self.GetType( thisNeighbor ) == 1:
+                        cost = self.GetG( self.current ) + 10
+                        
+                        if self.IsInOpenList( thisNeighbor ) and cost < self.GetG( thisNeighbor ):
+                            self.RemoveFromOpenList( thisNeighbor )
+                            
+                        #if self.IsInClosedList( thisNeighbor ) and cost < self.GetG( thisNeighbor ):
+                        #   self.RemoveFromClosedList( thisNeighbor )
+                            
+                        if not self.IsInOpenList( thisNeighbor ) and not self.IsInClosedList( thisNeighbor ):
+                            self.AddToOpenList( thisNeighbor )
+                            self.SetG( thisNeighbor, cost )
+                            self.CalcH( thisNeighbor )
+                            self.CalcF( thisNeighbor )
+                            self.SetParent( thisNeighbor, self.current )
+            else:
+                doContinue = False
+                        
+        if thisLowestFNode == False:
+            return False
+                        
+        # reconstruct path
+        self.current = self.end
+        while not self.current == self.start:
+            # build a string representation of the path using R, L, D, U
+            if self.current[1] > self.GetParent(self.current)[1]:
+                self.pathChainRev += 'R' 
+            elif self.current[1] < self.GetParent(self.current)[1]:
+                self.pathChainRev += 'L'
+            elif self.current[0] > self.GetParent(self.current)[0]:
+                self.pathChainRev += 'D'
+            elif self.current[0] < self.GetParent(self.current)[0]:
+                self.pathChainRev += 'U'
+            self.current = self.GetParent(self.current)
+            self.SetType( self.current[0],self.current[1], 4)
+            
+        # because pathChainRev was constructed in reverse order, it needs to be reversed!
+        for i in range(len(self.pathChainRev) - 1, -1, -1):
+            self.pathChain += self.pathChainRev[i]
+        
+        # set start and ending positions for future reference
+        self.SetType( self.start[0],self.start[1], 2)
+        self.SetType( self.end[0],self.start[1], 3)
+        
+        return self.pathChain
+
+    def Unfold (self, row,col):
+        # this function converts a 2D array coordinate pair (row, col)
+        # to a 1D-array index, for the object's 1D map array.
+        return (row * self.size[1]) + col
+    
+    def Set (self, row,col, newNode):
+        # sets the value of a particular map cell (usually refers to a node object)
+        self.map[ self.Unfold(row, col) ] = newNode
+        
+    def GetType (self,val):
+        row,col = val
+        return self.map[ self.Unfold(row, col) ].type
+        
+    def SetType (self,row,col, newValue):
+        self.map[ self.Unfold(row, col) ].type = newValue
+
+    def GetF (self, val):
+        row,col = val
+        return self.map[ self.Unfold(row, col) ].f
+
+    def GetG (self, val):
+        row,col = val
+        return self.map[ self.Unfold(row, col) ].g
+    
+    def GetH (self, val):
+        row,col = val
+        return self.map[ self.Unfold(row, col) ].h
+        
+    def SetG (self, val, newValue ):
+        row,col = val
+        self.map[ self.Unfold(row, col) ].g = newValue
+
+    def SetH (self, val, newValue ):
+        row,col = val
+        self.map[ self.Unfold(row, col) ].h = newValue
+        
+    def SetF (self, val, newValue ):
+        row,col = val
+        self.map[ self.Unfold(row, col) ].f = newValue
+        
+    def CalcH (self, val):
+        row,col = val
+        self.map[ self.Unfold(row, col) ].h = abs(row - self.end[0]) + abs(col - self.end[0])
+        
+    def CalcF (self, val):
+        row,col = val
+        unfoldIndex = self.Unfold(row, col)
+        self.map[unfoldIndex].f = self.map[unfoldIndex].g + self.map[unfoldIndex].h
+    
+    def AddToOpenList (self, val):
+        row,col = val
+        self.openList.append( (row, col) )
+        
+    def RemoveFromOpenList (self, val ):
+        row,col = val
+        self.openList.remove( (row, col) )
+        
+    def IsInOpenList (self, val ):
+        row,col = val
+        if self.openList.count( (row, col) ) > 0:
+            return True
+        else:
+            return False
+        
+    def GetLowestFNode (self):
+        lowestValue = 1000 # start arbitrarily high
+        lowestPair = (-1, -1)
+        
+        for iOrderedPair in self.openList:
+            if self.GetF( iOrderedPair ) < lowestValue:
+                lowestValue = self.GetF( iOrderedPair )
+                lowestPair = iOrderedPair
+        
+        if not lowestPair == (-1, -1):
+            return lowestPair
+        else:
+            return False
+        
+    def AddToClosedList (self, val ):
+        row,col = val
+        self.closedList.append( (row, col) )
+        
+    def IsInClosedList (self, val ):
+        row,col = val
+        if self.closedList.count( (row, col) ) > 0:
+            return True
+        else:
+            return False
+
+    def SetParent (self, val, val2 ):
+        row,col = val
+        parentRow,parentCol = val2
+        self.map[ self.Unfold(row, col) ].parent = (parentRow, parentCol)
+
+    def GetParent (self, val ):
+        row,col = val
+        return self.map[ self.Unfold(row, col) ].parent
+        
+    # def draw (self):
+    #     for row in range(0, self.size[0], 1):
+    #         for col in range(0, self.size[1], 1):
+            
+    #             thisTile = self.GetType((row, col))
+    #             screen.blit (self.tileIDImage[ thisTile ], (col * 32, row * 32))
+        
\ No newline at end of file
diff --git a/games/pacman/player.py b/games/pacman/player.py
new file mode 100644
index 0000000..3c70e05
--- /dev/null
+++ b/games/pacman/player.py
@@ -0,0 +1,154 @@
+import pygame 
+import os
+from games.pacman.config import SCRIPT_PATH
+class pacman ():
+    
+    def __init__ (self, path, screen):
+        self.screen = screen
+        self.path = path
+        self.x = 0
+        self.y = 0
+        self.velX = 0
+        self.velY = 0
+        self.speed = 2
+        
+        self.nearestRow = 0
+        self.nearestCol = 0
+        
+        self.homeX = 0
+        self.homeY = 0
+        
+        self.anim_pacmanL = {}
+        self.anim_pacmanR = {}
+        self.anim_pacmanU = {}
+        self.anim_pacmanD = {}
+        self.anim_pacmanS = {}
+        self.anim_pacmanCurrent = {}
+        
+        for i in range(1, 9, 1):
+            self.anim_pacmanL[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","pacman-l " + str(i) + ".gif")).convert()
+            self.anim_pacmanR[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","pacman-r " + str(i) + ".gif")).convert()
+            self.anim_pacmanU[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","pacman-u " + str(i) + ".gif")).convert()
+            self.anim_pacmanD[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","pacman-d " + str(i) + ".gif")).convert()
+            self.anim_pacmanS[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","pacman.gif")).convert()
+
+        self.pelletSndNum = 0
+        
+    def Move (self, thisGame, thisLevel, ghosts, thisFruit, tileID):   
+        
+        self.nearestRow = int(((self.y + 8) / 16))
+        self.nearestCol = int(((self.x + 8) / 16))
+
+        # make sure the current velocity will not cause a collision before moving
+        if not thisLevel.CheckIfHitWall(self.x + self.velX, self.y + self.velY, self.nearestRow, self.nearestCol):
+            # it's ok to Move
+            self.x += self.velX
+            self.y += self.velY
+            # check for collisions with other tiles (pellets, etc)
+            thisLevel.CheckIfHitSomething(self.x, self.y, self.nearestRow, self.nearestCol, tileID)
+            
+            # check for collisions with the ghosts
+            for i in range(0, 4, 1):
+                # print("ghosts[i].x: ", ghosts[i].x)
+                # print("ghosts[i].y: ", ghosts[i].y)
+                # print("self.x: ", self.x)
+                # print("self.y: ", self.y)
+                if thisLevel.CheckIfHit( self.x, self.y, ghosts[i].x, ghosts[i].y, 8):
+                    if ghosts[i].state == 1:
+                        # ghost is normal
+                        thisGame.SetMode( 2 )
+                        
+                    elif ghosts[i].state == 2:
+                        # ghost is vulnerable
+                        # give them glasses
+                        # make them run
+                        thisGame.AddToScore(thisGame.ghostValue)
+                        thisGame.ghostValue = thisGame.ghostValue * 2
+                        #snd_eatgh.play()
+                        
+                        ghosts[i].state = 3
+                        ghosts[i].speed = ghosts[i].speed * 4
+                        # and send them to the ghost box
+                        ghosts[i].x = ghosts[i].nearestCol * 16
+                        ghosts[i].y = ghosts[i].nearestRow * 16
+                        ghosts[i].currentPath = self.path.FindPath( (ghosts[i].nearestRow, ghosts[i].nearestCol), (thisLevel.GetGhostBoxPos(tileID)[0]+1, thisLevel.GetGhostBoxPos(tileID)[1]) )
+                        ghosts[i].FollowNextPathWay(thisLevel, tileID)
+                        
+                        # set game mode to brief pause after eating
+                        thisGame.SetMode( 5 )
+                        
+            # check for collisions with the fruit
+            if thisFruit.active == True:
+                if thisLevel.CheckIfHit( self.x, self.y, thisFruit.x, thisFruit.y, 8):
+                    thisGame.AddToScore(2500)
+                    thisFruit.active = False
+                    thisGame.fruitTimer = 0
+                    thisGame.fruitScoreTimer = 120
+                    #snd_eatfruit.play()
+        
+        else:
+            # we're going to hit a wall -- stop moving
+            self.velX = 0
+            self.velY = 0
+            
+        # deal with power-pellet ghost timer
+        if thisGame.ghostTimer > 0:
+            thisGame.ghostTimer -= 1
+            
+            if thisGame.ghostTimer == 0:
+                for i in range(0, 4, 1):
+                    if ghosts[i].state == 2:
+                        ghosts[i].state = 1
+                self.ghostValue = 0
+                
+        # deal with fruit timer
+        thisGame.fruitTimer += 1
+        if thisGame.fruitTimer == 500:
+            pathwayPair = thisLevel.GetPathwayPairPos(tileID)
+            
+            if not pathwayPair == False:
+            
+                pathwayEntrance = pathwayPair[0]
+                pathwayExit = pathwayPair[1]
+                
+                thisFruit.active = True
+                
+                thisFruit.nearestRow = pathwayEntrance[0]
+                thisFruit.nearestCol = pathwayEntrance[1]
+                
+                thisFruit.x = thisFruit.nearestCol * 16
+                thisFruit.y = thisFruit.nearestRow * 16
+                
+                thisFruit.currentPath = self.path.FindPath( (thisFruit.nearestRow, thisFruit.nearestCol), pathwayExit )
+                thisFruit.FollowNextPathWay()
+            
+        if thisGame.fruitScoreTimer > 0:
+            thisGame.fruitScoreTimer -= 1
+            
+        
+    def Draw (self, thisGame):
+        
+        if thisGame.mode == 3:
+            return False
+        
+        # set the current frame array to match the direction pacman is facing
+        if self.velX > 0:
+            self.anim_pacmanCurrent = self.anim_pacmanR
+        elif self.velX < 0:
+            self.anim_pacmanCurrent = self.anim_pacmanL
+        elif self.velY > 0:
+            self.anim_pacmanCurrent = self.anim_pacmanD
+        elif self.velY < 0:
+            self.anim_pacmanCurrent = self.anim_pacmanU
+            
+        self.screen.blit (self.anim_pacmanCurrent[ self.animFrame ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
+        
+        if thisGame.mode == 1:
+            if not self.velX == 0 or not self.velY == 0:
+                # only Move mouth when pacman is moving
+                self.animFrame += 1 
+            
+            if self.animFrame == 9:
+                # wrap to beginning
+                self.animFrame = 1
+            
\ No newline at end of file
diff --git a/games/pacman/requirements.txt b/games/pacman/requirements.txt
deleted file mode 100644
index 231dd17..0000000
--- a/games/pacman/requirements.txt
+++ /dev/null
@@ -1 +0,0 @@
-pygame
\ No newline at end of file
diff --git a/games/pacman/res/VeraMoBd.ttf b/games/pacman/res/VeraMoBd.ttf
new file mode 100644
index 0000000..9be6547
Binary files /dev/null and b/games/pacman/res/VeraMoBd.ttf differ
diff --git a/games/pacman/res/backgrounds/1.gif b/games/pacman/res/backgrounds/1.gif
new file mode 100644
index 0000000..fddeb90
Binary files /dev/null and b/games/pacman/res/backgrounds/1.gif differ
diff --git a/games/pacman/res/crossref.txt b/games/pacman/res/crossref.txt
new file mode 100644
index 0000000..bfb3780
--- /dev/null
+++ b/games/pacman/res/crossref.txt
@@ -0,0 +1,68 @@
+'    ____                  ____             ____
+'   / __/_ _____  ___ ____/ __/__________  / / /
+'  _\ \/ // / _ \/ -_) __/\ \/ __/ __/ _ \/ / / 
+' /___/\_,_/ .__/\__/_/ /___/\__/_/  \___/_/_/  
+'         /_/                  game engine
+'
+' Cross-reference for tiles and sprites.
+'
+' Syntax for each line is:
+'      [number] [tilename] [tile description]
+' Ex.  5130 wirecornerul upper-left corner of wire path
+'
+' Tile numbers may go from 1-32767. (Tile 0 is empty space.)
+' Tiles 9000-9999 are invisible during gameplay.
+'
+' Commands:
+'      # tiles              < tile declarations start here
+'      # sprites            < sprite descriptions start here
+' __________________________________________________________
+
+
+# tiles
+
+1 ghost-door wall of the ghost box
+2 pellet a normal pellet (required)
+3 pellet-power a power pellet (makes pac-man invincible)
+4 start the starting position for pac-man
+
+10 ghost-blinky blinky
+11 ghost-pinky pinky
+12 ghost-inky inky
+13 ghost-sue sue
+
+20 door-h horizontal door (flip to other side of maze)
+21 door-v vertical door (flip to other side of maze)
+22 showlogo causes the logo to be drawn
+23 hiscores generate and draw a hi-score list
+
+100 wall-straight-horiz a horizontal wall
+101 wall-straight-vert a vertical wall
+
+105 wall-corner-ll lower-left corner of a wall
+106 wall-corner-lr lower-right corner of a wall
+107 wall-corner-ul upper-left corner of a wall
+108 wall-corner-ur upper-right corner of a wall
+
+110 wall-end-b bottom end of a wall
+111 wall-end-l left end of a wall
+112 wall-end-r right end of a wall
+113 wall-end-t top end of a wall
+
+120 wall-nub a one-tile "nub" wall
+
+130 wall-t-bottom a "T"-shaped wall, bottom-orientation
+131 wall-t-left a "T"-shaped wall, left-orientation
+132 wall-t-right a "T"-shaped wall, right-orientation
+133 wall-t-top a "T"-shaped wall, top-orientation
+
+140 wall-x a four-way wall
+
+300 glasses ghost glasses
+
+500 x-paintwall use this tile to paint walls automatically
+
+
+
+# sprites
+
diff --git a/games/pacman/res/hiscore.txt b/games/pacman/res/hiscore.txt
new file mode 100644
index 0000000..48bdfbf
--- /dev/null
+++ b/games/pacman/res/hiscore.txt
@@ -0,0 +1,6 @@
+135260 David
+100000 David
+80000 Andy
+60000 Count Pacula
+40000 Cleopacra
+24790 User
diff --git a/games/pacman/res/levels/0.txt b/games/pacman/res/levels/0.txt
new file mode 100644
index 0000000..cd90d89
--- /dev/null
+++ b/games/pacman/res/levels/0.txt
@@ -0,0 +1,48 @@
+# lvlwidth 35
+# lvlheight 35
+# bgcolor 0 0 0
+# edgelightcolor 0 0 255
+# edgeshadowcolor 0 0 255
+# fillcolor 0 0 0
+# pelletcolor 255 255 255
+# fruittype 1
+
+# startleveldata
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 22 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 107 100 100 100 100 100 100 100 108 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 101 3 2 2 2 2 2 3 101 0 0 0 0 0 0 0 0 0 0 0 0 0 
+111 100 100 100 100 100 100 100 100 100 100 100 100 106 2 0 0 0 0 0 2 105 100 100 100 100 100 100 100 100 100 100 100 100 112 
+20 2 2 2 2 2 2 2 2 2 2 2 2 2 2 0 0 4 0 0 2 2 2 2 2 2 2 2 2 2 2 2 2 2 20 
+120 0 111 100 100 100 100 100 100 100 100 100 100 108 2 0 0 0 0 0 2 107 100 100 100 100 100 100 100 100 100 100 100 100 112 
+0 0 0 0 0 0 0 0 0 0 0 0 0 101 3 2 2 2 2 2 3 101 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 105 100 100 100 100 100 100 100 106 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 23 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 107 112 1 111 108 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 101 11 12 13 101 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 105 100 100 100 106 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+# endleveldata
+
+# sprites
diff --git a/games/pacman/res/levels/1.txt b/games/pacman/res/levels/1.txt
new file mode 100644
index 0000000..f6a84e6
--- /dev/null
+++ b/games/pacman/res/levels/1.txt
@@ -0,0 +1,37 @@
+# lvlwidth 21
+# lvlheight 25
+# bgcolor 0 0 0
+# edgecolor 0 0 255
+# fillcolor 0 0 0
+# pelletcolor 255 255 255
+# fruittype 1
+
+# startleveldata
+0 0 0 0 0 0 0 0 0 113 21 113 0 0 0 0 0 0 0 0 0 
+0 107 100 100 100 100 100 100 100 106 0 105 100 100 100 100 100 100 100 108 0 
+0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 
+0 101 3 120 2 113 2 111 100 108 2 107 100 112 2 113 2 120 3 101 0 
+0 101 2 2 2 101 2 2 2 101 2 101 2 2 2 101 2 2 2 101 0 
+0 101 2 111 100 106 2 113 2 110 2 110 2 113 2 105 100 112 2 101 0 
+0 101 2 2 2 2 2 101 2 2 2 2 2 101 2 2 2 2 2 101 0 
+0 101 2 120 2 111 100 130 100 112 2 111 100 130 100 112 2 120 2 101 0 
+0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 
+0 105 100 108 2 113 2 111 100 100 100 100 100 112 2 113 2 107 100 106 0 
+0 0 0 101 2 101 2 2 0 0 10 0 0 2 2 101 2 101 0 0 0 
+111 100 100 106 2 105 112 2 107 112 1 111 108 2 111 106 2 105 100 100 112 
+20 0 0 0 2 0 0 2 101 11 12 13 101 2 0 0 2 0 0 0 20 
+111 133 100 112 2 111 112 2 105 100 100 100 106 2 111 112 2 111 100 133 112 
+0 101 2 2 2 0 0 2 0 0 0 0 0 2 0 0 2 2 2 101 0 
+0 101 2 120 2 107 112 2 111 100 100 100 112 2 111 108 2 120 2 101 0 
+0 101 2 2 2 101 2 2 0 0 4 0 0 2 2 101 2 2 2 101 0 
+0 105 133 112 2 110 2 111 100 100 133 100 100 112 2 110 2 111 133 106 0 
+0 0 101 2 2 2 2 2 2 2 101 2 2 2 2 2 2 2 101 0 0 
+0 0 101 2 111 112 2 111 108 2 101 2 107 112 2 111 112 2 101 0 0 
+107 100 106 2 2 2 2 2 101 2 101 2 101 2 2 2 2 2 105 100 108 
+101 2 2 2 111 100 112 2 110 2 110 2 110 2 111 100 112 2 2 2 101 
+101 3 120 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 120 3 101 
+101 2 2 2 107 100 100 100 100 108 0 107 100 100 100 100 108 2 2 2 101 
+105 100 100 100 106 0 0 0 0 110 21 110 0 0 0 0 105 100 100 100 106 
+# endleveldata
+
+# sprites
diff --git a/games/pacman/res/levels/10.txt b/games/pacman/res/levels/10.txt
new file mode 100644
index 0000000..e254045
--- /dev/null
+++ b/games/pacman/res/levels/10.txt
@@ -0,0 +1,35 @@
+# lvlwidth 21
+# lvlheight 23
+# bgcolor 0 0 0
+# edgecolor 128 0 64
+# fillcolor 215 0 107
+# pelletcolor 0 255 0
+# fruittype 3
+
+# startleveldata
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 107 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 108 0 
+0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 
+111 106 3 120 2 111 100 108 2 111 100 112 2 107 100 112 2 120 3 105 112 
+20 0 2 2 2 2 2 101 2 2 2 2 2 101 2 2 2 2 2 0 20 
+111 100 100 112 2 120 2 110 2 113 2 113 2 110 2 120 2 111 100 100 112 
+20 0 0 0 2 2 2 2 2 101 2 101 2 2 2 2 2 0 0 0 20 
+111 108 0 120 2 113 2 111 100 106 2 105 100 112 2 113 2 120 0 107 112 
+0 101 2 2 2 101 2 0 0 0 10 0 0 0 2 101 2 2 2 101 0 
+0 101 2 111 100 130 112 2 107 112 1 111 108 2 111 130 100 112 2 101 0 
+0 101 2 2 2 2 2 2 101 11 12 13 101 2 2 2 2 2 2 101 0 
+0 101 2 111 133 100 112 2 105 100 100 100 106 2 111 100 133 112 2 101 0 
+0 101 2 2 101 2 2 2 0 0 0 0 0 2 2 2 101 2 2 101 0 
+0 131 112 2 110 2 107 100 112 0 113 0 111 100 108 2 110 2 111 132 0 
+0 101 2 2 2 2 101 2 2 2 101 2 2 2 101 2 2 2 2 101 0 
+111 106 2 120 0 111 106 2 120 2 101 2 120 2 105 112 0 120 2 105 112 
+20 0 2 2 2 2 2 2 2 2 101 2 2 2 2 2 2 2 2 0 20 
+111 100 100 112 2 111 108 2 111 100 130 100 112 2 107 112 2 111 100 100 112 
+20 0 2 2 2 2 101 2 2 2 4 2 2 2 101 2 2 2 2 0 20 
+111 108 3 111 112 2 105 100 112 2 120 2 111 100 106 2 111 112 3 107 112 
+0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 
+0 105 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 106 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+# endleveldata
+
+# sprites
diff --git a/games/pacman/res/levels/11.txt b/games/pacman/res/levels/11.txt
new file mode 100644
index 0000000..c546ac7
--- /dev/null
+++ b/games/pacman/res/levels/11.txt
@@ -0,0 +1,36 @@
+# lvlwidth 21
+# lvlheight 23
+# bgcolor 0 0 0
+# edgelightcolor 203 211 44
+# edgeshadowcolor 0 64 0
+# fillcolor 0 0 0
+# pelletcolor 255 0 0
+# fruittype 1
+
+# startleveldata
+113 21 107 100 100 100 100 100 100 100 133 100 100 100 100 100 100 100 108 21 113 
+101 0 110 0 0 2 2 2 2 2 110 2 2 2 2 2 0 0 110 0 101 
+101 0 0 0 113 2 113 2 113 2 2 2 113 2 113 2 113 0 0 0 101 
+131 100 100 100 106 3 110 2 110 2 113 2 110 2 110 3 105 100 100 100 132 
+101 2 2 2 2 2 2 2 2 2 101 2 2 2 2 2 2 2 2 2 101 
+101 2 107 100 112 2 113 0 111 100 140 100 112 0 113 2 111 100 108 2 101 
+101 2 101 2 2 2 101 0 0 0 101 0 0 0 101 2 2 2 101 2 101 
+101 2 110 2 111 100 130 100 112 0 110 0 111 100 130 100 112 2 110 2 101 
+101 2 2 2 0 0 0 0 0 0 10 0 0 0 0 0 0 2 2 2 101 
+101 2 111 100 100 100 108 0 107 112 1 111 108 0 107 100 100 100 112 2 101 
+101 2 2 2 2 2 110 0 101 11 12 13 101 0 110 2 2 2 2 2 101 
+105 100 100 100 112 2 2 2 131 100 100 100 132 2 2 2 111 100 100 100 106 
+20 0 0 0 0 0 113 2 110 0 0 0 110 2 113 0 0 0 0 0 20 
+107 100 100 100 100 100 106 2 0 0 113 0 0 2 105 100 100 100 100 100 108 
+101 2 2 2 2 2 2 2 111 100 140 100 112 2 2 2 2 2 2 2 101 
+101 2 113 2 107 100 108 0 0 0 101 0 0 0 107 100 108 2 113 2 101 
+101 2 101 2 110 0 105 100 112 0 110 0 111 100 106 0 110 2 101 2 101 
+101 2 101 2 2 2 2 2 2 2 4 2 2 2 2 2 2 2 101 2 101 
+101 2 110 2 120 2 111 100 108 2 113 2 107 100 112 2 120 2 110 2 101 
+101 2 2 2 3 2 2 2 101 2 101 2 101 2 2 2 3 2 2 2 101 
+101 0 113 2 111 100 112 2 110 2 110 2 110 2 111 100 112 2 113 0 101 
+101 0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 101 
+110 21 105 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 106 21 110 
+# endleveldata
+
+# sprites
diff --git a/games/pacman/res/levels/12.txt b/games/pacman/res/levels/12.txt
new file mode 100644
index 0000000..137aad1
--- /dev/null
+++ b/games/pacman/res/levels/12.txt
@@ -0,0 +1,40 @@
+# lvlwidth 21
+# lvlheight 27
+# bgcolor 0 0 0
+# edgelightcolor 52 61 139
+# edgeshadowcolor 35 41 95
+# fillcolor 0 0 0
+# pelletcolor 238 183 128
+# fruittype 3
+
+# startleveldata
+111 112 21 111 100 100 100 100 100 100 100 100 100 100 100 100 100 112 21 111 112 
+20 0 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 0 20 
+111 108 2 107 100 100 100 100 100 100 100 100 100 100 100 100 100 108 2 107 112 
+0 101 2 101 22 0 0 0 0 0 0 0 0 0 0 0 0 101 2 101 0 
+0 101 2 101 0 0 0 0 0 0 0 0 0 0 0 0 0 101 2 101 0 
+111 106 2 101 0 0 0 0 0 0 0 0 0 0 0 0 0 101 2 105 112 
+20 0 2 105 100 100 133 100 100 100 133 100 100 100 133 100 100 106 2 0 20 
+111 108 2 2 2 2 110 2 2 2 110 2 2 2 110 2 2 2 2 107 112 
+0 101 2 111 108 2 2 2 113 0 10 0 113 2 2 2 107 112 2 101 0 
+0 101 2 2 110 0 120 0 131 112 1 111 132 0 120 0 110 2 2 101 0 
+0 131 108 2 2 2 2 2 101 11 12 13 101 2 2 2 2 2 107 132 0 
+111 130 106 2 111 100 112 2 105 100 100 100 106 2 111 100 112 2 105 130 112 
+20 0 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 0 20 
+111 108 2 113 2 120 2 113 2 120 0 120 2 113 2 120 2 113 2 107 112 
+0 101 2 101 2 2 2 101 2 2 4 2 2 101 2 2 2 101 2 101 0 
+0 101 2 110 2 111 100 130 100 112 0 111 100 130 100 112 2 110 2 101 0 
+0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 
+111 106 2 120 3 120 2 120 2 113 2 113 2 120 2 120 3 120 2 105 112 
+20 0 2 2 2 2 2 2 2 101 2 101 2 2 2 2 2 2 2 0 20 
+111 108 2 111 100 112 2 111 100 106 2 105 100 112 2 111 100 112 2 107 112 
+0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 
+0 105 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 106 0 
+0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
+0 0 0 107 100 100 100 100 100 100 133 100 100 100 100 100 100 108 0 0 0 
+0 107 100 106 2 2 2 2 2 2 110 2 2 2 2 2 2 105 100 108 0 
+0 101 2 2 2 107 100 100 108 2 2 2 107 100 100 108 2 2 2 101 0 
+0 110 21 111 100 106 0 0 105 100 100 100 106 0 0 105 100 112 21 110 0 
+# endleveldata
+
+# sprites
diff --git a/games/pacman/res/levels/2.txt b/games/pacman/res/levels/2.txt
new file mode 100644
index 0000000..b65a9eb
--- /dev/null
+++ b/games/pacman/res/levels/2.txt
@@ -0,0 +1,35 @@
+# lvlwidth 33
+# lvlheight 23
+# bgcolor 0 0 0
+# edgecolor 85 0 170
+# fillcolor 128 0 255
+# pelletcolor 255 255 255
+# fruittype 2
+
+# startleveldata
+0 113 21 113 0 0 0 0 0 0 0 0 0 0 0 113 21 113 0 0 0 0 0 0 0 0 0 0 0 113 21 113 0 
+0 101 0 105 100 100 100 100 100 100 133 100 100 100 100 106 0 105 100 100 100 100 133 100 100 100 100 100 100 106 0 101 0 
+0 101 2 2 2 2 2 2 2 2 101 2 2 2 2 2 2 2 2 2 2 2 101 2 2 2 2 2 2 2 2 101 0 
+111 106 3 111 112 2 113 2 113 2 110 2 111 100 100 100 133 100 100 100 112 2 110 2 113 2 113 2 111 112 3 105 112 
+20 0 2 2 2 2 101 2 101 0 0 2 2 2 2 2 101 2 2 2 2 2 0 0 101 2 101 2 2 2 2 0 20 
+111 108 0 111 100 100 106 2 105 100 112 2 111 100 108 0 101 0 107 100 112 2 111 100 106 2 105 100 100 112 0 107 112 
+0 101 2 2 2 2 2 2 2 2 2 2 0 0 110 0 110 0 110 0 0 2 2 2 2 2 2 2 2 2 2 101 0 
+0 131 100 100 112 2 111 100 108 2 107 100 112 0 0 0 10 0 0 0 111 100 108 2 107 100 112 2 111 100 100 132 0 
+0 101 2 2 2 2 2 2 110 2 110 0 0 0 107 112 1 111 108 0 0 0 110 2 110 2 2 2 2 2 2 101 0 
+0 101 2 120 0 111 112 2 2 2 2 2 113 0 101 11 12 13 101 0 113 2 2 2 2 2 111 112 0 120 2 101 0 
+0 101 2 2 2 2 2 2 120 0 111 100 132 2 105 100 100 100 106 2 131 100 112 0 120 2 2 2 2 2 2 101 0 
+0 101 2 111 100 100 112 2 2 2 3 2 110 2 2 2 2 2 2 2 110 2 3 2 2 2 111 100 100 112 2 101 0 
+0 101 2 2 2 2 2 2 113 0 113 2 2 2 113 2 113 2 113 2 2 2 113 0 113 2 2 2 2 2 2 101 0 
+0 101 2 111 112 0 120 2 110 0 110 2 111 100 106 2 110 2 105 100 112 2 110 0 110 2 120 0 111 112 2 101 0 
+0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 
+0 105 100 108 2 107 112 0 111 100 100 100 112 0 111 100 133 100 112 0 111 100 100 100 112 0 111 108 2 107 100 106 0 
+0 0 0 101 2 101 2 2 2 2 2 2 2 2 2 2 101 2 2 2 2 2 2 2 2 2 2 101 2 101 0 0 0 
+111 100 100 106 2 101 2 113 2 111 133 100 100 100 108 2 110 2 107 100 100 100 133 112 2 113 2 101 2 105 100 100 112 
+20 0 0 0 2 101 2 101 2 2 101 2 2 2 101 2 2 2 101 2 2 2 101 2 2 101 2 101 2 0 0 0 20 
+111 108 0 120 3 110 2 105 112 2 110 2 113 2 110 2 120 2 110 2 113 2 110 2 111 106 2 110 3 120 0 107 112 
+0 101 0 0 2 2 2 2 2 2 2 2 101 2 2 2 2 2 2 2 101 2 2 2 2 2 2 2 2 0 0 101 0 
+0 101 0 107 100 100 100 100 100 100 100 100 130 100 100 108 0 107 100 100 130 100 100 100 100 100 100 100 100 108 0 101 0 
+0 110 21 110 0 0 0 0 0 0 0 0 0 0 0 110 21 110 0 0 0 0 0 0 0 0 0 0 0 110 21 110 0 
+# endleveldata
+
+# sprites
diff --git a/games/pacman/res/levels/3.txt b/games/pacman/res/levels/3.txt
new file mode 100644
index 0000000..e72d1c4
--- /dev/null
+++ b/games/pacman/res/levels/3.txt
@@ -0,0 +1,38 @@
+# lvlwidth 21
+# lvlheight 25
+# bgcolor 0 0 0
+# edgelightcolor 251 233 130
+# edgeshadowcolor 124 70 16
+# fillcolor 225 151 51
+# pelletcolor 255 255 255
+# fruittype 3
+
+# startleveldata
+0 0 0 0 0 0 0 0 0 113 21 113 0 0 0 0 0 0 0 0 0 
+111 100 100 100 100 100 100 108 0 101 0 101 0 107 100 100 100 100 100 100 112 
+20 0 3 2 2 2 2 101 0 101 0 101 0 101 2 2 2 2 3 0 20 
+111 108 2 107 100 108 2 101 0 101 0 101 0 101 2 107 100 108 2 107 112 
+0 101 2 101 0 101 2 105 100 106 0 105 100 106 2 101 0 101 2 101 0 
+0 101 2 101 0 101 2 2 2 2 2 2 2 2 2 101 0 101 2 101 0 
+0 101 2 101 0 131 133 133 133 133 133 133 133 133 133 132 0 101 2 101 0 
+0 101 2 131 133 140 140 130 130 130 130 130 130 130 140 140 133 132 2 101 0 
+0 101 2 105 130 130 106 2 2 2 10 2 2 2 105 130 130 106 2 101 0 
+0 101 0 2 2 0 0 2 107 112 1 111 108 2 0 0 2 2 0 101 0 
+0 105 100 108 2 107 108 2 101 11 12 13 101 2 107 108 2 107 100 106 0 
+0 0 0 101 2 105 106 2 105 100 100 100 106 2 105 106 2 101 0 0 0 
+0 0 0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 0 0 
+0 0 0 101 2 113 2 107 100 100 100 100 100 108 2 113 2 101 0 0 0 
+0 0 0 101 0 101 2 110 0 0 4 0 0 110 2 101 0 101 0 0 0 
+0 107 100 106 0 101 2 2 2 111 133 112 2 2 2 101 0 105 100 108 0 
+0 101 2 2 2 110 2 113 2 2 101 2 2 113 2 110 2 2 2 101 0 
+0 101 2 113 0 0 2 131 108 2 101 2 107 132 2 0 0 113 2 101 0 
+111 106 2 105 100 108 2 105 106 2 110 2 105 106 2 107 100 106 2 105 112 
+20 0 3 2 2 101 2 2 2 2 0 2 2 2 2 101 2 2 3 0 20 
+111 100 100 108 2 110 2 111 100 100 133 100 100 112 2 110 2 107 100 100 112 
+0 0 0 101 0 2 2 2 2 2 110 2 2 2 2 2 0 101 0 0 0 
+0 0 0 105 100 100 100 100 108 2 2 2 107 100 100 100 100 106 0 0 0 
+0 0 0 0 0 0 0 0 105 108 0 107 106 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 110 21 110 0 0 0 0 0 0 0 0 0 
+# endleveldata
+
+# sprites
diff --git a/games/pacman/res/levels/4.txt b/games/pacman/res/levels/4.txt
new file mode 100644
index 0000000..11394c2
--- /dev/null
+++ b/games/pacman/res/levels/4.txt
@@ -0,0 +1,36 @@
+# lvlwidth 21
+# lvlheight 23
+# bgcolor 0 0 0
+# edgelightcolor 128 255 0
+# edgeshadowcolor 128 255 0
+# fillcolor 0 128 0
+# pelletcolor 0 255 255
+# fruittype 4
+
+# startleveldata
+107 100 100 100 108 0 0 0 0 113 21 113 0 0 0 0 0 0 0 0 0 
+101 3 2 2 105 100 100 100 100 106 0 105 100 100 100 100 100 100 100 108 0 
+101 2 113 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 101 0 
+101 2 105 133 100 108 2 111 100 108 2 107 100 112 2 107 100 108 2 101 0 
+101 2 2 101 0 101 2 2 2 101 2 101 2 2 2 101 0 101 2 101 0 
+105 108 2 105 100 106 2 113 2 110 2 110 2 113 2 105 100 106 2 101 0 
+0 101 2 2 2 2 2 101 2 2 2 2 2 101 2 2 2 2 2 101 0 
+0 101 2 113 2 111 100 130 100 112 2 111 100 130 100 112 2 113 2 101 0 
+0 101 2 101 2 2 2 2 2 2 2 2 2 2 2 2 2 101 2 101 0 
+0 101 2 110 2 113 2 111 100 100 100 100 100 112 2 113 2 110 2 101 0 
+0 101 3 2 2 101 2 2 0 0 10 0 0 2 2 101 2 2 3 101 0 
+111 130 100 112 2 105 112 2 107 112 1 111 108 2 111 106 2 111 100 130 112 
+20 0 0 2 2 2 2 2 101 11 12 13 101 2 2 2 2 2 0 0 20 
+111 133 100 112 2 111 112 2 105 100 100 100 106 2 111 112 2 111 100 133 112 
+0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 
+0 101 2 113 0 107 112 2 111 100 100 100 112 2 111 108 0 113 2 101 0 
+0 101 2 101 0 101 2 2 0 0 4 0 0 2 2 101 0 101 2 101 0 
+0 101 2 110 0 110 2 111 100 100 133 100 100 112 2 110 0 110 2 101 0 
+0 101 2 2 2 2 2 2 2 2 101 2 2 2 2 2 2 2 2 101 0 
+0 101 2 120 2 120 2 111 112 2 110 2 111 112 2 120 2 120 2 101 0 
+0 101 3 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 101 0 
+0 105 100 100 100 100 100 100 100 108 0 107 100 100 100 100 100 100 100 106 0 
+0 0 0 0 0 0 0 0 0 110 21 110 0 0 0 0 0 0 0 0 0 
+# endleveldata
+
+# sprites
diff --git a/games/pacman/res/levels/5.txt b/games/pacman/res/levels/5.txt
new file mode 100644
index 0000000..74a735a
--- /dev/null
+++ b/games/pacman/res/levels/5.txt
@@ -0,0 +1,78 @@
+# lvlwidth 21
+# lvlheight 65
+# bgcolor 0 0 0
+# edgelightcolor 255 0 128
+# edgeshadowcolor 0 0 0
+# fillcolor 0 0 0
+# pelletcolor 0 0 255
+# fruittype 4
+
+# startleveldata
+113 21 113 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 113 21 113 
+101 0 105 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 106 0 101 
+101 0 0 0 2 2 2 2 2 0 0 0 2 2 2 2 2 0 0 0 101 
+131 100 100 112 3 120 2 113 2 111 100 112 2 113 2 120 3 111 100 100 132 
+101 2 2 2 2 2 2 101 2 2 2 2 2 101 2 2 2 2 2 2 101 
+101 2 111 108 2 111 100 140 100 112 2 111 100 140 100 112 2 107 112 2 101 
+101 2 2 101 2 2 2 101 2 2 2 2 2 101 2 2 2 101 2 2 101 
+131 112 2 101 2 113 2 110 2 111 133 112 2 110 2 113 2 101 2 111 132 
+101 2 2 101 2 101 2 2 2 2 101 2 2 2 2 101 2 101 2 2 101 
+101 2 111 132 2 105 100 100 112 2 110 2 111 100 100 106 2 131 112 2 101 
+101 2 2 101 2 2 2 2 2 2 0 2 2 2 2 2 2 101 2 2 101 
+105 108 2 110 2 113 2 120 2 111 100 112 2 120 2 113 2 110 2 107 106 
+0 101 2 2 2 101 2 2 2 2 2 2 2 2 2 101 2 2 2 101 0 
+111 130 100 112 2 105 100 100 100 108 2 107 100 100 100 106 2 111 100 130 112 
+20 0 0 0 2 2 2 2 2 101 2 101 2 2 2 2 2 0 0 0 20 
+107 100 100 100 100 100 100 112 2 110 2 110 2 111 100 100 100 100 100 100 108 
+101 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 
+101 2 107 108 3 120 0 113 0 111 133 112 0 113 0 120 3 107 108 2 101 
+101 2 131 132 2 0 0 101 0 0 101 0 0 101 0 0 2 131 132 2 101 
+101 2 131 132 2 111 100 130 112 0 101 0 111 130 100 112 2 131 132 2 101 
+101 2 131 132 2 2 2 2 2 2 101 2 2 2 2 2 2 131 132 2 101 
+101 2 131 132 2 107 112 2 113 2 110 2 113 2 111 108 2 131 132 2 101 
+101 2 131 132 2 110 2 2 101 2 2 2 101 2 2 110 2 131 132 2 101 
+101 2 131 132 2 0 2 111 132 0 120 0 131 112 2 0 2 131 132 2 101 
+101 2 131 132 2 113 2 2 101 0 0 0 101 2 2 113 2 131 132 2 101 
+101 2 131 106 2 105 112 2 110 0 113 0 110 2 111 106 2 105 132 2 101 
+110 2 101 0 2 2 2 2 2 2 101 2 2 2 2 2 2 0 101 2 110 
+20 2 101 0 111 112 2 107 112 2 101 2 111 108 2 111 112 0 101 2 20 
+113 2 101 2 2 2 2 101 2 2 101 2 2 101 2 2 2 2 101 2 113 
+101 2 101 2 113 2 111 106 2 111 130 112 2 105 112 2 113 2 101 2 101 
+101 2 101 2 101 2 2 2 2 0 0 0 2 2 2 2 101 2 101 2 101 
+101 2 101 2 105 100 100 100 112 0 113 0 111 100 100 100 106 2 101 2 101 
+101 2 101 2 2 2 2 0 0 0 101 0 0 0 2 2 2 2 101 2 101 
+101 2 101 3 111 112 2 111 100 100 130 100 100 112 2 111 112 3 101 2 101 
+101 2 101 2 2 2 2 2 0 0 10 0 0 2 2 2 2 2 101 2 101 
+101 2 131 133 133 133 108 2 107 112 1 111 108 2 107 133 133 133 132 2 101 
+101 2 105 130 130 130 106 2 101 11 12 13 101 2 105 130 130 130 106 2 101 
+101 2 2 2 2 2 2 2 105 100 100 100 106 2 2 2 2 2 2 2 101 
+131 133 133 133 133 133 108 0 0 0 0 0 0 0 107 133 133 133 133 133 132 
+131 140 140 130 130 130 130 100 100 108 2 107 100 100 130 130 130 130 140 140 132 
+105 130 132 2 2 2 2 2 2 101 2 101 2 2 2 2 2 2 131 130 106 
+20 0 110 2 107 100 100 112 2 110 2 110 2 111 100 100 108 2 110 0 20 
+113 2 2 2 101 2 2 2 2 2 2 2 2 2 2 2 101 2 2 2 113 
+101 2 111 133 132 2 111 100 100 100 133 100 100 100 112 2 131 133 112 2 101 
+101 2 2 131 132 2 2 2 2 2 101 2 2 2 2 2 131 132 2 2 101 
+131 108 2 105 106 2 113 2 113 2 101 2 113 2 113 2 105 106 2 107 132 
+131 132 2 2 2 2 101 2 110 2 110 2 110 2 101 2 2 2 2 131 132 
+131 140 133 133 108 2 101 2 0 2 2 2 0 2 101 2 107 133 133 140 132 
+131 140 140 140 132 2 101 2 107 112 2 111 108 2 101 2 131 140 140 140 132 
+131 140 140 140 106 2 110 2 110 2 4 2 110 2 110 2 105 140 140 140 132 
+105 130 130 106 2 2 2 2 2 2 113 2 2 2 2 2 2 105 130 130 106 
+20 0 0 2 2 113 2 111 100 100 140 100 100 112 2 113 2 2 0 0 20 
+113 0 113 2 107 132 2 2 2 2 110 2 2 2 2 131 108 2 113 0 113 
+101 0 101 2 131 132 3 111 112 2 0 2 111 112 3 131 132 2 101 0 101 
+101 0 101 2 105 132 2 0 0 2 113 2 0 0 2 131 106 2 101 0 101 
+101 0 101 2 2 101 2 111 112 2 101 2 111 112 2 101 2 2 101 0 101 
+101 0 131 108 2 101 2 2 2 2 101 2 2 2 2 101 2 107 132 0 101 
+101 0 131 106 2 101 2 111 100 100 130 100 100 112 2 101 2 105 132 0 101 
+101 0 101 2 2 101 2 2 2 2 2 2 2 2 2 101 2 2 101 0 101 
+101 0 101 2 107 132 2 111 100 108 2 107 100 112 2 131 108 2 101 0 101 
+101 0 101 2 131 132 2 2 2 101 2 101 2 2 2 131 132 2 101 0 101 
+101 0 101 2 105 130 100 112 2 110 2 110 2 111 100 130 106 2 101 0 101 
+101 0 101 2 2 2 2 2 2 2 3 2 2 2 2 2 2 2 101 0 101 
+101 0 131 133 133 133 133 133 133 133 133 133 133 133 133 133 133 133 132 0 101 
+110 21 105 130 130 130 130 130 130 130 130 130 130 130 130 130 130 130 106 21 110 
+# endleveldata
+
+# sprites
diff --git a/games/pacman/res/levels/6.txt b/games/pacman/res/levels/6.txt
new file mode 100644
index 0000000..fe40285
--- /dev/null
+++ b/games/pacman/res/levels/6.txt
@@ -0,0 +1,36 @@
+# lvlwidth 21
+# lvlheight 23
+# bgcolor 0 0 0
+# edgelightcolor 255 255 255
+# edgeshadowcolor 0 128 255
+# fillcolor 129 11 168
+# pelletcolor 255 255 255
+# fruittype 3
+
+# startleveldata
+107 100 100 100 133 100 100 100 100 100 100 100 100 100 100 100 133 100 100 100 108 
+101 2 2 2 101 2 2 2 2 2 2 2 2 2 2 2 101 2 2 2 101 
+101 3 120 2 110 2 113 2 111 100 100 100 112 2 113 2 110 2 120 3 101 
+101 2 2 2 2 2 101 2 2 2 2 2 2 2 101 2 2 2 2 2 101 
+131 100 112 2 120 2 105 100 100 100 133 100 100 100 106 2 120 2 111 100 132 
+101 2 2 2 0 2 2 2 2 2 101 2 2 2 2 2 0 2 2 2 101 
+101 2 111 100 112 2 107 100 112 2 110 2 111 100 108 2 111 100 112 2 101 
+101 2 0 2 2 2 110 2 2 2 2 2 2 2 110 2 2 2 0 2 101 
+105 100 108 2 120 2 0 0 111 100 100 100 112 0 0 2 120 2 107 100 106 
+0 0 101 2 2 2 113 0 0 0 10 0 0 0 113 2 2 2 101 0 0 
+0 0 105 100 108 2 101 0 107 112 1 111 108 0 101 2 107 100 106 0 0 
+0 0 0 0 101 2 101 0 101 11 12 13 101 0 101 2 101 0 0 0 0 
+111 100 100 100 106 2 110 0 105 100 100 100 106 0 110 2 105 100 100 100 112 
+20 0 0 0 0 2 2 2 2 2 4 2 2 2 2 2 0 0 0 0 20 
+111 100 100 100 108 2 113 2 111 100 100 100 112 2 113 2 107 100 100 100 112 
+0 0 0 0 101 2 101 2 2 2 0 2 2 2 101 2 101 0 0 0 0 
+0 0 107 100 106 2 131 100 112 2 113 2 111 100 132 2 105 100 108 0 0 
+0 0 101 2 2 2 101 2 2 2 101 2 2 2 101 2 2 2 101 0 0 
+107 100 106 2 120 2 101 2 111 100 130 100 112 2 101 2 120 2 105 100 108 
+101 2 2 2 2 2 101 2 2 2 2 2 2 2 101 2 2 2 2 2 101 
+101 3 120 2 113 2 105 100 112 2 120 2 111 100 106 2 113 2 120 3 101 
+101 2 2 2 101 2 2 2 2 2 2 2 2 2 2 2 101 2 2 2 101 
+105 100 100 100 130 100 100 100 100 100 100 100 100 100 100 100 130 100 100 100 106 
+# endleveldata
+
+# sprites
diff --git a/games/pacman/res/levels/7.txt b/games/pacman/res/levels/7.txt
new file mode 100644
index 0000000..a34c0a9
--- /dev/null
+++ b/games/pacman/res/levels/7.txt
@@ -0,0 +1,35 @@
+# lvlwidth 21
+# lvlheight 23
+# bgcolor 0 0 0
+# edgecolor 255 128 128
+# fillcolor 100 100 100
+# pelletcolor 170 0 85
+# fruittype 0
+
+# startleveldata
+120 21 111 100 108 0 107 100 100 100 100 100 100 100 108 0 107 100 112 21 120 
+20 2 2 2 105 100 106 2 2 2 2 2 2 2 105 100 106 2 2 2 20 
+113 3 120 2 2 2 2 2 111 100 133 100 112 2 2 2 2 2 120 3 113 
+101 2 2 2 107 100 108 2 2 2 101 2 2 2 107 100 108 2 2 2 101 
+105 100 100 100 106 0 101 2 113 2 101 2 113 2 101 0 105 100 100 100 106 
+0 0 0 0 0 0 101 2 101 2 101 2 101 2 101 0 0 0 0 0 0 
+107 100 100 100 100 100 106 2 101 2 110 2 101 2 105 100 100 100 100 100 108 
+101 2 2 2 2 2 2 2 101 2 2 2 101 2 2 2 2 2 2 2 101 
+101 2 113 2 113 2 111 100 130 112 0 111 130 100 112 2 113 2 113 2 101 
+101 2 101 2 101 2 2 2 2 2 4 2 2 2 2 2 101 2 101 2 101 
+101 2 110 2 105 100 100 112 2 113 0 113 2 111 100 100 106 2 110 2 101 
+101 2 2 2 2 2 2 2 2 101 0 101 2 2 2 2 2 2 2 2 101 
+105 100 108 2 107 112 2 107 100 106 0 105 100 108 2 111 108 2 107 100 106 
+0 0 101 2 101 2 2 101 2 2 2 2 2 101 2 2 101 2 101 0 0 
+0 0 101 2 110 2 111 106 2 111 100 112 2 105 112 2 110 2 101 0 0 
+0 0 101 2 2 2 2 2 2 0 10 0 2 2 2 2 2 2 101 0 0 
+0 0 105 100 108 2 120 2 107 112 1 111 108 2 120 2 107 100 106 0 0 
+0 0 0 0 101 2 2 2 101 11 12 13 101 2 2 2 101 0 0 0 0 
+0 0 0 0 101 2 120 2 105 100 100 100 106 2 120 2 101 0 0 0 0 
+0 0 0 0 101 2 2 2 2 2 2 2 2 2 2 2 101 0 0 0 0 
+111 100 100 100 106 0 113 2 111 100 100 100 112 2 113 0 105 100 100 100 112 
+20 0 0 0 0 0 101 2 2 2 3 2 2 2 101 0 0 0 0 0 20 
+120 21 111 100 100 100 130 100 100 100 100 100 100 100 130 100 100 100 112 21 120 
+# endleveldata
+
+# sprites
diff --git a/games/pacman/res/levels/8.txt b/games/pacman/res/levels/8.txt
new file mode 100644
index 0000000..21d3396
--- /dev/null
+++ b/games/pacman/res/levels/8.txt
@@ -0,0 +1,36 @@
+# lvlwidth 21
+# lvlheight 23
+# bgcolor 0 0 0
+# edgelightcolor 0 128 192
+# edgeshadowcolor 0 51 51
+# fillcolor 0 0 0
+# pelletcolor 255 128 0
+# fruittype 2
+
+# startleveldata
+0 0 0 0 0 0 0 0 113 21 113 21 113 0 0 0 0 0 0 0 0 
+0 0 0 107 100 100 100 100 106 0 110 0 105 100 100 100 100 108 0 0 0 
+0 0 0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 0 0 
+0 107 100 106 2 113 2 120 2 111 133 112 2 120 0 113 2 105 100 108 0 
+0 101 2 2 2 101 2 2 2 2 101 2 2 2 0 110 2 0 0 101 0 
+0 101 2 107 100 106 0 111 112 0 110 2 111 112 2 2 2 113 0 101 0 
+107 106 2 110 2 2 2 0 2 2 2 2 0 0 2 120 3 110 0 105 108 
+101 2 2 2 2 113 2 113 2 113 2 111 100 108 2 0 0 10 0 0 101 
+101 2 107 100 100 106 2 110 2 101 2 2 2 101 2 107 112 1 111 133 106 
+101 2 110 2 2 2 2 0 2 105 100 112 2 110 2 101 11 12 13 101 0 
+101 2 0 3 120 2 111 108 2 2 2 2 2 2 2 105 100 100 100 130 108 
+101 2 113 2 2 2 2 105 100 108 2 107 100 112 2 2 2 2 2 2 101 
+101 2 105 100 100 108 2 2 2 101 2 101 2 2 2 107 100 100 112 2 101 
+101 2 0 0 0 105 100 112 2 110 2 110 2 111 100 106 2 2 2 2 101 
+101 2 111 108 2 2 2 2 2 2 2 2 2 2 2 2 2 107 112 2 101 
+101 2 2 110 2 111 100 112 2 120 4 111 100 112 2 120 2 110 2 2 101 
+105 108 2 0 2 2 2 2 2 2 2 2 2 2 2 2 2 0 2 107 106 
+0 101 2 111 112 0 107 100 112 2 113 0 111 100 108 2 111 112 2 101 0 
+0 101 2 2 2 3 101 2 2 2 101 0 0 0 101 2 2 2 2 101 0 
+0 105 100 108 2 111 106 2 111 100 130 100 112 0 105 112 2 107 100 106 0 
+0 0 0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 0 0 
+0 0 0 105 100 100 100 100 108 0 113 0 107 100 100 100 100 106 0 0 0 
+0 0 0 0 0 0 0 0 110 21 110 21 110 0 0 0 0 0 0 0 0 
+# endleveldata
+
+# sprites
diff --git a/games/pacman/res/levels/9.txt b/games/pacman/res/levels/9.txt
new file mode 100644
index 0000000..3661b14
--- /dev/null
+++ b/games/pacman/res/levels/9.txt
@@ -0,0 +1,46 @@
+# lvlwidth 34
+# lvlheight 33
+# bgcolor 0 0 0
+# edgelightcolor 128 0 255
+# edgeshadowcolor 64 0 64
+# fillcolor 0 0 0
+# pelletcolor 0 255 0
+# fruittype 1
+
+# startleveldata
+0 0 0 0 0 0 0 0 0 113 21 113 0 0 0 0 0 0 0 0 0 0 113 21 113 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 101 0 101 0 0 0 0 0 0 0 0 0 0 101 0 101 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 101 0 101 0 0 0 0 0 0 0 0 0 0 101 0 101 0 0 0 0 0 0 0 0 0 
+0 0 0 107 100 100 100 100 100 106 0 105 100 100 100 100 100 100 100 100 100 100 106 0 105 100 100 100 100 100 108 0 0 0 
+0 0 0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 0 0 
+111 100 100 106 3 111 100 133 100 112 2 111 100 100 100 108 2 113 2 113 2 111 108 2 113 0 120 3 113 2 105 100 100 112 
+20 0 0 0 2 2 2 101 2 2 2 2 2 2 2 101 2 101 2 101 2 2 101 2 101 0 0 0 101 2 0 0 0 20 
+111 100 100 108 2 113 2 110 2 111 100 133 100 112 2 101 2 101 2 105 112 2 110 2 101 0 111 100 106 2 107 100 100 112 
+0 0 0 101 2 101 2 2 2 2 2 101 2 2 2 101 2 101 2 2 2 2 2 2 101 0 0 0 0 2 101 0 0 0 
+0 0 0 101 2 131 100 112 2 113 2 101 2 111 100 106 2 105 100 100 100 100 112 2 131 100 100 100 112 2 101 0 0 0 
+0 0 0 101 2 101 2 2 2 101 2 101 2 2 2 2 2 2 2 2 2 2 2 2 101 2 2 2 2 2 101 0 0 0 
+0 0 0 101 2 110 2 111 100 132 2 110 2 111 100 100 100 100 100 100 100 100 112 2 101 2 111 100 108 0 101 0 0 0 
+0 0 0 101 2 0 2 2 2 101 2 2 2 0 0 0 0 0 0 0 10 0 0 2 101 2 2 2 101 0 101 0 0 0 
+0 0 0 101 2 111 100 112 2 110 0 113 2 107 100 100 108 0 107 112 1 111 108 2 110 2 120 2 101 0 101 0 0 0 
+0 0 0 101 2 2 2 2 2 0 0 101 2 101 0 0 101 0 101 11 12 13 101 2 2 2 2 2 101 0 101 0 0 0 
+0 0 0 101 2 111 100 100 100 100 100 132 2 105 100 100 106 0 105 100 100 100 106 2 111 100 108 2 101 0 101 0 0 0 
+0 0 0 101 2 2 2 2 2 2 2 101 2 2 2 2 2 2 2 2 2 2 2 2 0 0 101 2 101 0 101 0 0 0 
+0 0 0 101 0 111 100 100 100 108 2 110 0 113 2 113 2 111 100 100 100 100 100 100 112 0 101 2 101 0 101 0 0 0 
+0 0 0 101 2 2 2 2 2 101 2 2 2 101 2 101 2 2 2 2 2 2 2 2 2 0 101 2 101 0 101 0 0 0 
+0 0 0 101 2 107 100 112 2 105 100 112 2 101 2 101 2 111 100 100 133 100 100 112 2 111 106 2 110 0 101 0 0 0 
+0 0 0 101 2 101 0 4 2 2 2 2 2 101 2 101 2 2 2 2 101 2 2 2 2 2 2 2 2 2 101 0 0 0 
+0 0 0 101 2 110 0 107 100 100 100 112 0 110 2 110 2 111 112 2 101 2 107 100 100 100 100 100 108 2 101 0 0 0 
+0 0 0 101 2 0 0 101 2 2 2 2 2 2 2 2 2 2 2 2 101 2 101 0 0 2 2 2 110 2 101 0 0 0 
+0 0 0 101 2 111 100 106 2 113 2 113 2 120 2 113 0 111 112 2 101 2 101 0 113 2 113 2 2 2 101 0 0 0 
+0 0 0 101 2 2 2 2 3 101 2 101 2 2 2 101 2 2 2 2 101 2 101 0 110 3 105 100 112 2 101 0 0 0 
+111 100 100 106 2 111 100 100 100 106 2 101 2 120 2 110 2 111 112 0 110 2 101 2 2 2 2 2 2 2 105 100 100 112 
+20 0 0 0 2 2 2 2 2 2 2 101 2 2 2 2 2 2 2 2 2 2 101 2 107 108 2 107 108 2 0 0 0 20 
+111 100 100 108 2 111 100 100 100 112 2 105 100 100 100 112 0 111 100 100 100 100 106 2 105 106 2 105 106 2 107 100 100 112 
+0 0 0 101 2 2 2 0 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 0 0 
+0 0 0 105 100 100 100 100 100 108 0 107 100 100 100 100 100 100 100 100 100 100 108 0 107 100 100 100 100 100 106 0 0 0 
+0 0 0 0 0 0 0 0 0 101 0 101 0 0 0 0 0 0 0 0 0 0 101 0 101 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 101 0 101 0 0 0 0 0 0 0 0 0 0 101 0 101 0 0 0 0 0 0 0 0 0 
+0 0 0 0 0 0 0 0 0 110 21 110 0 0 0 0 0 0 0 0 0 0 110 21 110 0 0 0 0 0 0 0 0 0 
+# endleveldata
+
+# sprites
diff --git a/games/pacman/res/sounds/eatfruit.wav b/games/pacman/res/sounds/eatfruit.wav
new file mode 100644
index 0000000..d180209
Binary files /dev/null and b/games/pacman/res/sounds/eatfruit.wav differ
diff --git a/games/pacman/res/sounds/eatgh2.wav b/games/pacman/res/sounds/eatgh2.wav
new file mode 100644
index 0000000..7d8b90e
Binary files /dev/null and b/games/pacman/res/sounds/eatgh2.wav differ
diff --git a/games/pacman/res/sounds/extralife.wav b/games/pacman/res/sounds/extralife.wav
new file mode 100644
index 0000000..2db3c19
Binary files /dev/null and b/games/pacman/res/sounds/extralife.wav differ
diff --git a/games/pacman/res/sounds/fruitbounce.wav b/games/pacman/res/sounds/fruitbounce.wav
new file mode 100644
index 0000000..6e17741
Binary files /dev/null and b/games/pacman/res/sounds/fruitbounce.wav differ
diff --git a/games/pacman/res/sounds/pellet1.wav b/games/pacman/res/sounds/pellet1.wav
new file mode 100644
index 0000000..1d39b64
Binary files /dev/null and b/games/pacman/res/sounds/pellet1.wav differ
diff --git a/games/pacman/res/sounds/pellet2.wav b/games/pacman/res/sounds/pellet2.wav
new file mode 100644
index 0000000..d8363d0
Binary files /dev/null and b/games/pacman/res/sounds/pellet2.wav differ
diff --git a/games/pacman/res/sounds/powerpellet.wav b/games/pacman/res/sounds/powerpellet.wav
new file mode 100644
index 0000000..489de59
Binary files /dev/null and b/games/pacman/res/sounds/powerpellet.wav differ
diff --git a/games/pacman/res/sprite/fruit 0.gif b/games/pacman/res/sprite/fruit 0.gif
new file mode 100644
index 0000000..8cc3dc4
Binary files /dev/null and b/games/pacman/res/sprite/fruit 0.gif differ
diff --git a/games/pacman/res/sprite/fruit 1.gif b/games/pacman/res/sprite/fruit 1.gif
new file mode 100644
index 0000000..8adcf61
Binary files /dev/null and b/games/pacman/res/sprite/fruit 1.gif differ
diff --git a/games/pacman/res/sprite/fruit 2.gif b/games/pacman/res/sprite/fruit 2.gif
new file mode 100644
index 0000000..bda9369
Binary files /dev/null and b/games/pacman/res/sprite/fruit 2.gif differ
diff --git a/games/pacman/res/sprite/fruit 3.gif b/games/pacman/res/sprite/fruit 3.gif
new file mode 100644
index 0000000..ea8f006
Binary files /dev/null and b/games/pacman/res/sprite/fruit 3.gif differ
diff --git a/games/pacman/res/sprite/fruit 4.gif b/games/pacman/res/sprite/fruit 4.gif
new file mode 100644
index 0000000..0be5f73
Binary files /dev/null and b/games/pacman/res/sprite/fruit 4.gif differ
diff --git a/games/pacman/res/sprite/ghost 1.gif b/games/pacman/res/sprite/ghost 1.gif
new file mode 100644
index 0000000..af02492
Binary files /dev/null and b/games/pacman/res/sprite/ghost 1.gif differ
diff --git a/games/pacman/res/sprite/ghost 2.gif b/games/pacman/res/sprite/ghost 2.gif
new file mode 100644
index 0000000..89845aa
Binary files /dev/null and b/games/pacman/res/sprite/ghost 2.gif differ
diff --git a/games/pacman/res/sprite/ghost 3.gif b/games/pacman/res/sprite/ghost 3.gif
new file mode 100644
index 0000000..5777f39
Binary files /dev/null and b/games/pacman/res/sprite/ghost 3.gif differ
diff --git a/games/pacman/res/sprite/ghost 4.gif b/games/pacman/res/sprite/ghost 4.gif
new file mode 100644
index 0000000..e95b7d7
Binary files /dev/null and b/games/pacman/res/sprite/ghost 4.gif differ
diff --git a/games/pacman/res/sprite/ghost 5.gif b/games/pacman/res/sprite/ghost 5.gif
new file mode 100644
index 0000000..9956c84
Binary files /dev/null and b/games/pacman/res/sprite/ghost 5.gif differ
diff --git a/games/pacman/res/sprite/ghost 6.gif b/games/pacman/res/sprite/ghost 6.gif
new file mode 100644
index 0000000..56533bf
Binary files /dev/null and b/games/pacman/res/sprite/ghost 6.gif differ
diff --git a/games/pacman/res/sprite/pacman-d 1.gif b/games/pacman/res/sprite/pacman-d 1.gif
new file mode 100644
index 0000000..b3db2db
Binary files /dev/null and b/games/pacman/res/sprite/pacman-d 1.gif differ
diff --git a/games/pacman/res/sprite/pacman-d 2.gif b/games/pacman/res/sprite/pacman-d 2.gif
new file mode 100644
index 0000000..2e257c5
Binary files /dev/null and b/games/pacman/res/sprite/pacman-d 2.gif differ
diff --git a/games/pacman/res/sprite/pacman-d 3.gif b/games/pacman/res/sprite/pacman-d 3.gif
new file mode 100644
index 0000000..84f4cf0
Binary files /dev/null and b/games/pacman/res/sprite/pacman-d 3.gif differ
diff --git a/games/pacman/res/sprite/pacman-d 4.gif b/games/pacman/res/sprite/pacman-d 4.gif
new file mode 100644
index 0000000..ee009c5
Binary files /dev/null and b/games/pacman/res/sprite/pacman-d 4.gif differ
diff --git a/games/pacman/res/sprite/pacman-d 5.gif b/games/pacman/res/sprite/pacman-d 5.gif
new file mode 100644
index 0000000..5fa29e9
Binary files /dev/null and b/games/pacman/res/sprite/pacman-d 5.gif differ
diff --git a/games/pacman/res/sprite/pacman-d 6.gif b/games/pacman/res/sprite/pacman-d 6.gif
new file mode 100644
index 0000000..ee009c5
Binary files /dev/null and b/games/pacman/res/sprite/pacman-d 6.gif differ
diff --git a/games/pacman/res/sprite/pacman-d 7.gif b/games/pacman/res/sprite/pacman-d 7.gif
new file mode 100644
index 0000000..84f4cf0
Binary files /dev/null and b/games/pacman/res/sprite/pacman-d 7.gif differ
diff --git a/games/pacman/res/sprite/pacman-d 8.gif b/games/pacman/res/sprite/pacman-d 8.gif
new file mode 100644
index 0000000..2e257c5
Binary files /dev/null and b/games/pacman/res/sprite/pacman-d 8.gif differ
diff --git a/games/pacman/res/sprite/pacman-l 1.gif b/games/pacman/res/sprite/pacman-l 1.gif
new file mode 100644
index 0000000..ee7f79a
Binary files /dev/null and b/games/pacman/res/sprite/pacman-l 1.gif differ
diff --git a/games/pacman/res/sprite/pacman-l 2.gif b/games/pacman/res/sprite/pacman-l 2.gif
new file mode 100644
index 0000000..93907ad
Binary files /dev/null and b/games/pacman/res/sprite/pacman-l 2.gif differ
diff --git a/games/pacman/res/sprite/pacman-l 3.gif b/games/pacman/res/sprite/pacman-l 3.gif
new file mode 100644
index 0000000..00d1fea
Binary files /dev/null and b/games/pacman/res/sprite/pacman-l 3.gif differ
diff --git a/games/pacman/res/sprite/pacman-l 4.gif b/games/pacman/res/sprite/pacman-l 4.gif
new file mode 100644
index 0000000..c687f08
Binary files /dev/null and b/games/pacman/res/sprite/pacman-l 4.gif differ
diff --git a/games/pacman/res/sprite/pacman-l 5.gif b/games/pacman/res/sprite/pacman-l 5.gif
new file mode 100644
index 0000000..b446def
Binary files /dev/null and b/games/pacman/res/sprite/pacman-l 5.gif differ
diff --git a/games/pacman/res/sprite/pacman-l 6.gif b/games/pacman/res/sprite/pacman-l 6.gif
new file mode 100644
index 0000000..c687f08
Binary files /dev/null and b/games/pacman/res/sprite/pacman-l 6.gif differ
diff --git a/games/pacman/res/sprite/pacman-l 7.gif b/games/pacman/res/sprite/pacman-l 7.gif
new file mode 100644
index 0000000..00d1fea
Binary files /dev/null and b/games/pacman/res/sprite/pacman-l 7.gif differ
diff --git a/games/pacman/res/sprite/pacman-l 8.gif b/games/pacman/res/sprite/pacman-l 8.gif
new file mode 100644
index 0000000..93907ad
Binary files /dev/null and b/games/pacman/res/sprite/pacman-l 8.gif differ
diff --git a/games/pacman/res/sprite/pacman-r 1.gif b/games/pacman/res/sprite/pacman-r 1.gif
new file mode 100644
index 0000000..7719686
Binary files /dev/null and b/games/pacman/res/sprite/pacman-r 1.gif differ
diff --git a/games/pacman/res/sprite/pacman-r 2.gif b/games/pacman/res/sprite/pacman-r 2.gif
new file mode 100644
index 0000000..d99ef73
Binary files /dev/null and b/games/pacman/res/sprite/pacman-r 2.gif differ
diff --git a/games/pacman/res/sprite/pacman-r 3.gif b/games/pacman/res/sprite/pacman-r 3.gif
new file mode 100644
index 0000000..6a0ab97
Binary files /dev/null and b/games/pacman/res/sprite/pacman-r 3.gif differ
diff --git a/games/pacman/res/sprite/pacman-r 4.gif b/games/pacman/res/sprite/pacman-r 4.gif
new file mode 100644
index 0000000..acbb20c
Binary files /dev/null and b/games/pacman/res/sprite/pacman-r 4.gif differ
diff --git a/games/pacman/res/sprite/pacman-r 5.gif b/games/pacman/res/sprite/pacman-r 5.gif
new file mode 100644
index 0000000..1fe5419
Binary files /dev/null and b/games/pacman/res/sprite/pacman-r 5.gif differ
diff --git a/games/pacman/res/sprite/pacman-r 6.gif b/games/pacman/res/sprite/pacman-r 6.gif
new file mode 100644
index 0000000..acbb20c
Binary files /dev/null and b/games/pacman/res/sprite/pacman-r 6.gif differ
diff --git a/games/pacman/res/sprite/pacman-r 7.gif b/games/pacman/res/sprite/pacman-r 7.gif
new file mode 100644
index 0000000..6a0ab97
Binary files /dev/null and b/games/pacman/res/sprite/pacman-r 7.gif differ
diff --git a/games/pacman/res/sprite/pacman-r 8.gif b/games/pacman/res/sprite/pacman-r 8.gif
new file mode 100644
index 0000000..d99ef73
Binary files /dev/null and b/games/pacman/res/sprite/pacman-r 8.gif differ
diff --git a/games/pacman/res/sprite/pacman-u 1.gif b/games/pacman/res/sprite/pacman-u 1.gif
new file mode 100644
index 0000000..01ef0a3
Binary files /dev/null and b/games/pacman/res/sprite/pacman-u 1.gif differ
diff --git a/games/pacman/res/sprite/pacman-u 2.gif b/games/pacman/res/sprite/pacman-u 2.gif
new file mode 100644
index 0000000..bceebda
Binary files /dev/null and b/games/pacman/res/sprite/pacman-u 2.gif differ
diff --git a/games/pacman/res/sprite/pacman-u 3.gif b/games/pacman/res/sprite/pacman-u 3.gif
new file mode 100644
index 0000000..77f41cc
Binary files /dev/null and b/games/pacman/res/sprite/pacman-u 3.gif differ
diff --git a/games/pacman/res/sprite/pacman-u 4.gif b/games/pacman/res/sprite/pacman-u 4.gif
new file mode 100644
index 0000000..d67a385
Binary files /dev/null and b/games/pacman/res/sprite/pacman-u 4.gif differ
diff --git a/games/pacman/res/sprite/pacman-u 5.gif b/games/pacman/res/sprite/pacman-u 5.gif
new file mode 100644
index 0000000..d4698b0
Binary files /dev/null and b/games/pacman/res/sprite/pacman-u 5.gif differ
diff --git a/games/pacman/res/sprite/pacman-u 6.gif b/games/pacman/res/sprite/pacman-u 6.gif
new file mode 100644
index 0000000..d67a385
Binary files /dev/null and b/games/pacman/res/sprite/pacman-u 6.gif differ
diff --git a/games/pacman/res/sprite/pacman-u 7.gif b/games/pacman/res/sprite/pacman-u 7.gif
new file mode 100644
index 0000000..77f41cc
Binary files /dev/null and b/games/pacman/res/sprite/pacman-u 7.gif differ
diff --git a/games/pacman/res/sprite/pacman-u 8.gif b/games/pacman/res/sprite/pacman-u 8.gif
new file mode 100644
index 0000000..bceebda
Binary files /dev/null and b/games/pacman/res/sprite/pacman-u 8.gif differ
diff --git a/games/pacman/res/sprite/pacman.gif b/games/pacman/res/sprite/pacman.gif
new file mode 100644
index 0000000..a584c10
Binary files /dev/null and b/games/pacman/res/sprite/pacman.gif differ
diff --git a/games/pacman/res/text/0.gif b/games/pacman/res/text/0.gif
new file mode 100644
index 0000000..f01b653
Binary files /dev/null and b/games/pacman/res/text/0.gif differ
diff --git a/games/pacman/res/text/1.gif b/games/pacman/res/text/1.gif
new file mode 100644
index 0000000..7349994
Binary files /dev/null and b/games/pacman/res/text/1.gif differ
diff --git a/games/pacman/res/text/2.gif b/games/pacman/res/text/2.gif
new file mode 100644
index 0000000..3254d6f
Binary files /dev/null and b/games/pacman/res/text/2.gif differ
diff --git a/games/pacman/res/text/3.gif b/games/pacman/res/text/3.gif
new file mode 100644
index 0000000..c88635d
Binary files /dev/null and b/games/pacman/res/text/3.gif differ
diff --git a/games/pacman/res/text/4.gif b/games/pacman/res/text/4.gif
new file mode 100644
index 0000000..f3b5c3b
Binary files /dev/null and b/games/pacman/res/text/4.gif differ
diff --git a/games/pacman/res/text/5.gif b/games/pacman/res/text/5.gif
new file mode 100644
index 0000000..dae0fd7
Binary files /dev/null and b/games/pacman/res/text/5.gif differ
diff --git a/games/pacman/res/text/6.gif b/games/pacman/res/text/6.gif
new file mode 100644
index 0000000..dae7821
Binary files /dev/null and b/games/pacman/res/text/6.gif differ
diff --git a/games/pacman/res/text/7.gif b/games/pacman/res/text/7.gif
new file mode 100644
index 0000000..dda359b
Binary files /dev/null and b/games/pacman/res/text/7.gif differ
diff --git a/games/pacman/res/text/8.gif b/games/pacman/res/text/8.gif
new file mode 100644
index 0000000..01305d4
Binary files /dev/null and b/games/pacman/res/text/8.gif differ
diff --git a/games/pacman/res/text/9.gif b/games/pacman/res/text/9.gif
new file mode 100644
index 0000000..b29bb19
Binary files /dev/null and b/games/pacman/res/text/9.gif differ
diff --git a/games/pacman/res/text/gameover.gif b/games/pacman/res/text/gameover.gif
new file mode 100644
index 0000000..e854b89
Binary files /dev/null and b/games/pacman/res/text/gameover.gif differ
diff --git a/games/pacman/res/text/life.gif b/games/pacman/res/text/life.gif
new file mode 100644
index 0000000..0e8f1bf
Binary files /dev/null and b/games/pacman/res/text/life.gif differ
diff --git a/games/pacman/res/text/logo.gif b/games/pacman/res/text/logo.gif
new file mode 100644
index 0000000..1cd71a7
Binary files /dev/null and b/games/pacman/res/text/logo.gif differ
diff --git a/games/pacman/res/text/ready.gif b/games/pacman/res/text/ready.gif
new file mode 100644
index 0000000..0cdcd89
Binary files /dev/null and b/games/pacman/res/text/ready.gif differ
diff --git a/games/pacman/res/tiles/blank.gif b/games/pacman/res/tiles/blank.gif
new file mode 100644
index 0000000..ae631b0
Binary files /dev/null and b/games/pacman/res/tiles/blank.gif differ
diff --git a/games/pacman/res/tiles/door-h.gif b/games/pacman/res/tiles/door-h.gif
new file mode 100644
index 0000000..49687f5
Binary files /dev/null and b/games/pacman/res/tiles/door-h.gif differ
diff --git a/games/pacman/res/tiles/door-v.gif b/games/pacman/res/tiles/door-v.gif
new file mode 100644
index 0000000..2e7568d
Binary files /dev/null and b/games/pacman/res/tiles/door-v.gif differ
diff --git a/games/pacman/res/tiles/ghost-blinky.gif b/games/pacman/res/tiles/ghost-blinky.gif
new file mode 100644
index 0000000..af02492
Binary files /dev/null and b/games/pacman/res/tiles/ghost-blinky.gif differ
diff --git a/games/pacman/res/tiles/ghost-door.gif b/games/pacman/res/tiles/ghost-door.gif
new file mode 100644
index 0000000..cffd09a
Binary files /dev/null and b/games/pacman/res/tiles/ghost-door.gif differ
diff --git a/games/pacman/res/tiles/ghost-inky.gif b/games/pacman/res/tiles/ghost-inky.gif
new file mode 100644
index 0000000..4753970
Binary files /dev/null and b/games/pacman/res/tiles/ghost-inky.gif differ
diff --git a/games/pacman/res/tiles/ghost-pinky.gif b/games/pacman/res/tiles/ghost-pinky.gif
new file mode 100644
index 0000000..6fd82ec
Binary files /dev/null and b/games/pacman/res/tiles/ghost-pinky.gif differ
diff --git a/games/pacman/res/tiles/ghost-sue.gif b/games/pacman/res/tiles/ghost-sue.gif
new file mode 100644
index 0000000..14b057d
Binary files /dev/null and b/games/pacman/res/tiles/ghost-sue.gif differ
diff --git a/games/pacman/res/tiles/glasses.gif b/games/pacman/res/tiles/glasses.gif
new file mode 100644
index 0000000..f17ba54
Binary files /dev/null and b/games/pacman/res/tiles/glasses.gif differ
diff --git a/games/pacman/res/tiles/hiscores.gif b/games/pacman/res/tiles/hiscores.gif
new file mode 100644
index 0000000..c504d3c
Binary files /dev/null and b/games/pacman/res/tiles/hiscores.gif differ
diff --git a/games/pacman/res/tiles/pellet-power.gif b/games/pacman/res/tiles/pellet-power.gif
new file mode 100644
index 0000000..806f7f4
Binary files /dev/null and b/games/pacman/res/tiles/pellet-power.gif differ
diff --git a/games/pacman/res/tiles/pellet.gif b/games/pacman/res/tiles/pellet.gif
new file mode 100644
index 0000000..5284dd8
Binary files /dev/null and b/games/pacman/res/tiles/pellet.gif differ
diff --git a/games/pacman/res/tiles/showlogo.gif b/games/pacman/res/tiles/showlogo.gif
new file mode 100644
index 0000000..35abd50
Binary files /dev/null and b/games/pacman/res/tiles/showlogo.gif differ
diff --git a/games/pacman/res/tiles/start.gif b/games/pacman/res/tiles/start.gif
new file mode 100644
index 0000000..8b0fafe
Binary files /dev/null and b/games/pacman/res/tiles/start.gif differ
diff --git a/games/pacman/res/tiles/wall-corner-ll.gif b/games/pacman/res/tiles/wall-corner-ll.gif
new file mode 100644
index 0000000..86b0398
Binary files /dev/null and b/games/pacman/res/tiles/wall-corner-ll.gif differ
diff --git a/games/pacman/res/tiles/wall-corner-lr.gif b/games/pacman/res/tiles/wall-corner-lr.gif
new file mode 100644
index 0000000..c43af41
Binary files /dev/null and b/games/pacman/res/tiles/wall-corner-lr.gif differ
diff --git a/games/pacman/res/tiles/wall-corner-ul.gif b/games/pacman/res/tiles/wall-corner-ul.gif
new file mode 100644
index 0000000..5acadaa
Binary files /dev/null and b/games/pacman/res/tiles/wall-corner-ul.gif differ
diff --git a/games/pacman/res/tiles/wall-corner-ur.gif b/games/pacman/res/tiles/wall-corner-ur.gif
new file mode 100644
index 0000000..be16253
Binary files /dev/null and b/games/pacman/res/tiles/wall-corner-ur.gif differ
diff --git a/games/pacman/res/tiles/wall-end-b.gif b/games/pacman/res/tiles/wall-end-b.gif
new file mode 100644
index 0000000..9041b06
Binary files /dev/null and b/games/pacman/res/tiles/wall-end-b.gif differ
diff --git a/games/pacman/res/tiles/wall-end-l.gif b/games/pacman/res/tiles/wall-end-l.gif
new file mode 100644
index 0000000..2ed728a
Binary files /dev/null and b/games/pacman/res/tiles/wall-end-l.gif differ
diff --git a/games/pacman/res/tiles/wall-end-r.gif b/games/pacman/res/tiles/wall-end-r.gif
new file mode 100644
index 0000000..25c7848
Binary files /dev/null and b/games/pacman/res/tiles/wall-end-r.gif differ
diff --git a/games/pacman/res/tiles/wall-end-t.gif b/games/pacman/res/tiles/wall-end-t.gif
new file mode 100644
index 0000000..2155e70
Binary files /dev/null and b/games/pacman/res/tiles/wall-end-t.gif differ
diff --git a/games/pacman/res/tiles/wall-nub.gif b/games/pacman/res/tiles/wall-nub.gif
new file mode 100644
index 0000000..113941b
Binary files /dev/null and b/games/pacman/res/tiles/wall-nub.gif differ
diff --git a/games/pacman/res/tiles/wall-straight-horiz.gif b/games/pacman/res/tiles/wall-straight-horiz.gif
new file mode 100644
index 0000000..6308eef
Binary files /dev/null and b/games/pacman/res/tiles/wall-straight-horiz.gif differ
diff --git a/games/pacman/res/tiles/wall-straight-vert.gif b/games/pacman/res/tiles/wall-straight-vert.gif
new file mode 100644
index 0000000..6b7ddb7
Binary files /dev/null and b/games/pacman/res/tiles/wall-straight-vert.gif differ
diff --git a/games/pacman/res/tiles/wall-t-bottom.gif b/games/pacman/res/tiles/wall-t-bottom.gif
new file mode 100644
index 0000000..10ac483
Binary files /dev/null and b/games/pacman/res/tiles/wall-t-bottom.gif differ
diff --git a/games/pacman/res/tiles/wall-t-left.gif b/games/pacman/res/tiles/wall-t-left.gif
new file mode 100644
index 0000000..3006e2a
Binary files /dev/null and b/games/pacman/res/tiles/wall-t-left.gif differ
diff --git a/games/pacman/res/tiles/wall-t-right.gif b/games/pacman/res/tiles/wall-t-right.gif
new file mode 100644
index 0000000..27bb644
Binary files /dev/null and b/games/pacman/res/tiles/wall-t-right.gif differ
diff --git a/games/pacman/res/tiles/wall-t-top.gif b/games/pacman/res/tiles/wall-t-top.gif
new file mode 100644
index 0000000..11f0e1e
Binary files /dev/null and b/games/pacman/res/tiles/wall-t-top.gif differ
diff --git a/games/pacman/res/tiles/wall-x.gif b/games/pacman/res/tiles/wall-x.gif
new file mode 100644
index 0000000..3ba8eaa
Binary files /dev/null and b/games/pacman/res/tiles/wall-x.gif differ
diff --git a/games/pacman/res/tiles/x-paintwall.gif b/games/pacman/res/tiles/x-paintwall.gif
new file mode 100644
index 0000000..78f60c4
Binary files /dev/null and b/games/pacman/res/tiles/x-paintwall.gif differ
diff --git a/games/pong/__pycache__/run_supervised.cpython-310.pyc b/games/pong/__pycache__/run_supervised.cpython-310.pyc
index 730994f..8d2214e 100644
Binary files a/games/pong/__pycache__/run_supervised.cpython-310.pyc and b/games/pong/__pycache__/run_supervised.cpython-310.pyc differ
diff --git a/games/pong/pong_envs/__pycache__/pong_env.cpython-310.pyc b/games/pong/pong_envs/__pycache__/pong_env.cpython-310.pyc
index b637823..10d59fd 100644
Binary files a/games/pong/pong_envs/__pycache__/pong_env.cpython-310.pyc and b/games/pong/pong_envs/__pycache__/pong_env.cpython-310.pyc differ
diff --git a/games/pong/pong_envs/pong_env.py b/games/pong/pong_envs/pong_env.py
index 3e9d6de..383e141 100644
--- a/games/pong/pong_envs/pong_env.py
+++ b/games/pong/pong_envs/pong_env.py
@@ -28,7 +28,7 @@ class PongEnvNew(gym.Env):
             self.observation_space = gym.spaces.Box(low=0, high=255, shape=(self.frame_stack, 84, 84), dtype=np.uint8)
         else:
             # Define a generic observation space for graph data
-            self.observation_space = gym.spaces.Box(low=-np.inf, high=np.inf, shape=(5, 7), dtype=np.float32)  # Number of objects and feature length
+            self.observation_space = gym.spaces.Box(low=-np.inf, high=np.inf, shape=(3, 7), dtype=np.float32)  # Number of objects and feature length
 
         if self.render_mode == "human" or self.render_mode == "rgb_array":
             self.screen = pygame.display.set_mode((self.width, self.height))
@@ -37,7 +37,7 @@ class PongEnvNew(gym.Env):
             self.screen = pygame.Surface((self.width, self.height))
         
         self.clock = pygame.time.Clock()
-        self.ai_reaction_time = 2  # milliseconds
+        self.ai_reaction_time = 10  # milliseconds
         self.np_random = None
         self.frame_buffer = np.zeros((self.height, self.width, self.frame_stack), dtype=np.uint8)
         self.proximity_threshold = 50
@@ -57,7 +57,7 @@ class PongEnvNew(gym.Env):
         self.left_paddle = pygame.Rect(20, self.height // 2 - self.paddle_height // 2, self.paddle_width, self.paddle_height)
         self.right_paddle = pygame.Rect(self.width - 20 - self.paddle_width, self.height // 2 - self.paddle_height // 2, self.paddle_width, self.paddle_height)
         self.ai_last_reaction_time = pygame.time.get_ticks()
-        self.ball_speed_x, self.ball_speed_y = 4 * random.choice((1, -1)), 4 * random.choice((1, -1))
+        self.ball_speed_x, self.ball_speed_y = 2 * random.choice((1, -1)), 2 * random.choice((1, -1))
         self.left_player_score = 0
         self.right_player_score = 0
         self.frame_buffer = np.zeros((self.height, self.width, self.frame_stack), dtype=np.uint8)
@@ -132,20 +132,45 @@ class PongEnvNew(gym.Env):
         # Existing game state update logic
         self.ball.x += self.ball_speed_x
         self.ball.y += self.ball_speed_y
+        
         # Check for collisions with top and bottom of the screen
-        if self.ball.top <= 0 or self.ball.bottom >= self.height:
+        if self.ball.top <= 0:
+            self.ball.top = 1  # Prevent sticking to the top wall
+            self.ball_speed_y *= -1
+        elif self.ball.bottom >= self.height:
+            self.ball.bottom = self.height - 1  # Prevent sticking to the bottom wall
             self.ball_speed_y *= -1
+        
         # AI paddle move
         self.ai_move()
+        
         # Check for collisions with paddles
         collision = False
         if self.ball.colliderect(self.left_paddle) or self.ball.colliderect(self.right_paddle):
-            self.ball_speed_x *= -1
             collision = True
+            paddle = self.left_paddle if self.ball.colliderect(self.left_paddle) else self.right_paddle
+            
+            # Calculate the difference between the center of the paddle and the ball's y position
+            paddle_center_y = paddle.y + paddle.height / 2
+            difference = self.ball.centery - paddle_center_y
+            
+            # Normalize the difference to a reasonable range, e.g., between -1 and 1
+            normalized_difference = difference / (paddle.height / 2)
+            
+            # Reflect the ball's horizontal speed
+            self.ball_speed_x *= -1
+            
+            # Adjust the ball's vertical speed based on the difference
+            self.ball_speed_y += normalized_difference * 5  # Adjust the multiplier as needed
+            
+            # Ensure the ball's speed is within a reasonable range
+            max_speed = 10
+            self.ball_speed_y = max(-max_speed, min(max_speed, self.ball_speed_y))
+            
             # Adjust the ball's position to prevent sticking
-            if self.ball.colliderect(self.left_paddle):
+            if paddle == self.left_paddle:
                 self.ball.left = self.left_paddle.right  # Place the ball right outside the left paddle
-            elif self.ball.colliderect(self.right_paddle):
+            else:
                 self.ball.right = self.right_paddle.left  # Place the ball right outside the right paddle
 
         # Check for scoring
@@ -163,7 +188,7 @@ class PongEnvNew(gym.Env):
 
     def ball_reset(self):
         self.ball.x, self.ball.y = self.width // 2 - self.ball_size // 2, self.height // 2 - self.ball_size // 2
-        self.ball_speed_x, self.ball_speed_y = 5 * random.choice((1, -1)), 5 * random.choice((1, -1))
+        self.ball_speed_x, self.ball_speed_y = 2 * random.choice((1, -1)), 2 * random.choice((1, -1))
 
     def step(self, action):
         if not pygame.display.get_init():
@@ -202,8 +227,8 @@ class PongEnvNew(gym.Env):
             "ball": [self.ball.x, self.ball.y, self.ball_speed_x, self.ball_speed_y, 1, 0, 0],
             "left_paddle": [self.left_paddle.x, self.left_paddle.y, 0, 0, 0, 1, 0],
             "right_paddle": [self.right_paddle.x, self.right_paddle.y, 0, 0, 0, 1, 0],
-            "top_wall": [0, 0, 0, 0, 0, 0, 1],
-            "bottom_wall": [0, self.height, 0, 0, 0, 0, 1]
+            # "top_wall": [0, 0, 0, 0, 0, 0, 1],
+            # "bottom_wall": [0, self.height, 0, 0, 0, 0, 1]
         }
 
         # Convert the object features to a tensor
@@ -222,19 +247,41 @@ class PongEnvNew(gym.Env):
         pygame.display.quit()
         pygame.quit()
 
-if __name__ == "__main__":
-    env = PongEnvNew(render_mode='human', observation_type='graph')
+# if __name__ == "__main__":
+#     env = PongEnvNew(render_mode='human', observation_type='pixel')
     
-    env.reset()
+#     env.reset()
+
+#     num_episodes = 100
+#     for i_episode in range(num_episodes):
+#         done = False
+#         try:
+#             while not done:
+#                 action = env.action_space.sample()
+#                 _, _, done, _, _ = env.step(action)
+#                 env.render()
+#                 pygame.time.wait(10)
+#         finally:
+#             env.close()
+
+from stable_baselines3 import PPO
 
+if __name__ == "__main__":
+    env = PongEnvNew(render_mode='human', observation_type='pixel')
+    model = PPO.load("ppo_custom_cnn_pong")
     num_episodes = 100
+
     for i_episode in range(num_episodes):
         done = False
+        obs, _ = env.reset()  # Reset the environment at the start of each episode
         try:
             while not done:
-                action = env.action_space.sample()
-                _, _, done, _, _ = env.step(action)
+                action, _ = model.predict(obs)
+                obs, _, done, _, _ = env.step(action)
                 env.render()
                 pygame.time.wait(10)
+        except Exception as e:
+            print(f"An error occurred: {e}")
+            break
         finally:
             env.close()
diff --git a/games/pong/run_supervised.py b/games/pong/run_supervised.py
deleted file mode 100644
index 98c7872..0000000
--- a/games/pong/run_supervised.py
+++ /dev/null
@@ -1,126 +0,0 @@
-import wandb
-from stable_baselines3 import PPO
-from stable_baselines3.common.env_util import make_vec_env
-from wandb.integration.sb3 import WandbCallback
-#from games.model.policy import CustomActorCriticPolicy
-from games.pong.pong_envs.pong_env import PongEnvNew
-from games.model.policy import CustomCNN, CustomHeteroGNN
-# Initialize wandb
-# wandb.init(
-#     project="gnn_atari",  # Replace with your project name
-#     sync_tensorboard=True,        # Automatically sync SB3 logs with wandb
-#     monitor_gym=True,             # Automatically log gym environments
-#     save_code=True                # Save the code used for this run
-# )
-
-# wandb.init(
-#     project="cnn_g",  # Replace with your project name
-#     sync_tensorboard=True,        # Automatically sync SB3 logs with wandb
-#     monitor_gym=True,             # Automatically log gym environments
-#     save_code=True                # Save the code used for this run
-# )
-
-# Wrap the environment 
-
-env = PongEnvNew(render_mode='human', observation_type='graph')
-# policy_kwargs = dict(
-#     features_extractor_class=CustomCNN,
-#     features_extractor_kwargs=dict(features_dim=128),
-# )
-
-policy_kwargs = dict(
-    features_extractor_class=CustomHeteroGNN,
-    features_extractor_kwargs=dict(
-        features_dim=64,
-        hidden_size=64,
-        num_layer=2,
-        obj_type_id='obj',
-        arity_dict={'atom': 2}
-    ),
-)
-
-# Create the PPO model with the custom feature extractor
-model = PPO('MlpPolicy', env, policy_kwargs=policy_kwargs, verbose=1)
-# Train the model with WandbCallback
-#model.learn(total_timesteps=1000000, callback=WandbCallback())
-model.learn(total_timesteps=1000000)
-# Save the model
-#model.save("ppo_custom_heterognn")
-#model.save("ppo_custom_cnn")
-# wandb.save("ppo_custom_heterognn.zip")  # Save the model to wandb
-
-# # Load the model
-# #model = PPO.load("ppo_custom_heterognn")
-# model = PPO.load("ppo_custom_cnn")
-# # Evaluate the model
-# obs = env.reset()
-# for _ in range(1000):
-#     action, _states = model.predict(obs)
-#     obs, rewards, dones, info = env.step(action)
-#     env.render()
-
-# import torch as th
-# import torch.nn as nn
-# from gymnasium import spaces
-
-# from stable_baselines3 import PPO
-# from stable_baselines3.common.torch_layers import BaseFeaturesExtractor
-# import torch_geometric as pyg
-# from stable_baselines3.common.policies import ActorCriticPolicy
-# from games.pong.pong_envs.pong_env import PongEnvNew
-
-# class CustomCNN(BaseFeaturesExtractor):
-#     """
-#     :param observation_space: (gym.Space)
-#     :param features_dim: (int) Number of features extracted.
-#     This corresponds to the number of units for the last layer.
-#     """
-
-#     def __init__(self, observation_space: spaces.Box, features_dim: int = 128):
-#         super().__init__(observation_space, features_dim)
-#         # We assume CxHxW images (channels first)
-#         n_input_channels = observation_space.shape[0]
-#         print(f"n_input_channels: {n_input_channels}")
-#         self.cnn = nn.Sequential(
-#             nn.Conv2d(n_input_channels, 32, kernel_size=8, stride=4, padding=0),
-#             nn.ReLU(),
-#             nn.Conv2d(32, 64, kernel_size=4, stride=2, padding=0),
-#             nn.ReLU(),
-#             nn.Conv2d(64, 128, kernel_size=3, stride=1, padding=0),
-#             nn.ReLU(),
-#             nn.Flatten(),
-#         )
-
-#         # Compute shape by doing one forward pass
-#         with th.no_grad():
-#             sample_input = th.as_tensor(observation_space.sample()[None]).float() 
-
-#             n_flatten = self.cnn(sample_input).view(-1).shape[0]
-
-#         self.linear = nn.Sequential(
-#             nn.Linear(n_flatten, features_dim),
-#             nn.ReLU()
-#         )
-
-#     def forward(self, observations: th.Tensor) -> th.Tensor:
-#         # (n_batch, n_channel, height, width)
-#         print(f"Observations shape: {observations.shape}")
-
-#         features = self.cnn(observations)
-#         output = self.linear(features)
-#         return output
-
-
-# env = PongEnvNew(render_mode='human', observation_type='pixel')
-
-# policy_kwargs = dict(
-#     features_extractor_class=CustomCNN,
-#     features_extractor_kwargs=dict(features_dim=128)
-# )
-
-# model = PPO("CnnPolicy", env, policy_kwargs=policy_kwargs, verbose=1)
-# #model = PPO("CnnPolicy", "BreakoutNoFrameskip-v4", policy_kwargs=policy_kwargs, verbose=1, batch_size=1)
-# model = 
-# model.learn(total_timesteps=1000000) 
-
-
diff --git a/wandb/debug-internal.log b/wandb/debug-internal.log
index d40373e..0a45801 120000
--- a/wandb/debug-internal.log
+++ b/wandb/debug-internal.log
@@ -1 +1 @@
-run-20240605_224243-zejyjx2m/logs/debug-internal.log
\ No newline at end of file
+run-20240618_231835-mkivkkkj/logs/debug-internal.log
\ No newline at end of file
diff --git a/wandb/debug.log b/wandb/debug.log
index 6ca7987..95a7b41 120000
--- a/wandb/debug.log
+++ b/wandb/debug.log
@@ -1 +1 @@
-run-20240605_224243-zejyjx2m/logs/debug.log
\ No newline at end of file
+run-20240618_231835-mkivkkkj/logs/debug.log
\ No newline at end of file
diff --git a/wandb/latest-run b/wandb/latest-run
index bed3576..463a551 120000
--- a/wandb/latest-run
+++ b/wandb/latest-run
@@ -1 +1 @@
-run-20240605_224243-zejyjx2m
\ No newline at end of file
+run-20240618_231835-mkivkkkj
\ No newline at end of file
