diff --git a/games/__pycache__/__init__.cpython-310.pyc b/games/__pycache__/__init__.cpython-310.pyc
index 347bbb7..1b00a1b 100644
Binary files a/games/__pycache__/__init__.cpython-310.pyc and b/games/__pycache__/__init__.cpython-310.pyc differ
diff --git a/games/encoder/GraphEncoder.py b/games/encoder/GraphEncoder.py
index 436b348..5065613 100644
--- a/games/encoder/GraphEncoder.py
+++ b/games/encoder/GraphEncoder.py
@@ -37,7 +37,6 @@ class HeteroGNNEncoderPong:
                     graph.add_edge(i, atom_index, position=0)
                     graph.add_edge(j, atom_index, position=1)
                     atom_index += 1
-            pos = nx.spring_layout(graph)  # positions for all nodes
             
             batch_data.append(graph)
 
@@ -769,3 +768,113 @@ class GraphEncoderBreakout:
             data_list.append(data)
 
         return data_list
+
+
+import torch
+import networkx as nx
+from torch_geometric.data import HeteroData, Batch
+from itertools import combinations
+import torch_geometric.utils as pyg_utils
+
+class HeteroGNNEncoderShooting:
+    def __init__(self, obj_type_id: str = "obj", atom_type_id: str = "atom"):
+        self.obj_type_id = obj_type_id
+        self.atom_type_id = atom_type_id
+
+    def encode(self, batch_node_features: torch.Tensor, proximity_threshold: float = 1000) -> Batch:
+        batch_data = []
+        batch_size = batch_node_features.size(0)
+
+        for b in range(batch_size):
+            node_features = batch_node_features[b]
+            num_nodes = node_features.size(0)
+            graph = nx.Graph()
+
+            # Adding object nodes
+            for i in range(num_nodes):
+                graph.add_node(i, type=self.obj_type_id, features=node_features[i].tolist())
+
+            # Adding atom nodes
+            atom_index = num_nodes
+            object_feature_length = node_features.size(1)
+
+            for i, j in combinations(range(num_nodes), 2):
+                if self.is_ball_bullet_pair(node_features[i], node_features[j]):
+                    atom_features = torch.zeros((2, object_feature_length)).tolist()
+                    graph.add_node(atom_index, type=self.atom_type_id, features=atom_features)
+                    graph.add_edge(i, atom_index, position=0)
+                    graph.add_edge(j, atom_index, position=1)
+                    atom_index += 1
+                else:
+                    dist = torch.norm(node_features[i, :2] - node_features[j, :2]).item()
+                    if dist < proximity_threshold:
+                        atom_features = torch.zeros((2, object_feature_length)).tolist()
+                        graph.add_node(atom_index, type=self.atom_type_id, features=atom_features)
+                        graph.add_edge(i, atom_index, position=0)
+                        graph.add_edge(j, atom_index, position=1)
+                        atom_index += 1
+
+            pos = nx.spring_layout(graph)  # positions for all nodes
+            batch_data.append(graph)
+
+        return Batch.from_data_list(self.to_pyg_data(batch_data))
+
+    def is_ball_bullet_pair(self, feature1, feature2):
+        return (feature1[-1] == 0 and feature2[-1] == 1) or (feature1[-1] == 1 and feature2[-1] == 0)
+
+    def to_pyg_data(self, batch_graphs):
+        data_list = []
+
+        for graph in batch_graphs:
+            data = HeteroData()
+            node_index_mapping = defaultdict(dict)
+            obj_features = []
+            atom_features_dict = defaultdict(list)
+            edge_dict = defaultdict(list)
+
+            current_obj_features = []
+            current_atom_features_dict = defaultdict(list)
+
+            for node, attrs in graph.nodes(data=True):
+                node_type = attrs['type']
+                features = torch.tensor(attrs['features'])
+                if node_type == self.obj_type_id:
+                    node_index_mapping[node_type][node] = len(current_obj_features)
+                    current_obj_features.append(features)
+                else:
+                    node_index_mapping[node_type][node] = len(current_atom_features_dict[node_type])
+                    current_atom_features_dict[node_type].append(features)
+
+            if current_obj_features:
+                obj_features.append(torch.stack(current_obj_features))
+            for node_type, features_list in current_atom_features_dict.items():
+                if features_list:
+                    flattened_features = [f.view(-1) for f in features_list]
+                    atom_features_dict[node_type].append(torch.stack(flattened_features))
+
+            if obj_features:
+                data[self.obj_type_id].x = torch.cat(obj_features)
+            for node_type, features_list in atom_features_dict.items():
+                if features_list:
+                    data[node_type].x = torch.cat(features_list)
+
+            for src, dst, attr in graph.edges(data=True):
+                src_type = graph.nodes[src]['type']
+                dst_type = graph.nodes[dst]['type']
+                pos = str(attr['position'])
+                edge_type = (src_type, pos, dst_type)
+
+                src_idx = node_index_mapping[src_type][src]
+                dst_idx = node_index_mapping[dst_type][dst]
+                edge_dict[edge_type].append((src_idx, dst_idx))
+                # Add reverse edges for bidirectionality
+                reverse_edge_type = (dst_type, pos, src_type)
+                edge_dict[reverse_edge_type].append((dst_idx, src_idx))
+
+            for edge_type, edges in edge_dict.items():
+                edge_tensor = torch.tensor(edges, dtype=torch.long).t().contiguous()
+                data[edge_type].edge_index = edge_tensor
+
+            data_list.append(data)
+
+        return data_list
\ No newline at end of file
diff --git a/games/encoder/__pycache__/GraphEncoder.cpython-310.pyc b/games/encoder/__pycache__/GraphEncoder.cpython-310.pyc
index 3dc7f23..9813cde 100644
Binary files a/games/encoder/__pycache__/GraphEncoder.cpython-310.pyc and b/games/encoder/__pycache__/GraphEncoder.cpython-310.pyc differ
diff --git a/games/encoder/__pycache__/__init__.cpython-310.pyc b/games/encoder/__pycache__/__init__.cpython-310.pyc
index 7335618..e4059e9 100644
Binary files a/games/encoder/__pycache__/__init__.cpython-310.pyc and b/games/encoder/__pycache__/__init__.cpython-310.pyc differ
diff --git a/games/freeway/__pycache__/__init__.cpython-310.pyc b/games/freeway/__pycache__/__init__.cpython-310.pyc
index ee44eda..8f6a241 100644
Binary files a/games/freeway/__pycache__/__init__.cpython-310.pyc and b/games/freeway/__pycache__/__init__.cpython-310.pyc differ
diff --git a/games/freeway/__pycache__/run_supervised_cnn.cpython-310.pyc b/games/freeway/__pycache__/run_supervised_cnn.cpython-310.pyc
index f8965e6..f4f1756 100644
Binary files a/games/freeway/__pycache__/run_supervised_cnn.cpython-310.pyc and b/games/freeway/__pycache__/run_supervised_cnn.cpython-310.pyc differ
diff --git a/games/freeway/__pycache__/run_supervised_gnn.cpython-310.pyc b/games/freeway/__pycache__/run_supervised_gnn.cpython-310.pyc
index 01b141a..62ca9f6 100644
Binary files a/games/freeway/__pycache__/run_supervised_gnn.cpython-310.pyc and b/games/freeway/__pycache__/run_supervised_gnn.cpython-310.pyc differ
diff --git a/games/freeway/freeway_envs/__pycache__/freeway_env.cpython-310.pyc b/games/freeway/freeway_envs/__pycache__/freeway_env.cpython-310.pyc
index cf3f63c..2b43868 100644
Binary files a/games/freeway/freeway_envs/__pycache__/freeway_env.cpython-310.pyc and b/games/freeway/freeway_envs/__pycache__/freeway_env.cpython-310.pyc differ
diff --git a/games/freeway/freeway_envs/freeway_env.py b/games/freeway/freeway_envs/freeway_env.py
index c17efff..fe4440b 100644
--- a/games/freeway/freeway_envs/freeway_env.py
+++ b/games/freeway/freeway_envs/freeway_env.py
@@ -6,41 +6,39 @@ from gymnasium import spaces
 import torch
 import networkx as nx
 from torch_geometric.data import HeteroData, Batch
-from collections import defaultdict
+from collections import defaultdict, deque
 from itertools import combinations
 from stable_baselines3 import PPO
 from stable_baselines3.common.evaluation import evaluate_policy
+from skimage.color import rgb2gray
+from skimage.transform import resize
 
 class FreewayEnv(gym.Env):
     metadata = {'render_modes': ['human', 'rgb_array']}
 
-    def __init__(self, render_mode='human', observation_type='pixel', frame_stack=4):
+    def __init__(self, render_mode='human', observation_type='pixel', frame_stack=4, lanes=[50, 80, 120], max_cars=10, car_speed =1):
         super(FreewayEnv, self).__init__()
         pygame.init()
         self.last_time = pygame.time.get_ticks()
         self.render_mode = render_mode
         self.observation_type = observation_type
-        #self.window_width = 800
         self.window_width = 210
-        #self.window_height = 600
         self.window_height = 160
         self.player_width = 5
         self.player_height = 5
         self.car_width = 20
         self.car_height = 20
         self.frame_stack = frame_stack
+        self.lanes = lanes
+        self.max_cars = max_cars
+        self.car_speed = car_speed
 
-        #self.lanes = [100, 200, 300, 400, 500, 600, 700]
-        self.lanes = [50,100,150]
-        self.max_cars = 10
-        # Define action and observation space
-        # Actions: 0 - Stay, 1 - Move Up, 2 - Move Down
         self.action_space = spaces.Discrete(3)
 
         if observation_type == "pixel":
             self.observation_space = spaces.Box(low=0, high=255, shape=(self.frame_stack, 84, 84), dtype=np.uint8)
         else:
-            self.observation_space = spaces.Box(low=-np.inf, high=np.inf, shape=(self.max_cars+ len(self.lanes)+1, 7), dtype=np.float32)
+            self.observation_space = spaces.Box(low=-np.inf, high=np.inf, shape=(self.max_cars + len(self.lanes) + 1, 7), dtype=np.float32)
 
         self.window = pygame.display.set_mode((self.window_width, self.window_height))
         self.background_image = pygame.image.load("games/images/Atari - background.png")
@@ -49,10 +47,11 @@ class FreewayEnv(gym.Env):
         self.player_image = pygame.transform.scale(self.player_image, (self.player_width, self.player_height))
         self.car_image = pygame.image.load("games/images/car2.png").convert_alpha()
         self.car_image = pygame.transform.scale(self.car_image, (self.car_width, self.car_height))
-        self.frame_buffer = np.zeros((self.frame_stack, 84, 84), dtype=np.uint8)
+        self.frame_buffer = deque(maxlen=self.frame_stack)
 
         self.clock = pygame.time.Clock()
         self.reset()
+
     def seed(self, seed=None):
         self.np_random, seed = gym.utils.seeding.np_random(seed)
         random.seed(seed)
@@ -69,19 +68,18 @@ class FreewayEnv(gym.Env):
         self.score = 0
         self.cars = [{'x': random.randint(0, self.window_width - self.car_width),
                       'lane': random.choice(self.lanes),
-                      'speed': random.randint(1, 2)} for _ in range(self.max_cars)]
+                      'speed': self.car_speed} for car in range(self.max_cars)]
         self.done = False
-        self.episode_start_time = pygame.time.get_ticks()
-        self.frame_buffer = np.zeros((self.frame_stack, 84, 84), dtype=np.uint8)
+        self.episode_step = 0
+        self.frame_buffer.clear()
         if self.observation_type == "pixel":
             for _ in range(self.frame_stack):
-                self.update_frame_buffer()
-            return self.get_observation(), {}
+                self.frame_buffer.append(self._get_obs())
+            return self.frame_buffer, {}
         else:
             return self.get_object_data(), {}
 
     def step(self, action):
-        reward = 0
         reward = -0.5
         current_time = pygame.time.get_ticks()
         if action == 1:  # Up
@@ -93,40 +91,45 @@ class FreewayEnv(gym.Env):
             car['x'] += car['speed']
             if car['x'] > self.window_width:
                 car['x'] = 0
-                car['speed'] = random.randint(1,2)
+                car['speed'] = random.randint(1, 2)
 
-        # Collision detection
         hit = any(self.player_rect.colliderect(pygame.Rect(car['x'], car['lane'], self.car_width, self.car_height)) for car in self.cars)
         if hit:
-            #self.score = -1
             self.player_rect.y = self.window_height - self.player_height - 10
-        
             self.last_time = current_time
-        if current_time - self.episode_start_time >= 60000:  # 60000 milliseconds = 1 minute
-            self.done = True
-            
-        if self.player_rect.y <= 0:  # Reached top
-            self.score +=1
-            reward += 10*(len(self.lanes))
+        done = False
+        self.episode_step += 1
+        if self.episode_step >= 3000:
+            done = True
 
+        if self.player_rect.y <= 0:  # Reached top
+            self.score += 1
+            reward += 10 * (len(self.lanes))
             self.player_rect.y = self.window_height - self.player_height - 10
-
+        truncated = False
+        info = {}  
         if self.observation_type == "pixel":
-            self.update_frame_buffer()
             observation = self.get_observation()
+            return np.array(self.frame_buffer), reward, done, truncated, info
         else:
-            observation = self.get_object_data()
+            return self.get_object_data(), reward, done, truncated, info
 
-        return observation, reward, self.done, False, {}
 
-    def update_frame_buffer(self):
-        frame = self.render_to_array()
-        grayscale = np.dot(frame[..., :3], [0.2989, 0.5870, 0.1140]).astype(np.uint8)  # Convert to grayscale
-        resized_frame = pygame.transform.scale(pygame.surfarray.make_surface(grayscale), (84, 84))
-        frame_array = pygame.surfarray.array3d(resized_frame).transpose(1, 0, 2)[:, :, 0]
+        return np.array(observation), reward, self.done, False, {}
 
-        self.frame_buffer = np.roll(self.frame_buffer, shift=-1, axis=0)
-        self.frame_buffer[-1] = frame_array
+    def _get_obs(self):
+        frame = self.render_to_array()
+    
+        # Convert to grayscale
+        grayscale = rgb2gray(frame)
+        
+        # Normalize the grayscale image to enhance contrast
+        normalized_frame = (grayscale - grayscale.min()) / (grayscale.max() - grayscale.min())
+        
+        # Resize the frame
+        resized_frame = resize(normalized_frame, (84, 84), anti_aliasing=True, mode='reflect', preserve_range=True)
+        
+        return resized_frame
 
     def render_to_array(self):
         self.window.blit(self.background_image, (0, 0))
@@ -141,18 +144,13 @@ class FreewayEnv(gym.Env):
     def get_object_data(self):
         objects = [
             [self.player_rect.x, self.player_rect.y, 0, 0, 1, 0, 0],  # Player
-            
-        ] 
-        # add lanes
+        ]
         for lane in self.lanes:
-            objects.append([self.window_width//2, lane, 0, 0, 0, 1, 0])
+            objects.append([self.window_width // 2, lane, 0, 0, 0, 1, 0])
 
-        for i, car in enumerate(self.cars):
+        for car in self.cars:
             objects.append([car['x'], car['lane'], car['speed'], 0, 0, 0, 1])
 
-        # while len(objects) < self.max_cars + 10:  # Ensure the list has a constant length
-        #     objects.append([0, 0, 0, 0, 0, 0, 0])
-
         return torch.tensor(objects, dtype=torch.float32)
 
     def render(self, mode='human'):
@@ -161,16 +159,18 @@ class FreewayEnv(gym.Env):
             self.window.blit(self.car_image, (car['x'], car['lane']))
         self.window.blit(self.player_image, (self.player_rect.x, self.player_rect.y))
         pygame.display.update()
+        self.clock.tick(60)
 
     def close(self):
         pygame.quit()
 
 
 if __name__=="__main__":
-    env = FreewayEnv(render_mode='human', observation_type='graph')
+    env = FreewayEnv(render_mode='human', observation_type='pixel')
 
-    #model = PPO.load("ppo_freeway_pixel")
-    model = PPO.load("ppo_custom_heterognn")
+    #model = PPO.load("best_model")
+    model = PPO.load("ppo_freeway_pixel")
+    #model = PPO.load("ppo_custom_heterognn")
 
     # # Evaluate the agent
     # mean_reward, std_reward = evaluate_policy(model, env, n_eval_episodes=1, render=True)
@@ -184,6 +184,7 @@ if __name__=="__main__":
         #action = env.action_space.sample()
         obs, reward, done, _,_ = env.step(action)
         total_reward += reward
+        #print(f"Action: {action}, Reward: {reward}")
         pygame.time.delay(50)
         env.render()
 
diff --git a/games/freeway/run_supervised_cnn.py b/games/freeway/run_supervised_cnn.py
index 8d1ce97..a1d9f06 100644
--- a/games/freeway/run_supervised_cnn.py
+++ b/games/freeway/run_supervised_cnn.py
@@ -1,89 +1,105 @@
-
-import torch as th
-import torch.nn as nn
-from gymnasium import spaces
-from stable_baselines3 import PPO
-from stable_baselines3.common.torch_layers import BaseFeaturesExtractor
-import torch_geometric as pyg
-from stable_baselines3.common.policies import ActorCriticPolicy
-from games.freeway.freeway_envs.freeway_env import FreewayEnv
-import pygame
-from stable_baselines3.common.vec_env import VecFrameStack
-from stable_baselines3.common.vec_env import DummyVecEnv
-from stable_baselines3.common.evaluation import evaluate_policy
-
-
-
-
+import os
+import numpy as np
 import torch as th
 import torch.nn as nn
 from gymnasium import spaces
 from stable_baselines3 import PPO
 from stable_baselines3.common.torch_layers import BaseFeaturesExtractor
-import torch_geometric as pyg
-from stable_baselines3.common.policies import ActorCriticPolicy
+from stable_baselines3.common.vec_env import DummyVecEnv, SubprocVecEnv
+from stable_baselines3.common.env_util import make_vec_env
+from stable_baselines3.common.monitor import Monitor
+from stable_baselines3.common.callbacks import BaseCallback, EvalCallback
+from stable_baselines3.common.monitor import load_results
+from stable_baselines3.common.results_plotter import ts2xy
+from wandb.integration.sb3 import WandbCallback
+from gymnasium.wrappers.time_limit import TimeLimit
 from games.freeway.freeway_envs.freeway_env import FreewayEnv
-import pygame
-
-class CustomCNN(BaseFeaturesExtractor):
-    """
-    :param observation_space: (gym.Space)
-    :param features_dim: (int) Number of features extracted.
-    This corresponds to the number of units for the last layer.
-    """
-
-    def __init__(self, observation_space: spaces.Box, features_dim: int = 128):
-        super().__init__(observation_space, features_dim)
-        # We assume CxHxW images (channels first)
-        n_input_channels = observation_space.shape[0]
-        print(f"n_input_channels: {n_input_channels}")
-        self.cnn = nn.Sequential(
-            nn.Conv2d(n_input_channels, 32, kernel_size=8, stride=4, padding=0),
-            nn.ReLU(),
-            nn.Conv2d(32, 64, kernel_size=4, stride=2, padding=0),
-            nn.ReLU(),
-            nn.Conv2d(64, 128, kernel_size=3, stride=1, padding=0),
-            nn.ReLU(),
-            nn.Flatten(),
-        )
-
-        # Compute shape by doing one forward pass
-        with th.no_grad():
-            sample_input = th.as_tensor(observation_space.sample()[None]).float() 
-
-            n_flatten = self.cnn(sample_input).view(-1).shape[0]
-
-        self.linear = nn.Sequential(
-            nn.Linear(n_flatten, features_dim),
-            nn.ReLU()
-        )
-
-    def forward(self, observations: th.Tensor) -> th.Tensor:
-        # (n_batch, n_channel, height, width)
-
-        features = self.cnn(observations)
-        output = self.linear(features)
-        return output
+from collections import OrderedDict
+import wandb
+from stable_baselines3.common.utils import get_schedule_fn
+
+class SaveOnBestTrainingRewardCallback(BaseCallback):
+    def __init__(self, check_freq, log_dir, verbose=1):
+        super(SaveOnBestTrainingRewardCallback, self).__init__(verbose)
+        self.check_freq = check_freq
+        self.log_dir = log_dir
+        self.save_path = os.path.join(log_dir, "best_model")
+        self.best_mean_reward = -np.inf
+
+    def _init_callback(self) -> None:
+        if self.save_path is not None:
+            os.makedirs(self.save_path, exist_ok=True)
+
+    def _on_step(self) -> bool:
+        if self.n_calls % self.check_freq == 0:
+            x, y = ts2xy(load_results(self.log_dir), "timesteps")
+            if len(x) > 0:
+                mean_reward = np.mean(y[-100:])
+                if self.verbose > 0:
+                    print(f"Num timesteps: {self.num_timesteps}")
+                    print(f"Best mean reward: {self.best_mean_reward:.2f} - Last mean reward per episode: {mean_reward:.2f}")
+                if mean_reward > self.best_mean_reward:
+                    self.best_mean_reward = mean_reward
+                    if self.verbose > 0:
+                        print(f"Saving new best model at {x[-1]} timesteps")
+                        print(f"Saving new best model to {self.save_path}.zip")
+                    self.model.save(self.save_path)
+            wandb.log({"mean_reward": mean_reward, "timesteps": self.num_timesteps})
+        return True
+
+def make_freeway_env(rank, seed=0, config=None):
+    def _init():
+        env = FreewayEnv(**config)
+        env = TimeLimit(env, max_episode_steps=3000)  # Set a reasonable max_episode_steps
+        monitor_path = os.path.join(log_dir, f"monitor_{rank}.csv")
+        os.makedirs(log_dir, exist_ok=True)  # Create log directory if it doesn't exist
+        env = Monitor(env, filename=monitor_path, allow_early_resets=True)
+        env.seed(seed + rank)
+        return env
+    return _init
 
 if __name__ == "__main__":
-
-   
     num_envs = 4  # Number of parallel environments
 
-    #Create a vectorized environment with DummyVecEnv
-    def make_env(rank, seed=0):
-        def _init():
-            env = FreewayEnv(render_mode='rgb_array', observation_type='pixel')
-            env.seed(seed + rank)
-            return env
-        return _init
+    params = OrderedDict([
+        ('batch_size', 256),
+        ('clip_range', get_schedule_fn(0.1)),  # Linear schedule for clip range
+        ('ent_coef', 0.01),
+        ('learning_rate', get_schedule_fn(2.5e-4)),  # Linear schedule for learning rate
+        ('n_epochs', 4),
+        ('n_steps', 128),
+        ('vf_coef', 0.5),
+    ])
+    env_configs = [
+        {"render_mode": None, "observation_type": "pixel", "car_speed": 4},
+        {"render_mode": None, "observation_type": "pixel", "car_speed": 2},
+        {"render_mode": None, "observation_type": "pixel", "car_speed": 4},
+        {"render_mode": None, "observation_type": "pixel", "car_speed": 2},
+    ]
+    log_dir = "./logs/Freeway-CNN-training/"
+
+    # Create a vectorized environment with SubprocVecEnv
+    envs = SubprocVecEnv([make_freeway_env(i, config=env_configs[i]) for i in range(num_envs)])
+
+    wandb.init(
+        project="cnn_atari_freeway",  # Replace with your project name
+        sync_tensorboard=True,           # Automatically sync SB3 logs with wandb
+        monitor_gym=True,                # Automatically log gym environments
+        save_code=True                   # Save the code used for this run
+    )
+    env = FreewayEnv(observation_type="pixel", render_mode=None, car_speed=2)
+    env = Monitor(env, filename=log_dir, allow_early_resets=True)
+    eval_callback = EvalCallback(env, best_model_save_path='./logs/freeway-CNN-eval',
+                                 log_path='./logs/freeway-CNN-eval', eval_freq=5000,
+                                 deterministic=True, render=False)
 
-    env = DummyVecEnv([make_env(i) for i in range(num_envs)])
-    env = FreewayEnv(render_mode='human', observation_type='pixel')
-    # env = DummyVecEnv([lambda: env])    
-    # env = VecFrameStack(env, n_stack=4)
-    
     device = "cuda" if th.cuda.is_available() else "cpu"
-    model = PPO("CnnPolicy", env, verbose=2, device=device)
-    model.learn(total_timesteps=100000)
-    model.save("ppo_freeway_pixel")   
\ No newline at end of file
+
+    model = PPO("CnnPolicy", envs, device=device, verbose=2)
+
+    # SaveOnBestTrainingRewardCallback
+    callback = SaveOnBestTrainingRewardCallback(check_freq=5000, log_dir=log_dir)
+    # wandb_callback = WandbCallback(model_save_path="./models/", model_save_freq=5000, verbose=2)
+
+    model.learn(total_timesteps=1000000, callback=[callback, eval_callback])
+    model.save("ppo_freeway_pixel")
diff --git a/games/freeway/run_supervised_gnn.py b/games/freeway/run_supervised_gnn.py
index 317183e..ad085ae 100644
--- a/games/freeway/run_supervised_gnn.py
+++ b/games/freeway/run_supervised_gnn.py
@@ -1,39 +1,28 @@
+import os
 import wandb
+import numpy as np
 from stable_baselines3 import PPO
 from stable_baselines3.common.env_util import make_vec_env
+from stable_baselines3.common.callbacks import BaseCallback
 from wandb.integration.sb3 import WandbCallback
-#from games.model.policy import CustomActorCriticPolicy
 from games.freeway.freeway_envs.freeway_env import FreewayEnv
-from games.model.policy import CustomCNN, CustomHeteroGNN
-import numpy as np
-import pygame
-# #Initialize wandb
-wandb.init(
-    project="gnn_atari_freeway",  # Replace with your project name
-    sync_tensorboard=True,        # Automatically sync SB3 logs with wandb
-    monitor_gym=True,             # Automatically log gym environments
-    save_code=True                # Save the code used for this run
-)
-
-# wandb.init(
-#     project="cnn_g",  # Replace with your project name
-#     sync_tensorboard=True,        # Automatically sync SB3 logs with wandb
-#     monitor_gym=True,             # Automatically log gym environments
-#     save_code=True                # Save the code used for this run
-# )
-
-# Wrap the environment 
+from games.model.policy import CustomHeteroGNN
+from stable_baselines3.common.vec_env import SubprocVecEnv
+from stable_baselines3.common.monitor import Monitor
+from stable_baselines3.common.callbacks import EvalCallback
+from stable_baselines3.common.monitor import load_results
+from stable_baselines3.common.results_plotter import ts2xy
 
-import os
-from stable_baselines3.common.callbacks import BaseCallback
+log_dir = "./logs/Freeway-GNN-training/"
+os.makedirs(log_dir, exist_ok=True)
 
 class SaveOnBestTrainingRewardCallback(BaseCallback):
-    def __init__(self, check_freq: int, log_dir: str, verbose: int = 1):
+    def __init__(self, check_freq, log_dir, verbose=1):
         super(SaveOnBestTrainingRewardCallback, self).__init__(verbose)
         self.check_freq = check_freq
         self.log_dir = log_dir
-        self.save_path = os.path.join(log_dir, 'best_model')
-        self.best_mean_reward = -float('inf')
+        self.save_path = os.path.join(log_dir, "best_model")
+        self.best_mean_reward = -np.inf
 
     def _init_callback(self) -> None:
         if self.save_path is not None:
@@ -41,61 +30,81 @@ class SaveOnBestTrainingRewardCallback(BaseCallback):
 
     def _on_step(self) -> bool:
         if self.n_calls % self.check_freq == 0:
-            x, y = self.training_env.get_attr('reward')
-            mean_reward = np.mean(y)
-            if self.verbose > 0:
-                print(f"Num timesteps: {self.num_timesteps}")
-                print(f"Best mean reward: {self.best_mean_reward:.2f} - Last mean reward: {mean_reward:.2f}")
-
-            if mean_reward > self.best_mean_reward:
-                self.best_mean_reward = mean_reward
+            x, y = ts2xy(load_results(self.log_dir), "timesteps")
+            if len(x) > 0:
+                mean_reward = np.mean(y[-100:])
                 if self.verbose > 0:
-                    print(f"Saving new best model to {self.save_path}")
-                self.model.save(self.save_path)
-
+                    print(f"Num timesteps: {self.num_timesteps}")
+                    print(f"Best mean reward: {self.best_mean_reward:.2f} - Last mean reward per episode: {mean_reward:.2f}")
+                if mean_reward > self.best_mean_reward:
+                    self.best_mean_reward = mean_reward
+                    if self.verbose > 0:
+                        print(f"Saving new best model at {x[-1]} timesteps")
+                        print(f"Saving new best model to {self.save_path}.zip")
+                    self.model.save(self.save_path)
+                wandb.log({"mean_reward": mean_reward, "timesteps": self.num_timesteps})
+            else:
+                if self.verbose > 0:
+                    print("No data available for logging.")
+                wandb.log({"timesteps": self.num_timesteps})
         return True
-import wandb
-from stable_baselines3 import PPO
-from stable_baselines3.common.env_util import make_vec_env
-from wandb.integration.sb3 import WandbCallback
-#from games.model.policy import CustomActorCriticPolicy
-from games.freeway.freeway_envs.freeway_env import FreewayEnv
-from games.model.policy import CustomCNN, CustomHeteroGNN
-import pygame
-import os
 
-# Initialize wandb
-wandb.init(
-    project="gnn_atari_freeway",  # Replace with your project name
-    sync_tensorboard=True,        # Automatically sync SB3 logs with wandb
-    monitor_gym=True,             # Automatically log gym environments
-    save_code=True                # Save the code used for this run
-)
+def make_env(lanes, max_cars, car_speed, seed=0, rank=None):
+    def _init():
+        env = FreewayEnv(lanes=lanes, max_cars=max_cars, car_speed=car_speed, render_mode='rgb_array', observation_type='graph')
+        monitor_path = os.path.join(log_dir, f"monitor_{rank}.csv")
+        os.makedirs(log_dir, exist_ok=True)  # Create log directory if it doesn't exist
+        env = Monitor(env, filename=monitor_path, allow_early_resets=True)
+        env.seed(seed + rank)
+        return env
+    return _init
 
-# Wrap the environment
-env = FreewayEnv(render_mode='human', observation_type='graph')
+if __name__ == "__main__":
+    # Initialize wandb
+    wandb.init(
+        project="gnn_atari_freeway",  # Replace with your project name
+        sync_tensorboard=True,        # Automatically sync SB3 logs with wandb
+        monitor_gym=True,             # Automatically log gym environments
+        save_code=True                # Save the code used for this run
+    )
 
-policy_kwargs = dict(
-    features_extractor_class=CustomHeteroGNN,
-    features_extractor_kwargs=dict(
-        features_dim=64,
-        hidden_size=64,
-        num_layer=2,
-        obj_type_id='obj',
-        arity_dict={'ChickenOnLane': 2, 'CarOnLane': 2, 'LaneNextToLane': 2},
-        game='freeway'
-    ),
-)
+    # Define environment configurations
+    configs = [
+        {"lanes": [50, 80, 120], "max_cars": 10, "car_speed": 4},
+        {"lanes": [50, 80, 120], "max_cars": 10, "car_speed": 2},
+        {"lanes": [50, 80, 120], "max_cars": 10, "car_speed": 4},
+        {"lanes": [50, 80, 120], "max_cars": 10, "car_speed": 2},
+    ]
 
-# Create the PPO model with the custom feature extractor
-model = PPO('MlpPolicy', env, policy_kwargs=policy_kwargs, verbose=2)
+    # Create the vectorized environment
+    envs = SubprocVecEnv([make_env(config['lanes'], config['max_cars'], config['car_speed'], rank=i) for i, config in enumerate(configs)])
 
-# Set up log directory
-log_dir = "./logs/"
-os.makedirs(log_dir, exist_ok=True)
+    policy_kwargs = dict(
+        features_extractor_class=CustomHeteroGNN,
+        features_extractor_kwargs=dict(
+            features_dim=64,
+            hidden_size=64,
+            num_layer=2,
+            obj_type_id='obj',
+            arity_dict={'ChickenOnLane': 2, 'CarOnLane': 2, 'LaneNextToLane': 2},
+            game='freeway'
+        ),
+    )
+
+    # Create the PPO model with the custom feature extractor
+    model = PPO('MlpPolicy', envs, policy_kwargs=policy_kwargs, verbose=2)
+
+    # Set up the evaluation environment and callback
+    eval_env = FreewayEnv(lanes=[50, 80, 120], max_cars=10, car_speed=4, render_mode='rgb_array', observation_type='graph')
+    eval_env = Monitor(eval_env)  # Apply Monitor wrapper here
+    eval_callback = EvalCallback(eval_env, best_model_save_path='./logs/freeway-GNN-eval',
+                                 log_path='./logs/freeway-GNN-eval', eval_freq=5000,
+                                 deterministic=True, render=False)
+
+    # Create and configure the custom callback
+    save_best_callback = SaveOnBestTrainingRewardCallback(check_freq=1000, log_dir=log_dir)
 
-# Create and configure the custom callback
-save_best_callback = SaveOnBestTrainingRewardCallback(check_freq=1000, log_dir=log_dir)
+    # Train the model with WandbCallback and the custom callback
+    model.learn(total_timesteps=1000000, callback=[WandbCallback(), save_best_callback, eval_callback])
 
-# Train the model with WandbCallback and the custom callback
-model.learn(total_timesteps=1000000, callback=[WandbCallback(), save_best_callback])
+    model.save("ppo_custom_heterognn_freeway")
diff --git a/games/model/__pycache__/cnn_model.cpython-310.pyc b/games/model/__pycache__/cnn_model.cpython-310.pyc
index 9e82db6..aaea007 100644
Binary files a/games/model/__pycache__/cnn_model.cpython-310.pyc and b/games/model/__pycache__/cnn_model.cpython-310.pyc differ
diff --git a/games/model/__pycache__/hetero_gnn.cpython-310.pyc b/games/model/__pycache__/hetero_gnn.cpython-310.pyc
index 7853617..4e78dfa 100644
Binary files a/games/model/__pycache__/hetero_gnn.cpython-310.pyc and b/games/model/__pycache__/hetero_gnn.cpython-310.pyc differ
diff --git a/games/model/__pycache__/hetero_message_passing.cpython-310.pyc b/games/model/__pycache__/hetero_message_passing.cpython-310.pyc
index 243e3b4..2d8f804 100644
Binary files a/games/model/__pycache__/hetero_message_passing.cpython-310.pyc and b/games/model/__pycache__/hetero_message_passing.cpython-310.pyc differ
diff --git a/games/model/__pycache__/policy.cpython-310.pyc b/games/model/__pycache__/policy.cpython-310.pyc
index 18a2c62..a8bcf5c 100644
Binary files a/games/model/__pycache__/policy.cpython-310.pyc and b/games/model/__pycache__/policy.cpython-310.pyc differ
Submodule games/pacman contains modified content
diff --git a/games/pacman/config.py b/games/pacman/config.py
deleted file mode 100644
index 73568ce..0000000
--- a/games/pacman/config.py
+++ /dev/null
@@ -1,40 +0,0 @@
-import pygame, sys, os, random
-from pygame.locals import *
-
-# WIN???
-SCRIPT_PATH=sys.path[0]+"/games/pacman"
-
-# NO_GIF_TILES -- tile numbers which do not correspond to a GIF file
-# currently only "23" for the high-score list
-NO_GIF_TILES=[23]
-
-NO_WX=0 # if set, the high-score code will not attempt to ask the user his name
-USER_NAME="User" # USER_NAME=os.getlogin() # the default user name if wx fails to load or NO_WX
-
-# Joystick defaults - maybe add a Preferences dialog in the future?
-JS_DEVNUM=0 # device 0 (pygame joysticks always start at 0). if JS_DEVNUM is not a valid device, will use 0
-JS_XAXIS=0 # axis 0 for left/right (default for most joysticks)
-JS_YAXIS=1 # axis 1 for up/down (default for most joysticks)
-JS_STARTBUTTON=0 # button number to start the game. this is a matter of personal preference, and will vary from device to device
-
-# Must come before pygame.init()
-pygame.mixer.pre_init(22050,16,2,512)
-JS_STARTBUTTON=0 # button number to start the game. this is a matter of personal preference, and will vary from device to device
-pygame.mixer.init()
-
-clock = pygame.time.Clock()
-pygame.init()
-
-window = pygame.display.set_mode((1, 1))
-pygame.display.set_caption("Pacman")
-
-screen = pygame.display.get_surface()
-
-# set up the colors 
-ghostcolor = {}
-ghostcolor[0] = (255, 0, 0, 255)
-ghostcolor[1] = (255, 128, 255, 255)
-ghostcolor[2] = (128, 255, 255, 255)
-ghostcolor[3] = (255, 128, 0, 255)
-ghostcolor[4] = (50, 50, 255, 255) # blue, vulnerable ghost
-ghostcolor[5] = (255, 255, 255, 255) # white, flashing ghost
\ No newline at end of file
diff --git a/games/pacman/fruit.py b/games/pacman/fruit.py
deleted file mode 100644
index 51e2b1c..0000000
--- a/games/pacman/fruit.py
+++ /dev/null
@@ -1,112 +0,0 @@
-from games.pacman.config import *
-
-class fruit ():
-    def __init__ (self):
-        # when fruit is not in use, it's in the (-1, -1) position off-screen.
-        self.slowTimer = 0
-        self.x = -16
-        self.y = -16
-        self.velX = 0
-        self.velY = 0
-        self.speed = 1
-        self.active = False
-        #self.thisGame = thisGame
-        
-        self.bouncei = 0
-        self.bounceY = 0
-        
-        self.nearestRow = (-1, -1)
-        self.nearestCol = (-1, -1)
-        
-        self.imFruit = {}
-        for i in range(0, 5, 1):
-            self.imFruit[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","fruit " + str(i) + ".gif")).convert()
-        
-        self.currentPath = ""
-        self.fruitType = 1
-        
-    def Draw (self, thisGame):
-        
-        if thisGame.mode == 3 or self.active == False:
-            return False
-        
-        screen.blit (self.imFruit[ self.fruitType ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1] - self.bounceY))
-
-            
-    def Move (self, thisGame):
-        
-        if self.active == False:
-            return False
-        
-        self.bouncei += 1
-        if self.bouncei == 1:
-            self.bounceY = 2
-        elif self.bouncei == 2:
-            self.bounceY = 4
-        elif self.bouncei == 3:
-            self.bounceY = 5
-        elif self.bouncei == 4:
-            self.bounceY = 5
-        elif self.bouncei == 5:
-            self.bounceY = 6
-        elif self.bouncei == 6:
-            self.bounceY = 6
-        elif self.bouncei == 9:
-            self.bounceY = 6
-        elif self.bouncei == 10:
-            self.bounceY = 5
-        elif self.bouncei == 11:
-            self.bounceY = 5
-        elif self.bouncei == 12:
-            self.bounceY = 4
-        elif self.bouncei == 13:
-            self.bounceY = 3
-        elif self.bouncei == 14:
-            self.bounceY = 2
-        elif self.bouncei == 15:
-            self.bounceY = 1
-        elif self.bouncei == 16:
-            self.bounceY = 0
-            self.bouncei = 0
-            #snd_fruitbounce.play()
-        
-        self.slowTimer += 1
-        if self.slowTimer == 2:
-            self.slowTimer = 0
-            
-            self.x += self.velX
-            self.y += self.velY
-            
-            self.nearestRow = int(((self.y + 8) / 16))
-            self.nearestCol = int(((self.x + 8) / 16))
-
-            if (self.x % 16) == 0 and (self.y % 16) == 0:
-                # if the fruit is lined up with the grid again
-                # meaning, it's time to go to the next path item
-                
-                if len(self.currentPath) > 0:
-                    self.currentPath = self.currentPath[1:]
-                    self.FollowNextPathWay()
-            
-                else:
-                    self.x = self.nearestCol * 16
-                    self.y = self.nearestRow * 16
-                    
-                    self.active = False
-                    thisGame.fruitTimer = 0
-            
-    def FollowNextPathWay (self):
-        
-
-        # only follow this pathway if there is a possible path found!
-        if not self.currentPath == False:
-        
-            if len(self.currentPath) > 0:
-                if self.currentPath[0] == "L":
-                    (self.velX, self.velY) = (-self.speed, 0)
-                elif self.currentPath[0] == "R":
-                    (self.velX, self.velY) = (self.speed, 0)
-                elif self.currentPath[0] == "U":
-                    (self.velX, self.velY) = (0, -self.speed)
-                elif self.currentPath[0] == "D":
-                    (self.velX, self.velY) = (0, self.speed)
diff --git a/games/pacman/game.py b/games/pacman/game.py
deleted file mode 100644
index 334c813..0000000
--- a/games/pacman/game.py
+++ /dev/null
@@ -1,214 +0,0 @@
-from games.pacman.config import *
-import os
-import pygame
-
-class game ():
-
-    def defaulthiscorelist(self):
-            return [ (100000,"David") , (80000,"Andy") , (60000,"Count Pacula") , (40000,"Cleopacra") , (20000,"Brett Favre") , (10000,"Sergei Pachmaninoff") ]
-
-    def gethiscores(self):
-            """If res/hiscore.txt exists, read it. If not, return the default high scores.
-               Output is [ (score,name) , (score,name) , .. ]. Always 6 entries."""
-            try:
-              f=open(os.path.join(SCRIPT_PATH,"res","hiscore.txt"))
-              hs=[]
-              for line in f:
-                while len(line)>0 and (line[0]=="\n" or line[0]=="\r"): line=line[1:]
-                while len(line)>0 and (line[-1]=="\n" or line[-1]=="\r"): line=line[:-1]
-                score=int(line.split(" ")[0])
-                name=line.partition(" ")[2]
-                if score>99999999: score=99999999
-                if len(name)>22: name=name[:22]
-                hs.append((score,name))
-              f.close()
-              if len(hs)>6: hs=hs[:6]
-              while len(hs)<6: hs.append((0,""))
-              return hs
-            except IOError:
-              return self.defaulthiscorelist()
-              
-    def writehiscores(self,hs):
-            """Given a new list, write it to the default file."""
-            fname=os.path.join(SCRIPT_PATH,"res","hiscore.txt")
-            f=open(fname,"w")
-            for line in hs:
-              f.write(str(line[0])+" "+line[1]+"\n")
-            f.close()
-            
-    def getplayername(self):
-            """Ask the player his name, to go on the high-score list."""
-            if NO_WX: return USER_NAME
-            try:
-              import wx
-            except:
-              print("Pacman Error: No module wx. Can not ask the user his name!")
-              print( "     :(       Download wx from http://www.wxpython.org/")
-              print( "     :(       To avoid seeing this error again, set NO_WX in file pacman.pyw.")
-              return USER_NAME
-            app=wx.App(None)
-            dlog=wx.TextEntryDialog(None,"You made the high-score list! Name:")
-            dlog.ShowModal()
-            name=dlog.GetValue()
-            dlog.Destroy()
-            app.Destroy()
-            return name
-              
-    def updatehiscores(self,newscore):
-            """Add newscore to the high score list, if appropriate."""
-            hs=self.gethiscores()
-            for line in hs:
-              if newscore>=line[0]:
-                hs.insert(hs.index(line),(newscore,self.getplayername()))
-                hs.pop(-1)
-                break
-            self.writehiscores(hs)
-
-    def makehiscorelist(self):
-            "Read the High-Score file and convert it to a useable Surface."
-            # My apologies for all the hard-coded constants.... -Andy
-            f=pygame.font.Font(os.path.join(SCRIPT_PATH,"res","VeraMoBd.ttf"),10)
-            scoresurf=pygame.Surface((276,86),pygame.SRCALPHA)
-            scoresurf.set_alpha(200)
-            linesurf=f.render(" "*18+"HIGH SCORES",1,(255,255,0))
-            scoresurf.blit(linesurf,(0,0))
-            hs=self.gethiscores()
-            vpos=0
-            for line in hs:
-              vpos+=12
-              linesurf=f.render(line[1].rjust(22)+str(line[0]).rjust(9),1,(255,255,255))
-              scoresurf.blit(linesurf,(0,vpos))
-            return scoresurf
-            
-    def drawmidgamehiscores(self):
-            """Redraw the high-score list image after pacman dies."""
-            self.imHiscores=self.makehiscorelist()
-
-    def __init__ (self, thisFruit, player, screen):
-        self.player = player
-        self.screen = screen
-        self.thisFruit = thisFruit
-        self.levelNum = 0
-        self.score = 0
-        self.lives = 3
-        
-        # game "mode" variable
-        # 1 = normal
-        # 2 = hit ghost
-        # 3 = game over
-        # 4 = wait to start
-        # 5 = wait after eating ghost
-        # 6 = wait after finishing level
-        self.mode = 0
-        self.modeTimer = 0
-        self.ghostTimer = 0
-        self.ghostValue = 0
-        self.fruitTimer = 0
-        self.fruitScoreTimer = 0
-        self.fruitScorePos = (0, 0)
-        
-        self.SetMode( 4 )
-        
-        # camera variables
-        self.screenPixelPos = (0, 0) # absolute x,y position of the screen from the upper-left corner of the level
-        self.screenNearestTilePos = (0, 0) # nearest-tile position of the screen from the UL corner
-        self.screenPixelOffset = (0, 0) # offset in pixels of the screen from its nearest-tile position
-        
-        self.screenTileSize = (23, 21)
-        self.screenSize = (self.screenTileSize[1] * 16, self.screenTileSize[0] * 16)
-
-        # numerical display digits
-        self.digit = {}
-        for i in range(0, 10, 1):
-            self.digit[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","text",str(i) + ".gif")).convert()
-        self.imLife = pygame.image.load(os.path.join(SCRIPT_PATH,"res","text","life.gif")).convert()
-        self.imGameOver = pygame.image.load(os.path.join(SCRIPT_PATH,"res","text","gameover.gif")).convert()
-        self.imReady = pygame.image.load(os.path.join(SCRIPT_PATH,"res","text","ready.gif")).convert()
-        self.imLogo = pygame.image.load(os.path.join(SCRIPT_PATH,"res","text","logo.gif")).convert()
-        self.imHiscores = self.makehiscorelist()
-        
-    def StartNewGame (self, thisLevel, tileID, tileIDImage, tileIDName):
-        self.levelNum = 1
-        self.score = 0
-        self.lives = 3
-        
-        self.SetMode( 1 )
-        thisLevel.LoadLevel( self.GetLevelNum(), tileID, tileIDImage , tileIDName)
-            
-    def AddToScore (self, amount):
-        
-        extraLifeSet = [25000, 50000, 100000, 150000]
-        
-        for specialScore in extraLifeSet:
-            if self.score < specialScore and self.score + amount >= specialScore:
-                #snd_extralife.play()
-                self.lives += 1
-        
-        self.score += amount
-        
-    
-    def DrawScore (self):
-        self.DrawNumber (self.score, 24 + 16, self.screenSize[1] - 24 )
-            
-        for i in range(0, self.lives, 1):
-            screen.blit (self.imLife, (24 + i * 10 + 16, self.screenSize[1] - 12) )
-            
-        screen.blit (self.thisFruit.imFruit[ self.thisFruit.fruitType ], (4 + 16, self.screenSize[1] - 20) )
-            
-        if self.mode == 3:
-            screen.blit (self.imGameOver, (self.screenSize[0] / 2 - 32, self.screenSize[1] / 2 - 10) )
-        elif self.mode == 4:
-            screen.blit (self.imReady, (self.screenSize[0] / 2 - 20, self.screenSize[1] / 2 + 12) )
-            
-        self.DrawNumber (self.levelNum, 0, self.screenSize[1] - 12 )
-            
-    def DrawNumber (self, number, x, y):
-        strNumber = str(int(number))
-        for i in range(0, len(strNumber), 1):
-            iDigit = int(strNumber[i])
-            screen.blit (self.digit[ iDigit ], (x + i * 9, y) )
-        
-    def SmartMoveScreen (self, thisLevel):
-            
-        possibleScreenX = self.player.x - self.screenTileSize[1] / 2 * 16
-        possibleScreenY = self.player.y - self.screenTileSize[0] / 2 * 16
-        
-        if possibleScreenX < 0:
-            possibleScreenX = 0
-        elif possibleScreenX > thisLevel.lvlWidth * 16 - self.screenSize[0]:
-            possibleScreenX = thisLevel.lvlWidth * 16 - self.screenSize[0]
-            
-        if possibleScreenY < 0:
-            possibleScreenY = 0
-        elif possibleScreenY > thisLevel.lvlHeight * 16 - self.screenSize[1]:
-            possibleScreenY = thisLevel.lvlHeight * 16 - self.screenSize[1]
-        
-        self.MoveScreen( possibleScreenX, possibleScreenY )
-        
-    def MoveScreen (self, newX, newY ):
-        self.screenPixelPos = (newX, newY)
-        self.screenNearestTilePos = (int(newY / 16), int(newX / 16)) # nearest-tile position of the screen from the UL corner
-        self.screenPixelOffset = (newX - self.screenNearestTilePos[1]*16, newY - self.screenNearestTilePos[0]*16)
-        
-    def GetScreenPos (self):
-        return self.screenPixelPos
-        
-    def GetLevelNum (self):
-        return self.levelNum
-    
-    def SetNextLevel (self):
-        self.levelNum += 1
-        
-        self.SetMode( 4 )
-        self.thisLevel.LoadLevel( self.thisGame.GetLevelNum() )
-        
-        self.player.velX = 0
-        self.player.velY = 0
-        self.player.anim_pacmanCurrent = self.player.anim_pacmanS
-        
-        
-    def SetMode (self, newMode):
-        self.mode = newMode
-        self.modeTimer = 0
-        # print " ***** GAME MODE IS NOW ***** " + str(newMode)
-        
\ No newline at end of file
diff --git a/games/pacman/ghost.py b/games/pacman/ghost.py
deleted file mode 100644
index 628eb75..0000000
--- a/games/pacman/ghost.py
+++ /dev/null
@@ -1,174 +0,0 @@
-from games.pacman.config import *
-
-class ghost ():
-    def __init__ (self, ghostID, path, screen, player):
-        self.player = player
-        self.screen = screen
-        self.path = path
-        self.x = 0
-        self.y = 0
-        self.velX = 0
-        self.velY = 0
-        self.speed = 1
-        self.ghostTimer = 0
-        self.nearestRow = 0
-        self.nearestCol = 0
-        
-        self.id = ghostID
-        
-        # ghost "state" variable
-        # 1 = normal
-        # 2 = vulnerable
-        # 3 = spectacles
-        self.state = 1
-        
-        self.homeX = 0
-        self.homeY = 0
-        
-        self.currentPath = ""
-        
-        self.anim = {}
-        for i in range(1, 7, 1):
-            self.anim[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","ghost " + str(i) + ".gif")).convert()
-            
-            # change the ghost color in this frame
-            for y in range(0, 16, 1):
-                for x in range(0, 16, 1):
-                
-                    if self.anim[i].get_at( (x, y) ) == (255, 0, 0, 255):
-                        # default, red ghost body color
-                        self.anim[i].set_at( (x, y), ghostcolor[ self.id ] )
-            
-        self.animFrame = 1
-        self.animDelay = 0
-        
-    def Draw (self, thisGame, tileID, tileIDImage, ghosts):
-        
-        if thisGame.mode == 3:
-            return False
-        
-        
-        # ghost eyes --
-        for y in range(4, 8, 1):
-            for x in range(3, 7, 1):
-                self.anim[ self.animFrame ].set_at( (x, y), (255, 255, 255, 255) )  
-                self.anim[ self.animFrame ].set_at( (x+6, y), (255, 255, 255, 255) )
-                
-                if self.player.x > self.x and self.player.y > self.y:
-                    #player is to lower-right
-                    pupilSet = (5, 6)
-                elif self.player.x < self.x and self.player.y > self.y:
-                    #player is to lower-left
-                    pupilSet = (3, 6)
-                elif self.player.x > self.x and self.player.y < self.y:
-                    #player is to upper-right
-                    pupilSet = (5, 4)
-                elif self.player.x < self.x and self.player.y < self.y:
-                    #player is to upper-left
-                    pupilSet = (3, 4)
-                else:
-                    pupilSet = (4, 6)
-                    
-        for y in range(pupilSet[1], pupilSet[1] + 2, 1):
-            for x in range(pupilSet[0], pupilSet[0] + 2, 1):
-                self.anim[ self.animFrame ].set_at( (x, y), (0, 0, 255, 255) )  
-                self.anim[ self.animFrame ].set_at( (x+6, y), (0, 0, 255, 255) )    
-        # -- end ghost eyes
-        
-        if self.state == 1:
-            # draw regular ghost (this one)
-            self.screen.blit (self.anim[ self.animFrame ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
-        elif self.state == 2:
-            # draw vulnerable ghost
-            
-            if thisGame.ghostTimer > 100:
-                # blue
-                screen.blit (ghosts[4].anim[ self.animFrame ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
-            else:
-                # blue/white flashing
-                tempTimerI = int(thisGame.ghostTimer / 10)
-                if tempTimerI == 1 or tempTimerI == 3 or tempTimerI == 5 or tempTimerI == 7 or tempTimerI == 9:
-                    screen.blit (ghosts[5].anim[ self.animFrame ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
-                else:
-                    screen.blit (ghosts[4].anim[ self.animFrame ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
-            
-        elif self.state == 3:
-            # draw glasses
-            self.screen.blit (tileIDImage[ tileID[ 'glasses' ] ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
-        
-        if thisGame.mode == 6 or thisGame.mode == 7:
-            # don't animate ghost if the level is complete
-            return False
-        
-        self.animDelay += 1
-        
-        if self.animDelay == 2:
-            self.animFrame += 1 
-        
-            if self.animFrame == 7:
-                # wrap to beginning
-                self.animFrame = 1
-                
-            self.animDelay = 0
-            
-    def Move (self, thisLevel, tileID):
-        
-
-        self.x += self.velX
-        self.y += self.velY
-        
-        self.nearestRow = int(((self.y + 8) / 16))
-        self.nearestCol = int(((self.x + 8) / 16))
-
-        if (self.x % 16) == 0 and (self.y % 16) == 0:
-            # if the ghost is lined up with the grid again
-            # meaning, it's time to go to the next path item
-            
-            if (self.currentPath):
-                self.currentPath = self.currentPath[1:]
-                self.FollowNextPathWay(thisLevel, tileID)
-        
-            else:
-                self.x = self.nearestCol * 16
-                self.y = self.nearestRow * 16
-            
-                # chase pac-man
-                self.currentPath = self.path.FindPath( (self.nearestRow, self.nearestCol), (self.player.nearestRow, self.player.nearestCol) )
-                self.FollowNextPathWay(thisLevel, tileID)
-            
-    def FollowNextPathWay(self, thisLevel, tileID, counter=0, max_recursion_depth=900):
-        # Stop recursion if the maximum depth is reached
-        if counter >= max_recursion_depth:
-            return
-
-        # only follow this pathway if there is a possible path found!
-        if not self.currentPath == False:
-            if len(self.currentPath) > 0:
-                if self.currentPath[0] == "L":
-                    (self.velX, self.velY) = (-self.speed, 0)
-                elif self.currentPath[0] == "R":
-                    (self.velX, self.velY) = (self.speed, 0)
-                elif self.currentPath[0] == "U":
-                    (self.velX, self.velY) = (0, -self.speed)
-                elif self.currentPath[0] == "D":
-                    (self.velX, self.velY) = (0, self.speed)
-            else:
-                # this ghost has reached his destination!!
-                if not self.state == 3:
-                    # chase pac-man
-                    self.currentPath = self.path.FindPath((self.nearestRow, self.nearestCol), (self.player.nearestRow, self.player.nearestCol))
-                    self.FollowNextPathWay(thisLevel, tileID, counter+1) 
-                else:
-                    # glasses found way back to ghost box
-                    self.state = 1
-                    self.speed = self.speed / 4
-
-                    # give ghost a path to a random spot (containing a pellet)
-                    (randRow, randCol) = (0, 0)
-
-                    while not thisLevel.GetMapTile(randRow, randCol) == tileID['pellet'] or (randRow, randCol) == (0, 0):
-                        randRow = random.randint(1, thisLevel.lvlHeight - 2)
-                        randCol = random.randint(1, thisLevel.lvlWidth - 2)
-
-                    self.currentPath = self.path.FindPath((self.nearestRow, self.nearestCol), (randRow, randCol))
-                    self.FollowNextPathWay(thisLevel, tileID, counter+1)
\ No newline at end of file
diff --git a/games/pacman/images/blue.png b/games/pacman/images/blue.png
deleted file mode 100644
index c633636..0000000
Binary files a/games/pacman/images/blue.png and /dev/null differ
diff --git a/games/pacman/images/pacman.png b/games/pacman/images/pacman.png
deleted file mode 100644
index d005d4d..0000000
Binary files a/games/pacman/images/pacman.png and /dev/null differ
diff --git a/games/pacman/images/pink.png b/games/pacman/images/pink.png
deleted file mode 100644
index 9614f58..0000000
Binary files a/games/pacman/images/pink.png and /dev/null differ
diff --git a/games/pacman/images/play.png b/games/pacman/images/play.png
deleted file mode 100644
index 05842b1..0000000
Binary files a/games/pacman/images/play.png and /dev/null differ
diff --git a/games/pacman/images/red.png b/games/pacman/images/red.png
deleted file mode 100644
index 5c5ea84..0000000
Binary files a/games/pacman/images/red.png and /dev/null differ
diff --git a/games/pacman/images/win.png b/games/pacman/images/win.png
deleted file mode 100644
index 728ccdf..0000000
Binary files a/games/pacman/images/win.png and /dev/null differ
diff --git a/games/pacman/images/yellow.png b/games/pacman/images/yellow.png
deleted file mode 100644
index 8db5a0a..0000000
Binary files a/games/pacman/images/yellow.png and /dev/null differ
diff --git a/games/pacman/level.py b/games/pacman/level.py
deleted file mode 100644
index b5153ee..0000000
--- a/games/pacman/level.py
+++ /dev/null
@@ -1,471 +0,0 @@
-from games.pacman.config import *
-
-class level ():
-    
-    def __init__ (self, game, player, ghosts, path, Fruit, screen):
-        self.player = player
-        self.ghosts = ghosts
-        self.path = path
-        self.thisFruit = Fruit
-        self.lvlWidth = 0
-        self.lvlHeight = 0
-        self.edgeLightColor = (255, 255, 0, 255)
-        self.edgeShadowColor = (255, 150, 0, 255)
-        self.fillColor = (0, 255, 255, 255)
-        self.pelletColor = (255, 255, 255, 255)
-        self.thisLevel = level
-        # self.snd_pellet = snd_pellet
-        # self.snd_powerpellet = snd_powerpellet
-        self.map = {}
-        self.thisGame = game
-        self.pellets = 0
-        self.powerPelletBlinkTimer = 0
-        self.screen = screen
-        
-    def SetMapTile (self, row, col, newValue):
-        self.map[ (row * self.lvlWidth) + col ] = newValue
-        
-    def GetMapTile (self, row, col):
-        if row >= 0 and row < self.lvlHeight and col >= 0 and col < self.lvlWidth:
-            return self.map[ (row * self.lvlWidth) + col ]
-        else:
-            return 0
-    
-    def IsWall (self, row, col):
-    
-        if row > self.lvlHeight - 1 or row < 0:
-            return True
-        
-        if col > self.lvlWidth - 1 or col < 0:
-            return True
-    
-        # check the offending tile ID
-        result = self.GetMapTile(row, col)
-
-        # if the tile was a wall
-        if result >= 100 and result <= 199:
-            return True
-        else:
-            return False
-    
-    def GetWallLocations(self):
-        wallLocations = []
-        for row in range(self.lvlHeight):
-            for col in range(self.lvlWidth):
-                if self.IsWall(row, col):
-                    wallLocations.append((row, col))
-        return wallLocations 
-    
-    def GetPelletLocations(self):
-        pelletLocations = []
-        for row in range(self.lvlHeight):
-            for col in range(self.lvlWidth):
-                if self.GetMapTile(row, col) == 2:
-                    pelletLocations.append((row*16, col*16))
-        return pelletLocations
-    
-    def GetPowerPelletLocations(self):
-        powerPelletLocations = []
-        for row in range(self.lvlHeight):
-            for col in range(self.lvlWidth):
-                if self.GetMapTile(row, col) == 3:
-                    powerPelletLocations.append((row, col))
-        return powerPelletLocations
-    
-
-                    
-    def CheckIfHitWall (self, possiblePlayerX, possiblePlayerY, row, col):
-    
-        numCollisions = 0
-        
-        # check each of the 9 surrounding tiles for a collision
-        for iRow in range(row - 1, row + 2, 1):
-            for iCol in range(col - 1, col + 2, 1):
-            
-                if  (possiblePlayerX - (iCol * 16) < 16) and (possiblePlayerX - (iCol * 16) > -16) and (possiblePlayerY - (iRow * 16) < 16) and (possiblePlayerY - (iRow * 16) > -16):
-                    
-                    if self.IsWall(iRow, iCol):
-                        numCollisions += 1
-                        
-        if numCollisions > 0:
-            return True
-        else:
-            return False
-        
-        
-    def CheckIfHit (self, playerX, playerY, x, y, cushion):
-    
-        if (playerX - x < cushion) and (playerX - x > -cushion) and (playerY - y < cushion) and (playerY - y > -cushion):
-            return True
-        else:
-            return False
-        
-    # check if player has hit a pellet, powerpellet or a wall
-    def CheckIfHit(self, playerX, playerY, row, col, tileID):
-        
-            for iRow in range(row - 1, row + 2, 1):
-                for iCol in range(col - 1, col + 2, 1):
-                
-                    if  (playerX - (iCol * 16) < 16) and (playerX - (iCol * 16) > -16) and (playerY - (iRow * 16) < 16) and (playerY - (iRow * 16) > -16):
-                        # check the offending tile ID
-                        result = self.GetMapTile(iRow, iCol)
-            
-                        if result == tileID:
-                            return True   
-                        elif result >= 100 and result <= 199:
-                            return True
-                        else:
-                            return False
-
-
-    def CheckIfHitSomething (self, playerX, playerY, row, col, tileID):
-    
-        for iRow in range(row - 1, row + 2, 1):
-            for iCol in range(col - 1, col + 2, 1):
-            
-                if  (playerX - (iCol * 16) < 16) and (playerX - (iCol * 16) > -16) and (playerY - (iRow * 16) < 16) and (playerY - (iRow * 16) > -16):
-                    # check the offending tile ID
-                    result = self.GetMapTile(iRow, iCol)
-        
-                    if result == tileID[ 'pellet' ]:
-                        # got a pellet
-                        self.SetMapTile(iRow, iCol, 0)
-                        #self.snd_pellet[self.player.pelletSndNum].play()
-                        self.player.pelletSndNum = 1 - self.player.pelletSndNum
-                        
-                        self.pellets -= 1
-                        
-                        self.thisGame.AddToScore(10)
-                        
-                        if self.pellets == 0:
-                            # no more pellets left!
-                            # WON THE LEVEL
-                            self.thisGame.SetMode( 6 )
-                            
-                        
-                    elif result == tileID[ 'pellet-power' ]:
-                        # got a power pellet
-                        self.SetMapTile(iRow, iCol, 0)
-                        #self.snd_powerpellet.play()
-                        
-                        self.thisGame.AddToScore(100)
-                        self.thisGame.ghostValue = 200
-                        
-                        self.thisGame.ghostTimer = 360
-                        for i in range(0, 4, 1):
-                            if self.ghosts[i].state == 1:
-                                self.ghosts[i].state = 2
-                        
-                    elif result == tileID[ 'door-h' ]:
-                        # ran into a horizontal door
-                        for i in range(0, self.thisLevel.lvlWidth, 1):
-                            if not i == iCol:
-                                if self.thisLevel.GetMapTile(iRow, i) == tileID[ 'door-h' ]:
-                                    self.player.x = i * 16
-                                    
-                                    if self.player.velX > 0:
-                                        self.player.x += 16
-                                    else:
-                                        self.player.x -= 16
-                                        
-                    elif result == tileID[ 'door-v' ]:
-                        # ran into a vertical door
-                        for i in range(0, self.thisLevel.lvlHeight, 1):
-                            if not i == iRow:
-                                if self.thisLevel.GetMapTile(i, iCol) == tileID[ 'door-v' ]:
-                                    self.player.y = i * 16
-                                    
-                                    if self.player.velY > 0:
-                                        self.player.y += 16
-                                    else:
-                                        self.player.y -= 16
-                                        
-    def GetGhostBoxPos (self, tileID):
-        
-        for row in range(0, self.lvlHeight, 1):
-            for col in range(0, self.lvlWidth, 1):
-                if self.GetMapTile(row, col) == tileID[ 'ghost-door' ]:
-                    return (row, col)
-                
-        return False
-    
-    def GetPathwayPairPos (self,  tileID):
-        
-        doorArray = []
-        
-        for row in range(0, self.lvlHeight, 1):
-            for col in range(0, self.lvlWidth, 1):
-                if self.GetMapTile(row, col) == tileID[ 'door-h' ]:
-                    # found a horizontal door
-                    doorArray.append( (row, col) )
-                elif self.GetMapTile(row, col) == tileID[ 'door-v' ]:
-                    # found a vertical door
-                    doorArray.append( (row, col) )
-        
-        if len(doorArray) == 0:
-            return False
-        
-        chosenDoor = random.randint(0, len(doorArray) - 1)
-        
-        if self.GetMapTile( doorArray[chosenDoor][0],doorArray[chosenDoor][1] ) == tileID[ 'door-h' ]:
-            # horizontal door was chosen
-            # look for the opposite one
-            for i in range(0, self.lvlWidth, 1):
-                if not i == doorArray[chosenDoor][1]:
-                    if self.GetMapTile(doorArray[chosenDoor][0], i) == tileID[ 'door-h' ]:
-                        return doorArray[chosenDoor], (doorArray[chosenDoor][0], i)
-        else:
-            # vertical door was chosen
-            # look for the opposite one
-            for i in range(0, self.lvlHeight, 1):
-                if not i == doorArray[chosenDoor][0]:
-                    if self.GetMapTile(i, doorArray[chosenDoor][1]) == tileID[ 'door-v' ]:
-                        return doorArray[chosenDoor], (i, doorArray[chosenDoor][1])
-                    
-        return False
-        
-    def PrintMap (self):
-        
-        for row in range(0, self.lvlHeight, 1):
-            outputLine = ""
-            for col in range(0, self.lvlWidth, 1):
-            
-                outputLine += str( self.GetMapTile(row, col) ) + ", "
-                
-            # print outputLine
-            
-    def DrawMap (self, tileID, tileIDImage):
-        
-        self.powerPelletBlinkTimer += 1
-        if self.powerPelletBlinkTimer == 60:
-            self.powerPelletBlinkTimer = 0
-        
-        for row in range(-1, self.thisGame.screenTileSize[0] +1, 1):
-            outputLine = ""
-            for col in range(-1, self.thisGame.screenTileSize[1] +1, 1):
-
-                # row containing tile that actually goes here
-                actualRow = self.thisGame.screenNearestTilePos[0] + row
-                actualCol = self.thisGame.screenNearestTilePos[1] + col
-
-                useTile = self.GetMapTile(actualRow, actualCol)
-                if not useTile == 0 and not useTile == tileID['door-h'] and not useTile == tileID['door-v']:
-                    # if this isn't a blank tile
-
-                    if useTile == tileID['pellet-power']:
-                        if self.powerPelletBlinkTimer < 30:
-                            self.screen.blit (tileIDImage[ useTile ], (col * 16 - self.thisGame.screenPixelOffset[0], row * 16 - self.thisGame.screenPixelOffset[1]) )
-
-                    elif useTile == tileID['showlogo']:
-                        self.screen.blit (self.thisGame.imLogo, (col * 16 - self.thisGame.screenPixelOffset[0], row * 16 - self.thisGame.screenPixelOffset[1]) )
-                    
-                    elif useTile == tileID['hiscores']:
-                        self.screen.blit(self.thisGame.imHiscores,(col*16-self.thisGame.screenPixelOffset[0],row*16-self.thisGame.screenPixelOffset[1]))
-                    
-              
-                    else:
-                        self.screen.blit (tileIDImage[ useTile ], (col * 16 - self.thisGame.screenPixelOffset[0], row * 16 - self.thisGame.screenPixelOffset[1]) )
-    
-    
-    def GetCrossRef(self, tileIDName, tileID, tileIDImage):
-        for key, value in tileIDName.items():
-            thisID = key
-            if thisID not in NO_GIF_TILES:
-                tileIDImage[thisID] = pygame.image.load(os.path.join(SCRIPT_PATH, "res", "tiles", value + ".gif")).convert()
-            else:
-                tileIDImage[thisID] = pygame.Surface((16, 16))
-
-            # Change colors in tileIDImage to match maze colors
-            for y in range(16):
-                for x in range(16):
-                    current_color = tileIDImage[thisID].get_at((x, y))
-                    if current_color == (255, 206, 255, 255):
-                        tileIDImage[thisID].set_at((x, y), self.edgeLightColor)
-                    elif current_color == (132, 0, 132, 255):
-                        tileIDImage[thisID].set_at((x, y), self.fillColor)
-                    elif current_color == (255, 0, 255, 255):
-                        tileIDImage[thisID].set_at((x, y), self.edgeShadowColor)
-                    elif current_color == (128, 0, 128, 255):
-                        tileIDImage[thisID].set_at((x, y), self.pelletColor)
-
-
-
-    def LoadLevel (self, levelNum, tileID, tileIDImage, tileIDName):
-        
-        self.map = {}
-        
-        self.pellets = 0
-        
-        f = open(os.path.join(SCRIPT_PATH,"res","levels",str(levelNum) + ".txt"), 'r')
-        # ANDY -- edit this
-        #fileOutput = f.read()
-        #str_splitByLine = fileOutput.split('\n')
-        lineNum=-1
-        rowNum = 0
-        useLine = False
-        isReadingLevelData = False
-          
-        for line in f:
-
-          lineNum += 1
-        
-            # print " ------- Level Line " + str(lineNum) + " -------- "
-          while len(line)>0 and (line[-1]=="\n" or line[-1]=="\r"): line=line[:-1]
-          while len(line)>0 and (line[0]=="\n" or line[0]=="\r"): line=line[1:]
-          str_splitBySpace = line.split(' ')
-            
-            
-          j = str_splitBySpace[0]
-                
-          if (j == "'" or j == ""):
-                # comment / whitespace line
-                # print " ignoring comment line.. "
-                useLine = False
-          elif j == "#":
-                # special divider / attribute line
-                useLine = False
-                
-                firstWord = str_splitBySpace[1]
-                
-                if firstWord == "lvlwidth":
-                    self.lvlWidth = int( str_splitBySpace[2] )
-                    # print "Width is " + str( self.lvlWidth )
-                    
-                elif firstWord == "lvlheight":
-                    self.lvlHeight = int( str_splitBySpace[2] )
-                    # print "Height is " + str( self.lvlHeight )
-                    
-                elif firstWord == "edgecolor":
-                    # edge color keyword for backwards compatibility (single edge color) mazes
-                    red = int( str_splitBySpace[2] )
-                    green = int( str_splitBySpace[3] )
-                    blue = int( str_splitBySpace[4] )
-                    self.edgeLightColor = (red, green, blue, 255)
-                    self.edgeShadowColor = (red, green, blue, 255)
-                    
-                elif firstWord == "edgelightcolor":
-                    red = int( str_splitBySpace[2] )
-                    green = int( str_splitBySpace[3] )
-                    blue = int( str_splitBySpace[4] )
-                    self.edgeLightColor = (red, green, blue, 255)
-                    
-                elif firstWord == "edgeshadowcolor":
-                    red = int( str_splitBySpace[2] )
-                    green = int( str_splitBySpace[3] )
-                    blue = int( str_splitBySpace[4] )
-                    self.edgeShadowColor = (red, green, blue, 255)
-                
-                elif firstWord == "fillcolor":
-                    red = int( str_splitBySpace[2] )
-                    green = int( str_splitBySpace[3] )
-                    blue = int( str_splitBySpace[4] )
-                    self.fillColor = (red, green, blue, 255)
-                    
-                elif firstWord == "pelletcolor":
-                    red = int( str_splitBySpace[2] )
-                    green = int( str_splitBySpace[3] )
-                    blue = int( str_splitBySpace[4] )
-                    self.pelletColor = (red, green, blue, 255)
-                    
-                elif firstWord == "fruittype":
-                    self.thisFruit.fruitType = int( str_splitBySpace[2] )
-                    
-                elif firstWord == "startleveldata":
-                    isReadingLevelData = True
-                        # print "Level data has begun"
-                    rowNum = 0
-                    
-                elif firstWord == "endleveldata":
-                    isReadingLevelData = False
-                    # print "Level data has ended"
-                    
-          else:
-                useLine = True
-                
-                
-            # this is a map data line   
-          if useLine == True:
-                
-                if isReadingLevelData == True:
-                        
-                    # print str( len(str_splitBySpace) ) + " tiles in this column"
-                    
-                    for k in range(0, self.lvlWidth, 1):
-                        self.SetMapTile(rowNum, k, int(str_splitBySpace[k]) )
-                        
-                        thisID = int(str_splitBySpace[k])
-                        if thisID == 4: 
-                            # starting position for pac-man
-                            
-                            self.player.homeX = k * 16
-                            self.player.homeY = rowNum * 16
-                            self.SetMapTile(rowNum, k, 0 )
-                            
-                        elif thisID >= 10 and thisID <= 13:
-                            # one of the self.ghosts
-                            
-                            self.ghosts[thisID - 10].homeX = k * 16
-                            self.ghosts[thisID - 10].homeY = rowNum * 16
-                            self.SetMapTile(rowNum, k, 0 )
-                        
-                        elif thisID == 2:
-                            # pellet
-                            
-                            self.pellets += 1
-                            
-                    rowNum += 1
-                    
-                
-        # reload all tiles and set appropriate colors
-        self.GetCrossRef(tileIDName, tileID, tileIDImage)
-
-        # load map into the pathfinder object
-        self.path.ResizeMap( self.lvlHeight, self.lvlWidth )
-        
-        for row in range(0, self.path.size[0], 1):
-            for col in range(0, self.path.size[1], 1):
-                if self.IsWall( row, col ):
-                    self.path.SetType( row, col, 1 )
-                else:
-                    self.path.SetType( row, col, 0 )
-        
-        # do all the level-starting stuff
-        self.Restart(tileID)
-        
-    def Restart (self, tileID):
-        
-        for i in range(0, 4, 1):
-            # move self.ghosts back to home
-
-            self.ghosts[i].x = self.ghosts[i].homeX
-            self.ghosts[i].y = self.ghosts[i].homeY
-            self.ghosts[i].velX = 0
-            self.ghosts[i].velY = 0
-            self.ghosts[i].state = 1
-            self.ghosts[i].speed = 1
-            self.ghosts[i].Move(self, tileID)
-            
-            # give each ghost a path to a random spot (containing a pellet)
-            (randRow, randCol) = (0, 0)
-
-            while not self.GetMapTile(randRow, randCol) == tileID[ 'pellet' ] or (randRow, randCol) == (0, 0):
-                randRow = random.randint(1, self.lvlHeight - 2)
-                randCol = random.randint(1, self.lvlWidth - 2)
-            
-            # print "Ghost " + str(i) + " headed towards " + str((randRow, randCol))
-            self.ghosts[i].currentPath = self.path.FindPath( (self.ghosts[i].nearestRow, self.ghosts[i].nearestCol), (randRow, randCol) )
-            self.ghosts[i].FollowNextPathWay(self, tileID)
-            
-        self.thisFruit.active = False
-            
-        self.thisGame.fruitTimer = 0
-
-        self.player.x = self.player.homeX
-        self.player.y = self.player.homeY
-        self.player.velX = 0
-        self.player.velY = 0
-        
-        self.player.anim_pacmanCurrent = self.player.anim_pacmanS
-        self.player.animFrame = 3
-
-
diff --git a/games/pacman/pacman.py b/games/pacman/pacman.py
deleted file mode 100644
index 70436f3..0000000
--- a/games/pacman/pacman.py
+++ /dev/null
@@ -1,686 +0,0 @@
-import random
-import pygame
-import numpy as np
-from pygame.math import Vector2
-
-class node ():
-    
-    def __init__ (self):
-        self.g = -1 # movement cost to move from previous node to this one (usually +10)
-        self.h = -1 # estimated movement cost to move from this node to the ending node (remaining horizontal and vertical steps * 10)
-        self.f = -1 # total movement cost of this node (= g + h)
-        # parent node - used to trace path back to the starting node at the end
-        self.parent = (-1, -1)
-        # node type - 0 for empty space, 1 for wall (optionally, 2 for starting node and 3 for end)
-        self.type = -1 
-        # create a 2d grid numpy array of 20x20
-
-
-
-    
-class Color:
-    """
-    Class to store hex values for colors/
-    """
-    def __init__(self):
-        """
-        Constructor Function
-        """
-        self.black = (0, 0, 0)
-        self.grey = (100, 100, 100)
-        self.white = (255, 255, 255)
-        self.blue = (0, 0, 255)
-        self.green = (0, 255, 0)
-        self.red = (255, 0, 0)
-        self.purple = (255, 0, 255)
-        self.yellow = (255, 255, 0)
-
-class PowerUp(pygame.sprite.Sprite):
-    def __init__(self, x, y):
-        super().__init__()
-        self.image = pygame.Surface([20, 20])
-        self.image.fill(Color().purple)  # Color indicating special power-up
-        self.rect = self.image.get_rect()
-        self.rect.x = x
-        self.rect.y = y
-        self.type = 'eat_ghosts'  # Specific type for eating ghosts
-        self.duration = 7000  # Lasts for 7 seconds
-
-    def apply_effect(self, player):
-        if self.type == 'eat_ghosts':
-            player.enable_ghost_eating(self.duration)
-
-
-class Wall(pygame.sprite.Sprite):
-    def __init__(self, x, y, width, height, color):
-        """
-        Constructor function
-        :param x:
-        :type x:
-        :param y:
-        :type y:
-        :param width:
-        :type width:
-        :param height:
-        :type height:
-        :param color:
-        :type color:
-        """
-
-        # Call the parent's constructor
-        pygame.sprite.Sprite.__init__(self)
-
-        # Make a wall, of the size specified in the parameters
-        self.image = pygame.Surface([width, height])
-        self.image.fill(color)
-
-        # Make our top-left corner the passed-in location.
-        self.rect = self.image.get_rect()
-        self.rect.top = y
-        self.rect.left = x
-
-
-class Block(pygame.sprite.Sprite):
-    """
-    This class represents the ball
-    It derives from the "Sprite" class in Pygame
-    """
-
-    def __init__(self, color, width, height):
-        """
-        Constructor. Pass in the color of the block and its x and y position
-        :param color:
-        :type color:
-        :param width:
-        :type width:
-        :param height:
-        :type height:
-        """
-
-        # Call the parent class (Sprite) constructor
-        pygame.sprite.Sprite.__init__(self)
-
-        # Create an image of the block, and fill it with a color.
-        # This could also be an image loaded from the disk.
-        self.color = Color()
-        self.image = pygame.Surface([width, height])
-        self.image.fill(self.color.white)
-        self.image.set_colorkey(self.color.white)
-        pygame.draw.ellipse(self.image, color, [0, 0, width, height])
-
-        # Fetch the rectangle object that has the dimensions of the image.
-        # Update the position of this object by setting the values
-        # of rect.x and rect.y
-        self.rect = self.image.get_rect()
-
-
-class Player(pygame.sprite.Sprite):
-    """
-    This class represents the bar at the bottom that the player controls
-    """
-
-    change_x = 0
-    change_y = 0
-
-    def __init__(self, x, y, filename):
-        """
-        Constructor function
-        :param x:
-        :type x:
-        :param y:
-        :type y:
-        :param filename:
-        :type filename:
-        """
-
-        # Call the parent's constructor
-        pygame.sprite.Sprite.__init__(self)
-
-        # Set height, width
-        self.image = pygame.image.load(filename).convert()
-
-        # Make our top-left corner the passed-in location.
-        self.rect = self.image.get_rect()
-        self.rect.top = y
-        self.rect.left = x
-        self.prev_x = x
-        self.prev_y = y
-        self.goal = None
-        self.ghost_eating = False
-        self.position = Vector2(x, y)  # Current position as a vector
-        self.goal = Vector2()  # Goal position initialized to zero vector
-        self.directions = {
-            'up': Vector2(0, -1),
-            'down': Vector2(0, 1),
-            'left': Vector2(-1, 0),
-            'right': Vector2(1, 0)
-        }
-
-
-    def prev_direction(self):
-        """
-        Clear the speed of the player
-        """
-        self.prev_x = self.change_x
-        self.prev_y = self.change_y
-
-    def change_speed(self, x, y):
-        """
-        Change the speed of the player
-        :param x:
-        :type x:
-        :param y:
-        :type y:
-        """
-        self.change_x += x
-        self.change_y += y
-
-    def update(self, walls, gate):
-        """
-        Find a new position for the player
-        :param walls: 
-        :type walls: 
-        :param gate: 
-        :type gate: 
-        """
-        for event in pygame.event.get():
-            if event.type == pygame.USEREVENT + 3:  # Timer for ghost eating power-up
-                self.ghost_eating = False
-        # Get the old position, in case we need to go back to it
-        old_x = self.rect.left
-        new_x = old_x + self.change_x
-        self.rect.left = new_x
-
-        old_y = self.rect.top
-        new_y = old_y + self.change_y
-
-   
-        x_collide = pygame.sprite.spritecollide(self, walls, False)
-        if x_collide:
-            self.rect.left = old_x
-        else:
-            self.rect.top = new_y
-            y_collide = pygame.sprite.spritecollide(self, walls, False)
-            if y_collide:
-                self.rect.top = old_y
-
-        if gate:
-            gate_hit = pygame.sprite.spritecollide(self, gate, False)
-            if gate_hit:
-                self.rect.left = old_x
-                self.rect.top = old_y 
-    
-    def enable_ghost_eating(self, duration):
-        self.ghost_eating = True
-        pygame.time.set_timer(pygame.USEREVENT + 3, duration)
-
-    
-
-
-class Ghost(Player):
-    """
-    Class to handle ghosts, inheriting from Player.
-    """
-    def __init__(self, x, y, filename, game):
-        super().__init__(x, y, filename)
-        self.game = game
-
-    def update_behavior(self, pacman):
-        self.mode = "flee" if pacman.ghost_eating else "chase"
-
-    def move(self, pacman):
-        self.update_behavior(pacman)
-        direction = self.chase_pacman() if self.mode == "chase" else self.run_away_from_pacman()
-        if direction:
-            movement = self.calculate_movement(direction)
-            self.change_speed(*movement)
-
-    def chase_pacman(self):
-        return self.goal_direction(self.game.game_map)
-
-    def run_away_from_pacman(self):
-        furthest_point = self.find_furthest_point()
-        self.set_goal(*furthest_point)
-        return self.goal_direction(self.game.game_map)
-
-    def find_furthest_point(self):
-        max_distance = 0
-        furthest_point = (self.rect.x, self.rect.y)
-        for y in range(self.game.path_finder.size[0]):
-            for x in range(self.game.path_finder.size[1]):
-                if self.game.game_map[y][x] == 0:
-                    distance = (Vector2(x, y) - self.position).length_squared()
-                    if distance > max_distance:
-                        max_distance = distance
-                        furthest_point = (x, y)
-        return furthest_point
-
-    def goal_direction(self, game_map):
-        TILEWIDTH = 30
-        distances = []
-        directions = list(self.directions.keys())
-        for direction in directions:
-            next_position = self.position + self.directions[direction] * TILEWIDTH
-            if game_map[int(next_position.y // TILEWIDTH)][int(next_position.x // TILEWIDTH)] == 1:
-                distances.append(float('inf'))
-            else:
-                vec = next_position - self.goal
-                distances.append(vec.length_squared())
-        if min(distances) == float('inf'):
-            return None
-        else:
-            index = distances.index(min(distances))
-            return directions[index]
-
-    def calculate_movement(self, direction):
-        movement_map = {
-            'up': (0, -30),
-            'down': (0, 30),
-            'left': (-30, 0),
-         'right': (30, 0)
-        }
-        return movement_map.get(direction, (0, 0)) 
-    
-
-class Game:
-    """
-    Class to run the game.
-    """
-
-    def __init__(self):
-        """
-        Constructor Function
-        """
-        self.cell_size = 30
-        self.grid_width = 20
-        self.grid_height = 20
-        #self.path_finder = path_finder()
-        # This is a list of walls. Each is in the form [x, y, width, height]
-        self.walls = [
-            [0, 0, 6, 600],
-            [0, 0, 600, 6],
-            [0, 600, 606, 6],
-            [600, 0, 6, 606],
-            [300, 0, 6, 66],
-            [60, 60, 186, 6],
-            [360, 60, 186, 6],
-            [60, 120, 66, 6],
-            [60, 120, 6, 126],
-            [180, 120, 246, 6],
-            [300, 120, 6, 66],
-            [480, 120, 66, 6],
-            [540, 120, 6, 126],
-            [120, 180, 126, 6],
-            [120, 180, 6, 126],
-            [360, 180, 126, 6],
-            [480, 180, 6, 126],
-            [180, 240, 6, 126],
-            [180, 360, 246, 6],
-            [420, 240, 6, 126],
-            [240, 240, 42, 6],
-            [324, 240, 42, 6],
-            [240, 240, 6, 66],
-            [240, 300, 126, 6],
-            [360, 240, 6, 66],
-            [0, 300, 66, 6],
-            [540, 300, 66, 6],
-            [60, 360, 66, 6],
-            [60, 360, 6, 186],
-            [480, 360, 66, 6],
-            [540, 360, 6, 186],
-            [120, 420, 366, 6],
-            [120, 420, 6, 66],
-            [480, 420, 6, 66],
-            [180, 480, 246, 6],
-            [300, 480, 6, 66],
-            [120, 540, 126, 6],
-            [360, 540, 126, 6],
-        ]
-
-       
-
-        self.color = Color()
-        # Call this function so the Pygame library can initialize itself
-        pygame.init()
-
-        # Create an 606x606 sized screen
-        self.screen = pygame.display.set_mode([606, 606])
-
-        # Set the title of the window
-        pygame.display.set_caption('Pacman')
-
-        # Create a surface we can draw on
-        background = pygame.Surface(self.screen.get_size())
-        background = background.convert()
-        background.fill(self.color.black)
-        self.clock = pygame.time.Clock()
-        pygame.font.init()
-        self.font = pygame.font.SysFont('arial', 30)
-        self.all_sprites_list = None
-        self.power_pellets = pygame.sprite.RenderPlain()
-        # default locations for Pacman and ghosts
-        w = 303 - 16  # Width
-        p_h = 7 * 60 + 19
-        m_h = 4 * 60 + 19
-        b_h = 3 * 60 + 19
-        i_w = 303 - 16 - 32
-        c_w = 303 + 32 - 16
-
-        self.all_sprites_list = pygame.sprite.RenderPlain()
-        self.block_list = pygame.sprite.RenderPlain()
-        self.ghost_list = pygame.sprite.RenderPlain()
-        self.pacman_collide = pygame.sprite.RenderPlain()
-        self.wall_list = self.setup_walls()
-
-        self.gate = self.setup_gate()
-
-        p_turn = 0
-        p_steps = 0
-
-        b_turn = 0
-        b_steps = 0
-
-        i_turn = 0
-        i_steps = 0
-
-        c_turn = 0
-        c_steps = 0
-
-        # Create the player  object
-        self.pacman = Player(w, p_h, 'images/pacman.png')
-        self.all_sprites_list.add(self.pacman)
-        self.pacman_collide.add(self.pacman)
-
-        self.ghost_two = Ghost(w, b_h, 'images/red.png', self)
-        self.ghost_list.add(self.ghost_two)
-        self.all_sprites_list.add(self.ghost_two)
-
-        self.ghost_one = Ghost(w, m_h, 'images/pink.png', self)
-        self.ghost_list.add(self.ghost_one)
-        self.all_sprites_list.add(self.ghost_one)
-
-        ghost_three = Ghost(i_w, m_h, 'images/blue.png',self)
-        self.ghost_list.add(ghost_three)
-        self.all_sprites_list.add(ghost_three)
-
-        ghost_four = Ghost(c_w, m_h, 'images/yellow.png',self)
-        self.ghost_list.add(ghost_four)
-        self.all_sprites_list.add(ghost_four)
-        grid = [[0 for _ in range(19)] for _ in range(19)]
-        # Draw the grid
-        for row in range(19):
-            for column in range(19):
-                
-                if (row == 7 or row == 8) and (column == 8 or column == 9 or column == 10):
-                    continue
-                else:
-                    block = Block(self.color.yellow, 4, 4)
-
-                    # Set a random location for the block
-                    block.rect.x = 30 * column + 6 + 26
-                    block.rect.y = 30 * row + 6 + 26
-
-                    b_collide = pygame.sprite.spritecollide(block, self.wall_list, False)
-                    p_collide = pygame.sprite.spritecollide(block, self.pacman_collide, False)
-                    if b_collide:
-                        grid[row][column] = 1
-
-                        continue
-
-                    elif p_collide:
-                        grid[row][column] = 0
-                        continue
-                    else:
-                        # Add the block to the list of objects
-                        grid[row][column] = 0
-                        self.block_list.add(block)
-                        self.all_sprites_list.add(block)
-        # create new grid which is 20x20 with edges as 1 from grid
-        
-        new_grid = [[1 if i == 0 or i == 19 or j == 0 or j == 19 else grid[i-1][j-1] for j in range(20)] for i in range(20)] 
-        self.game_map = new_grid
-        self.path_finder.ResizeMap(20, 20)
-        self.update_path_finder_with_walls(new_grid)
-        blocks = list(self.block_list)
-        selected_blocks = random.sample(blocks, 4)
-        self.power_pellet_list = pygame.sprite.RenderPlain()
-# Replace the selected blocks with power pellets
-        for block in selected_blocks:
-            power_pellet = PowerUp(block.rect.x, block.rect.y)  # Assuming you have a PowerPellet class
-            self.power_pellet_list.add(power_pellet)
-    # Add the power pellet to the game (you might need to modify this part based on your game structure)
-            self.all_sprites_list.add(power_pellet)
-        self.bll = len(self.block_list)
-
-
-   
-
-    def update_path_finder_with_walls(self, grid):
-        for i in range(len(grid[0])):
-            for j in range(len(grid[1])):
-                self.path_finder.SetType(i,j, grid[i][j])
-
-
-
-    def get_maze_size(self):
-        max_width = 0
-        max_height = 0
-
-        for wall in self.walls:
-            x, y, width, height = wall
-            # Calculate the furthest extents of the walls
-            max_width = max(max_width, x + width)
-            max_height = max(max_height, y + height)
-
-        return max_width, max_height
-    def setup_walls(self):
-        """
-        Make the walls. (x_pos, y_pos, width, height)
-        :return:
-        :rtype:
-        """
-        wall_list = pygame.sprite.RenderPlain()
-
-        # Loop through the list. Create the wall, add it to the list
-        for item in self.walls:
-            wall = Wall(item[0], item[1], item[2], item[3], self.color.grey)
-            wall_list.add(wall)
-            self.all_sprites_list.add(wall)
-
-        # return our new list
-        return wall_list
-
-    def setup_gate(self):
-        """
-        Add gates in the walls
-        :return:
-        :rtype:
-        """
-        gate = pygame.sprite.RenderPlain()
-        gate.add(Wall(282, 242, 42, 2, self.color.white))
-        self.all_sprites_list.add(gate)
-        return gate 
-    
-
-    def setup_power_pellets(self):
-        # Define power pellet locations and add them to the game
-        locations = [(100, 200), (500, 300), (300, 100)]  # Example locations
-        for x, y in locations:
-            pellet = PowerUp(x, y)
-            self.power_pellets.add(pellet)
-            self.all_sprites_list.add(pellet) 
-
-
-    def start_game(self):
-        """
-        start the game
-        """
-
-       
-
-        
-                
-       
-
-        # Get the unique row indices
-
-        
-        score = 0
-        done = False
-        while not done:
-            # Events
-            for event in pygame.event.get():
-                if event.type == pygame.QUIT:
-                    done = True
-
-                if event.type == pygame.KEYDOWN:
-                    if event.key == pygame.K_LEFT:
-                        self.pacman.change_speed(-30, 0)
-                    if event.key == pygame.K_RIGHT:
-                        self.pacman.change_speed(30, 0)
-                    if event.key == pygame.K_UP:
-                        self.pacman.change_speed(0, -30)
-                    if event.key == pygame.K_DOWN:
-                        self.pacman.change_speed(0, 30)
-
-                if event.type == pygame.KEYUP:
-                    if event.key == pygame.K_LEFT:
-                        self.pacman.change_speed(30, 0)
-                    if event.key == pygame.K_RIGHT:
-                        self.pacman.change_speed(-30, 0)
-                    if event.key == pygame.K_UP:
-                        self.pacman.change_speed(0, 30)
-                    if event.key == pygame.K_DOWN:
-                        self.pacman.change_speed(0, -30)
-
-            self.pacman.update(self.wall_list, self.gate) 
-
-            # Assuming new_grid is your grid
-            
-
-            # Check if the two grids are the same
-            # print(f"new_grid_np: {new_grid_np}")
-            # print(f"path_finder_grid: {path_finder_grid}")
-            # print(f"Are the grids equal? {are_grids_equal}")
-        # whic
-            #self.ghost_one.move(self.pacman)
-            self.ghost_two.move(self.pacman)
-            # ghost_three.move(pacman)
-            # ghost_four.move(pacman)
-
-            # ghost_one.update(wall_list, None)
-            self.ghost_two.update(self.wall_list, None)
-            print(f"Ghost Two position: {self.ghost_two.rect.x}, {self.ghost_two.rect.y}")
-            print("Is Ghost Two in all_sprites_list?", self.ghost_two in self.all_sprites_list)
-            print("Is Ghost Two in ghost_list?", self.ghost_two in self.ghost_list)
-            # ghost_three.update(wall_list, None)
-            # ghost_four.update(wall_list, None)
-            # See if the pacman block has collided with anything.
-            blocks_hit_list = pygame.sprite.spritecollide(self.pacman, self.block_list, True) 
-            power_pellets_hit_list = pygame.sprite.spritecollide(self.pacman, self.power_pellet_list, True)
-            # check if pacman hits any power pellet
-            # if pellet is hit 
-            # Check the list of collisions.
-            if len(blocks_hit_list) > 0:
-                score += len(blocks_hit_list)
-
-            self.screen.fill(self.color.black)
-
-            self.wall_list.draw(self.screen)
-            self.gate.draw(self.screen)
-            self.all_sprites_list.draw(self.screen)
-            self.ghost_list.draw(self.screen)
-
-            text = self.font.render(str(score) + '/' + str(self.bll), True, self.color.white)
-            self.screen.blit(text, [270, 254])
-
-            if score == self.bll:
-                self.do_next(
-                    'Congratulations, you won!',
-                    145,
-                    self.block_list,
-                    self.ghost_list,
-                    self.pacman_collide,
-                    self.wall_list,
-                    self.gate,
-                )
-                return
-
-            ghost_hit_list = pygame.sprite.spritecollide(self.pacman, self.ghost_list, False)
-
-            if ghost_hit_list:
-                self.do_next(
-                    'Game Over',
-                    235,
-                    self.block_list,
-                    self.ghost_list,
-                    self.pacman_collide,
-                    self.wall_list,
-                    self.gate,
-                )
-                return
-
-            pygame.display.flip()
-
-            self.clock.tick(10)
-
-    def do_next(self, message, left, block_list, ghost_list, pacman_collide, wall_list, gate):
-        """
-        Go to next configuration in the game
-        :param message:
-        :type message:
-        :param left:
-        :type left:
-        :param block_list:
-        :type block_list:
-        :param ghost_list:
-        :type ghost_list:
-        :param pacman_collide:
-        :type pacman_collide:
-        :param wall_list:
-        :type wall_list:
-        :param gate:
-        :type gate:
-        """
-        while True:
-            for event in pygame.event.get():
-                if event.type == pygame.QUIT:
-                    pygame.quit()
-                    return
-                if event.type == pygame.KEYDOWN:
-                    if event.key == pygame.K_ESCAPE:
-                        pygame.quit()
-                        return
-                    if event.key == pygame.K_RETURN:
-                        del self.all_sprites_list
-                        del block_list
-                        del ghost_list
-                        del pacman_collide
-                        del wall_list
-                        del gate
-                        self.start_game()
-                        return
-
-            # Grey background
-            w_surface = pygame.Surface((400, 200))  # the size of your rect
-            w_surface.fill((255, 255, 255))  # this fills the entire surface
-            self.screen.blit(w_surface, (100, 200))  # (0,0) are the top-left coordinates
-
-            # Won or lost
-            text1 = self.font.render(message, True, self.color.black)
-            self.screen.blit(text1, [left, 233])
-
-            text2 = self.font.render('To play again, press ENTER.', True, self.color.black)
-            self.screen.blit(text2, [135, 300])
-            text3 = self.font.render('To quit, press ESCAPE.', True, self.color.black)
-            self.screen.blit(text3, [165, 340])
-
-            pygame.display.flip()
-            self.clock.tick(10)
-
-
-if __name__ == '__main__':
-    # main function
-    game = Game()
-    game.start_game()
-    pygame.quit()
\ No newline at end of file
diff --git a/games/pacman/pacman_env.py b/games/pacman/pacman_env.py
deleted file mode 100644
index e185f02..0000000
--- a/games/pacman/pacman_env.py
+++ /dev/null
@@ -1,370 +0,0 @@
-import gym
-from gym import spaces
-import pygame
-import numpy as np
-import os
-import sys
-from pygame.locals import *
-import time
-# Import your game modules
-from games.pacman.player import pacman
-from games.pacman.ghost import ghost
-from games.pacman.path import path_finder
-from games.pacman.level import level
-from games.pacman.game import game
-from games.pacman.fruit import fruit
-from games.pacman.config import *
-import networkx as nx
-from games.encoder.GraphEncoder import GraphConverter
-
-class PacmanEnv(gym.Env):
-    metadata = {'render.modes': ['human', 'rgb_array']}
-    def __init__(self):
-        super(PacmanEnv, self).__init__()
-
-        # Action space (4 directions)
-        self.action_space = spaces.Discrete(4)  # [Up, Down, Left, Right]
-
-        # Observation space (Assuming a RGB image of the screen)
-        self.observation_space = spaces.Box(low=0, high=255,
-                                            shape=(self.window_height, self.window_width, 3 * self.frame_stack),
-                                            dtype=np.uint8)
-        # Initialize the game
-        pygame.init()
-        self.window = pygame.display.set_mode((1, 1))
-        img_Background = pygame.image.load(os.path.join(SCRIPT_PATH,"res","backgrounds","1.gif")).convert()
-
-        pygame.display.set_caption("Pacman")
-        self.screen = pygame.display.get_surface()
-        self.tileID = {}
-        self.tileIDName = {}
-        self.tileIDImage = {}
-        self.NO_GIF_TILES = set()
-        self.path = path_finder()
-        self.player = pacman(self.path, self.screen)
-        self.ghosts = {i: ghost(i, self.path, self.screen, self.player) for i in range(6)}
-        self.fruit = fruit()
-        self.game = game(self.fruit, self.player, self.screen)
-        self.level = level(self.game, self.player, self.ghosts, self.path, self.fruit, self.screen)
-        self.frame_stack = 4 
-        self.window_width = 336
-        self.window_height = 400
-        self.frame_buffer = np.zeros((self.window_height, self.window_width, 3 * self.frame_stack), dtype=np.uint8)
-        self.load_resources()
-
-
-    def load_resources(self):
-        lineNum = 0
-        self.SCRIPT_PATH = os.path.dirname(__file__)
-        res_path = os.path.join(self.SCRIPT_PATH, "res")
-        # Load background images
-        self.img_Background = pygame.image.load(os.path.join(res_path, "backgrounds", "1.gif")).convert()
-        
-        
-        f = open(os.path.join(SCRIPT_PATH,"res","crossref.txt"), 'r')
-
-        # Load tile images and other assets by initializing the cross-reference data structures
-          # Define this properly based on your game's requirements
-
-        # Assume crossref.txt has the mappings from tile ID to tile names and their associated images
-        for i in f.readlines():
-            # print " ========= Line " + str(lineNum) + " ============ "
-            while len(i)>0 and (i[-1]=='\n' or i[-1]=='\r'): i=i[:-1]
-            while len(i)>0 and (i[0]=='\n' or i[0]=='\r'): i=i[1:]
-            str_splitBySpace = i.split(' ')
-            
-            j = str_splitBySpace[0]
-                
-            if (j == "'" or j == "" or j == "#"):
-                # comment / whitespace line
-                # print " ignoring comment line.. "
-                useLine = False
-            else:
-                # print str(wordNum) + ". " + j
-                useLine = True
-            
-            if useLine == True:
-                self.tileIDName[ int(str_splitBySpace[0]) ] = str_splitBySpace[1]
-                self.tileID[ str_splitBySpace[1] ] = int(str_splitBySpace[0])
-                
-                thisID = int(str_splitBySpace[0])
-                if not thisID in NO_GIF_TILES:
-                    self.tileIDImage[ thisID ] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","tiles",str_splitBySpace[1] + ".gif")).convert()
-                else:
-                        self.tileIDImage[ thisID ] = pygame.Surface((16,16))
-                
-                # change colors in tileIDImage to match maze colors
-                for y in range(0, 16, 1):
-                    for x in range(0, 16, 1):
-                    
-                        if self.tileIDImage[ thisID ].get_at( (x, y) ) == (255, 206, 255, 255):
-                            # wall edge
-                            self.tileIDImage[ thisID ].set_at( (x, y), self.level.edgeLightColor )
-                            
-                        elif self.tileIDImage[ thisID ].get_at( (x, y) ) == (132, 0, 132, 255):
-                            # wall fill
-                            self.tileIDImage[ thisID ].set_at( (x, y), self.level.fillColor ) 
-
-                        elif self.tileIDImage[ thisID ].get_at( (x, y) ) == (255, 0, 255, 255):
-                            # pellet color
-                            self.tileIDImage[ thisID ].set_at( (x, y), self.level.edgeShadowColor )   
-                            
-                        elif self.tileIDImage[ thisID ].get_at( (x, y) ) == (128, 0, 128, 255):
-                            # pellet color
-                            self.tileIDImage[ thisID ].set_at( (x, y), self.level.pelletColor )   
-                    
-                # print str_splitBySpace[0] + " is married to " + str_splitBySpace[1]
-            lineNum += 1
-    
-    def reset(self):
-        # Reset the game
-                # Load resources
-        #self.load_resources()
-        
-        # Game components
-        self.player = pacman(self.path, self.screen)
-        self.ghosts = {i: ghost(i, self.path, self.screen, self.player) for i in range(6)}
-        self.fruit = fruit()
-        self.game = game(self.fruit, self.player, self.screen)
-        self.level = level(self.game, self.player, self.ghosts, self.path, self.fruit, self.screen) 
-        self.load_resources()
-        #self.game.StartNewGame(self.level, self.tileID, self.tileIDImage, self.tileIDName)
-        self.clock = pygame.time.Clock()
-        self.game.StartNewGame(self.level, self.tileID, self.tileIDImage, self.tileIDName)
-        self.level.LoadLevel( self.game.GetLevelNum(), self.tileID, self.tileIDImage, self.tileIDName )
-        self.window = pygame.display.set_mode( self.game.screenSize, pygame.DOUBLEBUF | pygame.HWSURFACE )
-        self.frame_buffer = np.zeros((self.window_height, self.window_width, 3 * self.frame_stack), dtype=np.uint8)
-        return pygame.surfarray.array3d(pygame.display.get_surface())
-
-    def step(self, action):
-        reward = 0
-        done = False
-        # Map action to game controls
-        #print(self.game.mode)
-        if self.game.mode == 1:
-            if action == 0:
-                if not self.level.CheckIfHitWall(self.player.x + self.player.speed, self.player.y, self.player.nearestRow, self.player.nearestCol): 
-                    self.player.velX = self.player.speed
-                    self.player.velY = 0
-                    
-            elif action == 1:
-                if not self.level.CheckIfHitWall(self.player.x - self.player.speed, self.player.y, self.player.nearestRow, self.player.nearestCol): 
-                    self.player.velX = -self.player.speed
-                    self.player.velY = 0
-                
-            elif action == 2:
-                if not self.level.CheckIfHitWall(self.player.x, self.player.y + self.player.speed, self.player.nearestRow, self.player.nearestCol): 
-                    self.player.velX = 0
-                    self.player.velY = self.player.speed
-                
-            elif action == 3:
-                if not self.level.CheckIfHitWall(self.player.x, self.player.y - self.player.speed, self.player.nearestRow, self.player.nearestCol):
-                    self.player.velX = 0
-                    self.player.velY = -self.player.speed
-            # Game logic
-            
-            score = self.game.score
-            self.game.modeTimer += 1
-            self.player.Move(self.game, self.level, self.ghosts, self.fruit, self.tileID)
-            for ghost in self.ghosts.values():
-                ghost.Move(self.level, self.tileID)
-           
-            new_score = self.game.score
-            reward = new_score - score  # Reward for eating pellets
-            #reward = eaten_pellets * 10  # Reward for eating pellets
-
-        elif self.game.mode == 2:
-                reward = -100
-                self.game.modeTimer += 1
-        
-                if self.game.modeTimer == 90:
-                    self.level.Restart(self.tileID)
-                #self.level.Restart(self.tileID)
-                self.game.lives -= 1
-                if self.game.lives == -1:
-                    done = True
-            
-        elif self.game.mode == 5:
-            reward = 100
-            self.game.mode = 1
-        
-        elif self.game.mode == 6:
-            reward = 1000
-            done = True
-
-
-        info = self.get_graph_data()  # Additional data, not used now but required by Gym's API
-
-            # Get observation
-        observation = self._get_observation()
-
-        return observation, reward, done, info
-
-      # Return initial state
-    def _get_observation(self):
-        # You can also choose to return other representations of the game state
-        frame = pygame.surfarray.array3d(pygame.display.get_surface())
-        frame = frame.transpose((1, 0, 2))  # Correct the shape to (height, width, channels)
-        # Update frame buffer
-        self.frame_buffer = np.roll(self.frame_buffer, -3, axis=2)
-        self.frame_buffer[:, :, -3:] = frame
-        return self.frame_buffer
-
-    
-    def get_graph_data(self):
-        # Initialize a NetworkX graph
-        graph = nx.Graph()
-
-        # Define object features and add nodes
-        pacman_features = [self.player.x, self.player.y, self.player.velX, self.player.velY, 1, 0, 0, 0]
-        graph.add_node("pacman", type="object", features=pacman_features)
-
-        ghost_features = [[ghost.x, ghost.y, ghost.velX, ghost.velY,0,1,0,0] for ghost in self.ghosts.values()]
-        for i, features in enumerate(ghost_features):
-            graph.add_node(f"ghost_{i}", type="object", features=features)
-
-        pellet_features = [[pellet[0], pellet[1],0,0,0,0,1,0] for pellet in self.level.GetPelletLocations()]
-        for i, features in enumerate(pellet_features):
-            graph.add_node(f"pellet_{i}", type="object", features=features)
-
-        power_pellet_features = [[pellet[0], pellet[1],0,0,0,0,0,1] for pellet in self.level.GetPowerPelletLocations()]
-        for i, features in enumerate(power_pellet_features):
-            graph.add_node(f"power_pellet_{i}", type="object", features=features)
-
-        # Combine object positions
-        object_positions = {
-            "pacman": pacman_features[:2],
-        }
-        for i, ghost in enumerate(self.ghosts.values()):
-            object_positions[f"ghost_{i}"] = ghost_features[i][:2]
-        for i, pellet in enumerate(self.level.GetPelletLocations()):
-            object_positions[f"pellet_{i}"] = pellet_features[i][:2]
-        for i, power_pellet in enumerate(self.level.GetPowerPelletLocations()):
-            object_positions[f"power_pellet_{i}"] = power_pellet_features[i][:2]
-
-        # Proximity threshold for creating atoms
-        #proximity_threshold = self.proximity_threshold
-
-        # Create atom nodes and edges based on proximity
-        atom_index = len(object_positions)  # Start indexing atoms after all objects
-
-        # Determine wall proximity around Pac-Man
-        walls = {
-            'up': self.level.CheckIfHitWall(self.player.x, self.player.y - self.player.velY, self.player.y - 1, self.player.x),
-            'down': self.level.CheckIfHitWall(self.player.x, self.player.y + self.player.velY, self.player.y + 1, self.player.x),
-            'left': self.level.CheckIfHitWall(self.player.x - self.player.velX, self.player.y, self.player.y, self.player.x - 1),
-            'right': self.level.CheckIfHitWall(self.player.x + self.player.velX, self.player.y, self.player.y, self.player.x + 1)
-        }
-
-        standard_feature_vector_size = len(pacman_features)
-        empty_feature_vector = [0] *(2* standard_feature_vector_size)
-
-        # Add wall direction atoms and edges for Pac-Man
-        for direction, hit in walls.items():
-            if hit:
-                atom_node = f"Wall{direction.capitalize()}_{atom_index}"
-                graph.add_node(atom_node, type="atom", features=empty_feature_vector, predicate=f"Wall{direction.capitalize()}")
-                graph.add_edge("pacman", atom_node, position=0)
-                atom_index += 1
-
-        # Add distance and direction atoms and edges for ghosts
-        for i, ghost_pos in enumerate(ghost_features):
-            distance = np.linalg.norm(np.array(pacman_features[:2]) - np.array(ghost_pos[:2]))
-            direction = np.array(pacman_features[:2]) - np.array(ghost_pos[:2])
-            
-            atom_node_distance = f"Distance_Pacman_Ghost_{i}_{atom_index}"
-            graph.add_node(atom_node_distance,features=empty_feature_vector, type="atom", predicate="Distance")
-            graph.add_edge("pacman", atom_node_distance, position=0)
-            graph.add_edge(f"ghost_{i}", atom_node_distance, position=1)
-            
-            atom_index += 1
-
-            if pacman_features[0] == ghost_pos[0]:
-                atom_node_same_row = f"SameRow_Pacman_Ghost_{i}_{atom_index}"
-                graph.add_node(atom_node_same_row, features=empty_feature_vector,type="atom", predicate="SameRow")
-                graph.add_edge("pacman", atom_node_same_row, position=0)
-                graph.add_edge(f"ghost_{i}", atom_node_same_row, position=1)
-                atom_index += 1
-
-            if pacman_features[1] == ghost_pos[1]:
-                atom_node_same_column = f"SameColumn_Pacman_Ghost_{i}_{atom_index}"
-                graph.add_node(atom_node_same_column, features=empty_feature_vector, type="atom", predicate="SameColumn")
-                graph.add_edge("pacman", atom_node_same_column, position=0)
-                graph.add_edge(f"ghost_{i}", atom_node_same_column, position=1)
-                atom_index += 1
-
-        # Add distance and direction atoms and edges for pellets
-        for i, pellet_pos in enumerate(pellet_features):
-            distance = np.linalg.norm(np.array(pacman_features[:2]) - np.array(pellet_pos[:2]))
-            
-            atom_node_distance = f"Distance_Pacman_Pellet_{i}_{atom_index}"
-            graph.add_node(atom_node_distance, features=empty_feature_vector,type="atom", predicate="Distance")
-            graph.add_edge("pacman", atom_node_distance, position=0)
-            graph.add_edge(f"pellet_{i}", atom_node_distance, position=1)
-            
-            atom_index += 1
-
-        # Add distance and direction atoms and edges for power pellets
-        for i, power_pellet_pos in enumerate(power_pellet_features):
-            distance = np.linalg.norm(np.array(pacman_features[:2]) - np.array(power_pellet_pos[:2]))
-            
-            atom_node_distance = f"Distance_Pacman_PowerPellet_{i}_{atom_index}"
-            graph.add_node(atom_node_distance,features=empty_feature_vector, type="atom", predicate="Distance")
-            graph.add_edge("pacman", atom_node_distance, position=0)
-            graph.add_edge(f"power_pellet_{i}", atom_node_distance, position=1)
-            
-            atom_index += 1
-
-        # Create a GraphConverter object
-        converter = GraphConverter()
-
-        # Convert the NetworkX graph to a PyG Data object
-        data = converter.to_pyg_data(graph)
-        return data
-    
-
-    
-    def render(self, mode='human'):
-        self.screen.blit(self.img_Background, (0, 0))
-        self.level.DrawMap(self.tileID, self.tileIDImage)
-        
-        if self.game.fruitScoreTimer > 0:
-            if self.game.modeTimer % 2 == 0:
-                self.game.DrawNumber (2500, self.fruit.x - self.game.screenPixelPos[0] - 16, self.fruit.y - self.screenPixelPos[1] + 4)
-
-        for i in range(0, 4, 1):
-            self.ghosts[i].Draw(self.game,self.tileID, self.tileIDImage, self.ghosts)
-        self.fruit.Draw(self.game)
-        self.player.Draw(self.game)
-        if mode == 'human':
-            
-            pygame.display.flip()
-        elif mode == 'rgb_array':
-            return pygame.surfarray.array3d(pygame.display.get_surface())
-
-    def close(self):
-        pygame.quit()
-
-# Usage Example
-if __name__ == "__main__":
-    env = PacmanEnv()
-    obs = env.reset()
-    done = False
-
-    while not done:
-        #env.render()  # Ensure the environment is rendered every loop
-        action = env.action_space.sample()
-        
-        obs, reward, done, info = env.step(action)
-        if reward<0:
-            print("Ghost collision")
-        #print(f"Action: {action}, Reward: {reward}")
-        #time.sleep(0.1)  # Add a delay to make changes observable
-
-        if done:
-            print("Game Over. Restarting...")
-            obs = env.reset()
-            done = False
-            time.sleep(2)  # Pause before restarting
-
-    env.close()
\ No newline at end of file
diff --git a/games/pacman/pacman_new.py b/games/pacman/pacman_new.py
deleted file mode 100644
index 1baea23..0000000
--- a/games/pacman/pacman_new.py
+++ /dev/null
@@ -1,1583 +0,0 @@
-#! /usr/bin/python
-
-# pacman.pyw
-# By David Reilly
-
-# Modified by Andy Sommerville, 8 October 2007:
-# - Changed hard-coded DOS paths to os.path calls
-# - Added constant SCRIPT_PATH (so you don't need to have pacman.pyw and res in your cwd, as long
-# -   as those two are in the same directory)
-# - Changed text-file reading to accomodate any known EOLn method (\n, \r, or \r\n)
-# - I (happily) don't have a Windows box to test this. Blocks marked "WIN???"
-# -   should be examined if this doesn't run in Windows
-# - Added joystick support (configure by changing JS_* constants)
-# - Added a high-score list. Depends on wx for querying the user's name
-
-import pygame, sys, os, random
-from pygame.locals import *
-
-# WIN???
-SCRIPT_PATH=sys.path[0]
-
-# NO_GIF_TILES -- tile numbers which do not correspond to a GIF file
-# currently only "23" for the high-score list
-NO_GIF_TILES=[23]
-
-NO_WX=0 # if set, the high-score code will not attempt to ask the user his name
-USER_NAME="User" # USER_NAME=os.getlogin() # the default user name if wx fails to load or NO_WX
-
-# Joystick defaults - maybe add a Preferences dialog in the future?
-JS_DEVNUM=0 # device 0 (pygame joysticks always start at 0). if JS_DEVNUM is not a valid device, will use 0
-JS_XAXIS=0 # axis 0 for left/right (default for most joysticks)
-JS_YAXIS=1 # axis 1 for up/down (default for most joysticks)
-JS_STARTBUTTON=0 # button number to start the game. this is a matter of personal preference, and will vary from device to device
-
-# Must come before pygame.init()
-pygame.mixer.pre_init(22050,16,2,512)
-JS_STARTBUTTON=0 # button number to start the game. this is a matter of personal preference, and will vary from device to device
-pygame.mixer.init()
-
-clock = pygame.time.Clock()
-pygame.init()
-
-window = pygame.display.set_mode((1, 1))
-pygame.display.set_caption("Pacman")
-
-screen = pygame.display.get_surface()
-
-img_Background = pygame.image.load(os.path.join(SCRIPT_PATH,"res","backgrounds","1.gif")).convert()
-
-snd_pellet = {}
-snd_pellet[0] = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","pellet1.wav"))
-snd_pellet[1] = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","pellet2.wav"))
-snd_powerpellet = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","powerpellet.wav"))
-snd_eatgh = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","eatgh2.wav"))
-snd_fruitbounce = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","fruitbounce.wav"))
-snd_eatfruit = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","eatfruit.wav"))
-snd_extralife = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","extralife.wav"))
-
-
-
-#      ___________________
-# ___/  class definitions  \_______________________________________________
-
-class game ():
-
-    def defaulthiscorelist(self):
-            return [ (100000,"David") , (80000,"Andy") , (60000,"Count Pacula") , (40000,"Cleopacra") , (20000,"Brett Favre") , (10000,"Sergei Pachmaninoff") ]
-
-    def gethiscores(self):
-            """If res/hiscore.txt exists, read it. If not, return the default high scores.
-               Output is [ (score,name) , (score,name) , .. ]. Always 6 entries."""
-            try:
-              f=open(os.path.join(SCRIPT_PATH,"res","hiscore.txt"))
-              hs=[]
-              for line in f:
-                while len(line)>0 and (line[0]=="\n" or line[0]=="\r"): line=line[1:]
-                while len(line)>0 and (line[-1]=="\n" or line[-1]=="\r"): line=line[:-1]
-                score=int(line.split(" ")[0])
-                name=line.partition(" ")[2]
-                if score>99999999: score=99999999
-                if len(name)>22: name=name[:22]
-                hs.append((score,name))
-              f.close()
-              if len(hs)>6: hs=hs[:6]
-              while len(hs)<6: hs.append((0,""))
-              return hs
-            except IOError:
-              return self.defaulthiscorelist()
-              
-    def writehiscores(self,hs):
-            """Given a new list, write it to the default file."""
-            fname=os.path.join(SCRIPT_PATH,"res","hiscore.txt")
-            f=open(fname,"w")
-            for line in hs:
-              f.write(str(line[0])+" "+line[1]+"\n")
-            f.close()
-            
-    def getplayername(self):
-            """Ask the player his name, to go on the high-score list."""
-            if NO_WX: return USER_NAME
-            try:
-              import wx
-            except:
-              print("Pacman Error: No module wx. Can not ask the user his name!")
-              print( "     :(       Download wx from http://www.wxpython.org/")
-              print( "     :(       To avoid seeing this error again, set NO_WX in file pacman.pyw.")
-              return USER_NAME
-            app=wx.App(None)
-            dlog=wx.TextEntryDialog(None,"You made the high-score list! Name:")
-            dlog.ShowModal()
-            name=dlog.GetValue()
-            dlog.Destroy()
-            app.Destroy()
-            return name
-              
-    def updatehiscores(self,newscore):
-            """Add newscore to the high score list, if appropriate."""
-            hs=self.gethiscores()
-            for line in hs:
-              if newscore>=line[0]:
-                hs.insert(hs.index(line),(newscore,self.getplayername()))
-                hs.pop(-1)
-                break
-            self.writehiscores(hs)
-
-    def makehiscorelist(self):
-            "Read the High-Score file and convert it to a useable Surface."
-            # My apologies for all the hard-coded constants.... -Andy
-            f=pygame.font.Font(os.path.join(SCRIPT_PATH,"res","VeraMoBd.ttf"),10)
-            scoresurf=pygame.Surface((276,86),pygame.SRCALPHA)
-            scoresurf.set_alpha(200)
-            linesurf=f.render(" "*18+"HIGH SCORES",1,(255,255,0))
-            scoresurf.blit(linesurf,(0,0))
-            hs=self.gethiscores()
-            vpos=0
-            for line in hs:
-              vpos+=12
-              linesurf=f.render(line[1].rjust(22)+str(line[0]).rjust(9),1,(255,255,255))
-              scoresurf.blit(linesurf,(0,vpos))
-            return scoresurf
-            
-    def drawmidgamehiscores(self):
-            """Redraw the high-score list image after pacman dies."""
-            self.imHiscores=self.makehiscorelist()
-
-    def __init__ (self):
-        self.levelNum = 0
-        self.score = 0
-        self.lives = 3
-        
-        # game "mode" variable
-        # 1 = normal
-        # 2 = hit ghost
-        # 3 = game over
-        # 4 = wait to start
-        # 5 = wait after eating ghost
-        # 6 = wait after finishing level
-        self.mode = 0
-        self.modeTimer = 0
-        self.ghostTimer = 0
-        self.ghostValue = 0
-        self.fruitTimer = 0
-        self.fruitScoreTimer = 0
-        self.fruitScorePos = (0, 0)
-        
-        self.SetMode( 3 )
-        
-        # camera variables
-        self.screenPixelPos = (0, 0) # absolute x,y position of the screen from the upper-left corner of the level
-        self.screenNearestTilePos = (0, 0) # nearest-tile position of the screen from the UL corner
-        self.screenPixelOffset = (0, 0) # offset in pixels of the screen from its nearest-tile position
-        
-        self.screenTileSize = (23, 21)
-        self.screenSize = (self.screenTileSize[1] * 16, self.screenTileSize[0] * 16)
-
-        # numerical display digits
-        self.digit = {}
-        for i in range(0, 10, 1):
-            self.digit[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","text",str(i) + ".gif")).convert()
-        self.imLife = pygame.image.load(os.path.join(SCRIPT_PATH,"res","text","life.gif")).convert()
-        self.imGameOver = pygame.image.load(os.path.join(SCRIPT_PATH,"res","text","gameover.gif")).convert()
-        self.imReady = pygame.image.load(os.path.join(SCRIPT_PATH,"res","text","ready.gif")).convert()
-        self.imLogo = pygame.image.load(os.path.join(SCRIPT_PATH,"res","text","logo.gif")).convert()
-        self.imHiscores = self.makehiscorelist()
-        
-    def StartNewGame (self):
-        self.levelNum = 1
-        self.score = 0
-        self.lives = 3
-        
-        self.SetMode( 4 )
-        thisLevel.LoadLevel( thisGame.GetLevelNum() )
-            
-    def AddToScore (self, amount):
-        
-        extraLifeSet = [25000, 50000, 100000, 150000]
-        
-        for specialScore in extraLifeSet:
-            if self.score < specialScore and self.score + amount >= specialScore:
-                snd_extralife.play()
-                thisGame.lives += 1
-        
-        self.score += amount
-        
-    
-    def DrawScore (self):
-        self.DrawNumber (self.score, 24 + 16, self.screenSize[1] - 24 )
-            
-        for i in range(0, self.lives, 1):
-            screen.blit (self.imLife, (24 + i * 10 + 16, self.screenSize[1] - 12) )
-            
-        screen.blit (thisFruit.imFruit[ thisFruit.fruitType ], (4 + 16, self.screenSize[1] - 20) )
-            
-        if self.mode == 3:
-            screen.blit (self.imGameOver, (self.screenSize[0] / 2 - 32, self.screenSize[1] / 2 - 10) )
-        elif self.mode == 4:
-            screen.blit (self.imReady, (self.screenSize[0] / 2 - 20, self.screenSize[1] / 2 + 12) )
-            
-        self.DrawNumber (self.levelNum, 0, self.screenSize[1] - 12 )
-            
-    def DrawNumber (self, number, x, y):
-        strNumber = str(int(number))
-        for i in range(0, len(strNumber), 1):
-            iDigit = int(strNumber[i])
-            screen.blit (self.digit[ iDigit ], (x + i * 9, y) )
-        
-    def SmartMoveScreen (self):
-            
-        possibleScreenX = player.x - self.screenTileSize[1] / 2 * 16
-        possibleScreenY = player.y - self.screenTileSize[0] / 2 * 16
-        
-        if possibleScreenX < 0:
-            possibleScreenX = 0
-        elif possibleScreenX > thisLevel.lvlWidth * 16 - self.screenSize[0]:
-            possibleScreenX = thisLevel.lvlWidth * 16 - self.screenSize[0]
-            
-        if possibleScreenY < 0:
-            possibleScreenY = 0
-        elif possibleScreenY > thisLevel.lvlHeight * 16 - self.screenSize[1]:
-            possibleScreenY = thisLevel.lvlHeight * 16 - self.screenSize[1]
-        
-        thisGame.MoveScreen( possibleScreenX, possibleScreenY )
-        
-    def MoveScreen (self, newX, newY ):
-        self.screenPixelPos = (newX, newY)
-        self.screenNearestTilePos = (int(newY / 16), int(newX / 16)) # nearest-tile position of the screen from the UL corner
-        self.screenPixelOffset = (newX - self.screenNearestTilePos[1]*16, newY - self.screenNearestTilePos[0]*16)
-        
-    def GetScreenPos (self):
-        return self.screenPixelPos
-        
-    def GetLevelNum (self):
-        return self.levelNum
-    
-    def SetNextLevel (self):
-        self.levelNum += 1
-        
-        self.SetMode( 4 )
-        thisLevel.LoadLevel( thisGame.GetLevelNum() )
-        
-        player.velX = 0
-        player.velY = 0
-        player.anim_pacmanCurrent = player.anim_pacmanS
-        
-        
-    def SetMode (self, newMode):
-        self.mode = newMode
-        self.modeTimer = 0
-        # print " ***** GAME MODE IS NOW ***** " + str(newMode)
-        
-class node ():
-    
-    def __init__ (self):
-        self.g = -1 # movement cost to move from previous node to this one (usually +10)
-        self.h = -1 # estimated movement cost to move from this node to the ending node (remaining horizontal and vertical steps * 10)
-        self.f = -1 # total movement cost of this node (= g + h)
-        # parent node - used to trace path back to the starting node at the end
-        self.parent = (-1, -1)
-        # node type - 0 for empty space, 1 for wall (optionally, 2 for starting node and 3 for end)
-        self.type = -1
-        
-class path_finder ():
-    
-    def __init__ (self):
-        # map is a 1-DIMENSIONAL array.
-        # use the Unfold( (row, col) ) function to convert a 2D coordinate pair
-        # into a 1D index to use with this array.
-        self.map = {}
-        self.size = (-1, -1) # rows by columns
-        
-        self.pathChainRev = ""
-        self.pathChain = ""
-                
-        # starting and ending nodes
-        self.start = (-1, -1)
-        self.end = (-1, -1)
-        
-        # current node (used by algorithm)
-        self.current = (-1, -1)
-        
-        # open and closed lists of nodes to consider (used by algorithm)
-        self.openList = []
-        self.closedList = []
-        
-        # used in algorithm (adjacent neighbors path finder is allowed to consider)
-        self.neighborSet = [ (0, -1), (0, 1), (-1, 0), (1, 0) ]
-        
-    def ResizeMap (self, numRows, numCols):
-        self.map = {}
-        self.size = (numRows, numCols)
-
-        # initialize path_finder map to a 2D array of empty nodes
-        for row in range(0, self.size[0], 1):
-            for col in range(0, self.size[1], 1):
-                self.Set( row, col, node() )
-                self.SetType( row, col, 0 )
-        
-    def CleanUpTemp (self):
-        
-        # this resets variables needed for a search (but preserves the same map / maze)
-    
-        self.pathChainRev = ""
-        self.pathChain = ""
-        self.current = (-1, -1)
-        self.openList = []
-        self.closedList = []
-        
-    def FindPath (self, startPos, endPos ):
-        
-        self.CleanUpTemp()
-        
-        # (row, col) tuples
-        self.start = startPos
-        self.end = endPos
-        
-        # add start node to open list
-        self.AddToOpenList( self.start )
-        self.SetG ( self.start, 0 )
-        self.SetH ( self.start, 0 )
-        self.SetF ( self.start, 0 )
-        
-        doContinue = True
-        
-        while (doContinue == True):
-        
-            thisLowestFNode = self.GetLowestFNode()
-
-            if not thisLowestFNode == self.end and not thisLowestFNode == False:
-                self.current = thisLowestFNode
-                self.RemoveFromOpenList( self.current )
-                self.AddToClosedList( self.current )
-                
-                for offset in self.neighborSet:
-                    thisNeighbor = (self.current[0] + offset[0], self.current[1] + offset[1])
-                    
-                    if not thisNeighbor[0] < 0 and not thisNeighbor[1] < 0 and not thisNeighbor[0] > self.size[0] - 1 and not thisNeighbor[1] > self.size[1] - 1 and not self.GetType( thisNeighbor ) == 1:
-                        cost = self.GetG( self.current ) + 10
-                        
-                        if self.IsInOpenList( thisNeighbor ) and cost < self.GetG( thisNeighbor ):
-                            self.RemoveFromOpenList( thisNeighbor )
-                            
-                        #if self.IsInClosedList( thisNeighbor ) and cost < self.GetG( thisNeighbor ):
-                        #   self.RemoveFromClosedList( thisNeighbor )
-                            
-                        if not self.IsInOpenList( thisNeighbor ) and not self.IsInClosedList( thisNeighbor ):
-                            self.AddToOpenList( thisNeighbor )
-                            self.SetG( thisNeighbor, cost )
-                            self.CalcH( thisNeighbor )
-                            self.CalcF( thisNeighbor )
-                            self.SetParent( thisNeighbor, self.current )
-            else:
-                doContinue = False
-                        
-        if thisLowestFNode == False:
-            return False
-                        
-        # reconstruct path
-        self.current = self.end
-        while not self.current == self.start:
-            # build a string representation of the path using R, L, D, U
-            if self.current[1] > self.GetParent(self.current)[1]:
-                self.pathChainRev += 'R' 
-            elif self.current[1] < self.GetParent(self.current)[1]:
-                self.pathChainRev += 'L'
-            elif self.current[0] > self.GetParent(self.current)[0]:
-                self.pathChainRev += 'D'
-            elif self.current[0] < self.GetParent(self.current)[0]:
-                self.pathChainRev += 'U'
-            self.current = self.GetParent(self.current)
-            self.SetType( self.current[0],self.current[1], 4)
-            
-        # because pathChainRev was constructed in reverse order, it needs to be reversed!
-        for i in range(len(self.pathChainRev) - 1, -1, -1):
-            self.pathChain += self.pathChainRev[i]
-        
-        # set start and ending positions for future reference
-        self.SetType( self.start[0],self.start[1], 2)
-        self.SetType( self.end[0],self.start[1], 3)
-        
-        return self.pathChain
-
-    def Unfold (self, row,col):
-        # this function converts a 2D array coordinate pair (row, col)
-        # to a 1D-array index, for the object's 1D map array.
-        return (row * self.size[1]) + col
-    
-    def Set (self, row,col, newNode):
-        # sets the value of a particular map cell (usually refers to a node object)
-        self.map[ self.Unfold(row, col) ] = newNode
-        
-    def GetType (self,val):
-        row,col = val
-        return self.map[ self.Unfold(row, col) ].type
-        
-    def SetType (self,row,col, newValue):
-        self.map[ self.Unfold(row, col) ].type = newValue
-
-    def GetF (self, val):
-        row,col = val
-        return self.map[ self.Unfold(row, col) ].f
-
-    def GetG (self, val):
-        row,col = val
-        return self.map[ self.Unfold(row, col) ].g
-    
-    def GetH (self, val):
-        row,col = val
-        return self.map[ self.Unfold(row, col) ].h
-        
-    def SetG (self, val, newValue ):
-        row,col = val
-        self.map[ self.Unfold(row, col) ].g = newValue
-
-    def SetH (self, val, newValue ):
-        row,col = val
-        self.map[ self.Unfold(row, col) ].h = newValue
-        
-    def SetF (self, val, newValue ):
-        row,col = val
-        self.map[ self.Unfold(row, col) ].f = newValue
-        
-    def CalcH (self, val):
-        row,col = val
-        self.map[ self.Unfold(row, col) ].h = abs(row - self.end[0]) + abs(col - self.end[0])
-        
-    def CalcF (self, val):
-        row,col = val
-        unfoldIndex = self.Unfold(row, col)
-        self.map[unfoldIndex].f = self.map[unfoldIndex].g + self.map[unfoldIndex].h
-    
-    def AddToOpenList (self, val):
-        row,col = val
-        self.openList.append( (row, col) )
-        
-    def RemoveFromOpenList (self, val ):
-        row,col = val
-        self.openList.remove( (row, col) )
-        
-    def IsInOpenList (self, val ):
-        row,col = val
-        if self.openList.count( (row, col) ) > 0:
-            return True
-        else:
-            return False
-        
-    def GetLowestFNode (self):
-        lowestValue = 1000 # start arbitrarily high
-        lowestPair = (-1, -1)
-        
-        for iOrderedPair in self.openList:
-            if self.GetF( iOrderedPair ) < lowestValue:
-                lowestValue = self.GetF( iOrderedPair )
-                lowestPair = iOrderedPair
-        
-        if not lowestPair == (-1, -1):
-            return lowestPair
-        else:
-            return False
-        
-    def AddToClosedList (self, val ):
-        row,col = val
-        self.closedList.append( (row, col) )
-        
-    def IsInClosedList (self, val ):
-        row,col = val
-        if self.closedList.count( (row, col) ) > 0:
-            return True
-        else:
-            return False
-
-    def SetParent (self, val, val2 ):
-        row,col = val
-        parentRow,parentCol = val2
-        self.map[ self.Unfold(row, col) ].parent = (parentRow, parentCol)
-
-    def GetParent (self, val ):
-        row,col = val
-        return self.map[ self.Unfold(row, col) ].parent
-        
-    def draw (self):
-        for row in range(0, self.size[0], 1):
-            for col in range(0, self.size[1], 1):
-            
-                thisTile = self.GetType((row, col))
-                screen.blit (tileIDImage[ thisTile ], (col * 32, row * 32))
-        
-class ghost ():
-    def __init__ (self, ghostID):
-        self.x = 0
-        self.y = 0
-        self.velX = 0
-        self.velY = 0
-        self.speed = 1
-        
-        self.nearestRow = 0
-        self.nearestCol = 0
-        
-        self.id = ghostID
-        
-        # ghost "state" variable
-        # 1 = normal
-        # 2 = vulnerable
-        # 3 = spectacles
-        self.state = 1
-        
-        self.homeX = 0
-        self.homeY = 0
-        
-        self.currentPath = ""
-        
-        self.anim = {}
-        for i in range(1, 7, 1):
-            self.anim[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","ghost " + str(i) + ".gif")).convert()
-            
-            # change the ghost color in this frame
-            for y in range(0, 16, 1):
-                for x in range(0, 16, 1):
-                
-                    if self.anim[i].get_at( (x, y) ) == (255, 0, 0, 255):
-                        # default, red ghost body color
-                        self.anim[i].set_at( (x, y), ghostcolor[ self.id ] )
-            
-        self.animFrame = 1
-        self.animDelay = 0
-        
-    def Draw (self):
-        
-        if thisGame.mode == 3:
-            return False
-        
-        
-        # ghost eyes --
-        for y in range(4, 8, 1):
-            for x in range(3, 7, 1):
-                self.anim[ self.animFrame ].set_at( (x, y), (255, 255, 255, 255) )  
-                self.anim[ self.animFrame ].set_at( (x+6, y), (255, 255, 255, 255) )
-                
-                if player.x > self.x and player.y > self.y:
-                    #player is to lower-right
-                    pupilSet = (5, 6)
-                elif player.x < self.x and player.y > self.y:
-                    #player is to lower-left
-                    pupilSet = (3, 6)
-                elif player.x > self.x and player.y < self.y:
-                    #player is to upper-right
-                    pupilSet = (5, 4)
-                elif player.x < self.x and player.y < self.y:
-                    #player is to upper-left
-                    pupilSet = (3, 4)
-                else:
-                    pupilSet = (4, 6)
-                    
-        for y in range(pupilSet[1], pupilSet[1] + 2, 1):
-            for x in range(pupilSet[0], pupilSet[0] + 2, 1):
-                self.anim[ self.animFrame ].set_at( (x, y), (0, 0, 255, 255) )  
-                self.anim[ self.animFrame ].set_at( (x+6, y), (0, 0, 255, 255) )    
-        # -- end ghost eyes
-        
-        if self.state == 1:
-            # draw regular ghost (this one)
-            screen.blit (self.anim[ self.animFrame ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
-        elif self.state == 2:
-            # draw vulnerable ghost
-            
-            if thisGame.ghostTimer > 100:
-                # blue
-                screen.blit (ghosts[4].anim[ self.animFrame ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
-            else:
-                # blue/white flashing
-                tempTimerI = int(thisGame.ghostTimer / 10)
-                if tempTimerI == 1 or tempTimerI == 3 or tempTimerI == 5 or tempTimerI == 7 or tempTimerI == 9:
-                    screen.blit (ghosts[5].anim[ self.animFrame ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
-                else:
-                    screen.blit (ghosts[4].anim[ self.animFrame ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
-            
-        elif self.state == 3:
-            # draw glasses
-            screen.blit (tileIDImage[ tileID[ 'glasses' ] ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
-        
-        if thisGame.mode == 6 or thisGame.mode == 7:
-            # don't animate ghost if the level is complete
-            return False
-        
-        self.animDelay += 1
-        
-        if self.animDelay == 2:
-            self.animFrame += 1 
-        
-            if self.animFrame == 7:
-                # wrap to beginning
-                self.animFrame = 1
-                
-            self.animDelay = 0
-            
-    def Move (self):
-        
-
-        self.x += self.velX
-        self.y += self.velY
-        
-        self.nearestRow = int(((self.y + 8) / 16))
-        self.nearestCol = int(((self.x + 8) / 16))
-
-        if (self.x % 16) == 0 and (self.y % 16) == 0:
-            # if the ghost is lined up with the grid again
-            # meaning, it's time to go to the next path item
-            
-            if (self.currentPath):
-                self.currentPath = self.currentPath[1:]
-                self.FollowNextPathWay()
-        
-            else:
-                self.x = self.nearestCol * 16
-                self.y = self.nearestRow * 16
-            
-                # chase pac-man
-                self.currentPath = path.FindPath( (self.nearestRow, self.nearestCol), (player.nearestRow, player.nearestCol) )
-                self.FollowNextPathWay()
-            
-    def FollowNextPathWay (self):
-        
-        # print "Ghost " + str(self.id) + " rem: " + self.currentPath
-        
-        # only follow this pathway if there is a possible path found!
-        if not self.currentPath == False:
-        
-            if len(self.currentPath) > 0:
-                if self.currentPath[0] == "L":
-                    (self.velX, self.velY) = (-self.speed, 0)
-                elif self.currentPath[0] == "R":
-                    (self.velX, self.velY) = (self.speed, 0)
-                elif self.currentPath[0] == "U":
-                    (self.velX, self.velY) = (0, -self.speed)
-                elif self.currentPath[0] == "D":
-                    (self.velX, self.velY) = (0, self.speed)
-                    
-            else:
-                # this ghost has reached his destination!!
-                
-                if not self.state == 3:
-                    # chase pac-man
-                    self.currentPath = path.FindPath( (self.nearestRow, self.nearestCol), (player.nearestRow, player.nearestCol) )
-                    self.FollowNextPathWay()
-                
-                else:
-                    # glasses found way back to ghost box
-                    self.state = 1
-                    self.speed = self.speed / 4
-                    
-                    # give ghost a path to a random spot (containing a pellet)
-                    (randRow, randCol) = (0, 0)
-
-                    while not thisLevel.GetMapTile(randRow, randCol) == tileID[ 'pellet' ] or (randRow, randCol) == (0, 0):
-                        randRow = random.randint(1, thisLevel.lvlHeight - 2)
-                        randCol = random.randint(1, thisLevel.lvlWidth - 2)
-
-                    self.currentPath = path.FindPath( (self.nearestRow, self.nearestCol), (randRow, randCol) )
-                    self.FollowNextPathWay()
-
-class fruit ():
-    def __init__ (self):
-        # when fruit is not in use, it's in the (-1, -1) position off-screen.
-        self.slowTimer = 0
-        self.x = -16
-        self.y = -16
-        self.velX = 0
-        self.velY = 0
-        self.speed = 1
-        self.active = False
-        
-        self.bouncei = 0
-        self.bounceY = 0
-        
-        self.nearestRow = (-1, -1)
-        self.nearestCol = (-1, -1)
-        
-        self.imFruit = {}
-        for i in range(0, 5, 1):
-            self.imFruit[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","fruit " + str(i) + ".gif")).convert()
-        
-        self.currentPath = ""
-        self.fruitType = 1
-        
-    def Draw (self):
-        
-        if thisGame.mode == 3 or self.active == False:
-            return False
-        
-        screen.blit (self.imFruit[ self.fruitType ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1] - self.bounceY))
-
-            
-    def Move (self):
-        
-        if self.active == False:
-            return False
-        
-        self.bouncei += 1
-        if self.bouncei == 1:
-            self.bounceY = 2
-        elif self.bouncei == 2:
-            self.bounceY = 4
-        elif self.bouncei == 3:
-            self.bounceY = 5
-        elif self.bouncei == 4:
-            self.bounceY = 5
-        elif self.bouncei == 5:
-            self.bounceY = 6
-        elif self.bouncei == 6:
-            self.bounceY = 6
-        elif self.bouncei == 9:
-            self.bounceY = 6
-        elif self.bouncei == 10:
-            self.bounceY = 5
-        elif self.bouncei == 11:
-            self.bounceY = 5
-        elif self.bouncei == 12:
-            self.bounceY = 4
-        elif self.bouncei == 13:
-            self.bounceY = 3
-        elif self.bouncei == 14:
-            self.bounceY = 2
-        elif self.bouncei == 15:
-            self.bounceY = 1
-        elif self.bouncei == 16:
-            self.bounceY = 0
-            self.bouncei = 0
-            snd_fruitbounce.play()
-        
-        self.slowTimer += 1
-        if self.slowTimer == 2:
-            self.slowTimer = 0
-            
-            self.x += self.velX
-            self.y += self.velY
-            
-            self.nearestRow = int(((self.y + 8) / 16))
-            self.nearestCol = int(((self.x + 8) / 16))
-
-            if (self.x % 16) == 0 and (self.y % 16) == 0:
-                # if the fruit is lined up with the grid again
-                # meaning, it's time to go to the next path item
-                
-                if len(self.currentPath) > 0:
-                    self.currentPath = self.currentPath[1:]
-                    self.FollowNextPathWay()
-            
-                else:
-                    self.x = self.nearestCol * 16
-                    self.y = self.nearestRow * 16
-                    
-                    self.active = False
-                    thisGame.fruitTimer = 0
-            
-    def FollowNextPathWay (self):
-        
-
-        # only follow this pathway if there is a possible path found!
-        if not self.currentPath == False:
-        
-            if len(self.currentPath) > 0:
-                if self.currentPath[0] == "L":
-                    (self.velX, self.velY) = (-self.speed, 0)
-                elif self.currentPath[0] == "R":
-                    (self.velX, self.velY) = (self.speed, 0)
-                elif self.currentPath[0] == "U":
-                    (self.velX, self.velY) = (0, -self.speed)
-                elif self.currentPath[0] == "D":
-                    (self.velX, self.velY) = (0, self.speed)
-
-class pacman ():
-    
-    def __init__ (self):
-        self.x = 0
-        self.y = 0
-        self.velX = 0
-        self.velY = 0
-        self.speed = 2
-        
-        self.nearestRow = 0
-        self.nearestCol = 0
-        
-        self.homeX = 0
-        self.homeY = 0
-        
-        self.anim_pacmanL = {}
-        self.anim_pacmanR = {}
-        self.anim_pacmanU = {}
-        self.anim_pacmanD = {}
-        self.anim_pacmanS = {}
-        self.anim_pacmanCurrent = {}
-        
-        for i in range(1, 9, 1):
-            self.anim_pacmanL[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","pacman-l " + str(i) + ".gif")).convert()
-            self.anim_pacmanR[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","pacman-r " + str(i) + ".gif")).convert()
-            self.anim_pacmanU[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","pacman-u " + str(i) + ".gif")).convert()
-            self.anim_pacmanD[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","pacman-d " + str(i) + ".gif")).convert()
-            self.anim_pacmanS[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","pacman.gif")).convert()
-
-        self.pelletSndNum = 0
-        
-    def Move (self):
-        
-        self.nearestRow = int(((self.y + 8) / 16))
-        self.nearestCol = int(((self.x + 8) / 16))
-
-        # make sure the current velocity will not cause a collision before moving
-        if not thisLevel.CheckIfHitWall(self.x + self.velX, self.y + self.velY, self.nearestRow, self.nearestCol):
-            # it's ok to Move
-            self.x += self.velX
-            self.y += self.velY
-            
-            # check for collisions with other tiles (pellets, etc)
-            thisLevel.CheckIfHitSomething(self.x, self.y, self.nearestRow, self.nearestCol)
-            
-            # check for collisions with the ghosts
-            for i in range(0, 4, 1):
-                if thisLevel.CheckIfHit( self.x, self.y, ghosts[i].x, ghosts[i].y, 8):
-                    # hit a ghost
-                    
-                    if ghosts[i].state == 1:
-                        # ghost is normal
-                        thisGame.SetMode( 2 )
-                        
-                    elif ghosts[i].state == 2:
-                        # ghost is vulnerable
-                        # give them glasses
-                        # make them run
-                        thisGame.AddToScore(thisGame.ghostValue)
-                        thisGame.ghostValue = thisGame.ghostValue * 2
-                        snd_eatgh.play()
-                        
-                        ghosts[i].state = 3
-                        ghosts[i].speed = ghosts[i].speed * 4
-                        # and send them to the ghost box
-                        ghosts[i].x = ghosts[i].nearestCol * 16
-                        ghosts[i].y = ghosts[i].nearestRow * 16
-                        ghosts[i].currentPath = path.FindPath( (ghosts[i].nearestRow, ghosts[i].nearestCol), (thisLevel.GetGhostBoxPos()[0]+1, thisLevel.GetGhostBoxPos()[1]) )
-                        ghosts[i].FollowNextPathWay()
-                        
-                        # set game mode to brief pause after eating
-                        thisGame.SetMode( 5 )
-                        
-            # check for collisions with the fruit
-            if thisFruit.active == True:
-                if thisLevel.CheckIfHit( self.x, self.y, thisFruit.x, thisFruit.y, 8):
-                    thisGame.AddToScore(2500)
-                    thisFruit.active = False
-                    thisGame.fruitTimer = 0
-                    thisGame.fruitScoreTimer = 120
-                    snd_eatfruit.play()
-        
-        else:
-            # we're going to hit a wall -- stop moving
-            self.velX = 0
-            self.velY = 0
-            
-        # deal with power-pellet ghost timer
-        if thisGame.ghostTimer > 0:
-            thisGame.ghostTimer -= 1
-            
-            if thisGame.ghostTimer == 0:
-                for i in range(0, 4, 1):
-                    if ghosts[i].state == 2:
-                        ghosts[i].state = 1
-                self.ghostValue = 0
-                
-        # deal with fruit timer
-        thisGame.fruitTimer += 1
-        if thisGame.fruitTimer == 500:
-            pathwayPair = thisLevel.GetPathwayPairPos()
-            
-            if not pathwayPair == False:
-            
-                pathwayEntrance = pathwayPair[0]
-                pathwayExit = pathwayPair[1]
-                
-                thisFruit.active = True
-                
-                thisFruit.nearestRow = pathwayEntrance[0]
-                thisFruit.nearestCol = pathwayEntrance[1]
-                
-                thisFruit.x = thisFruit.nearestCol * 16
-                thisFruit.y = thisFruit.nearestRow * 16
-                
-                thisFruit.currentPath = path.FindPath( (thisFruit.nearestRow, thisFruit.nearestCol), pathwayExit )
-                thisFruit.FollowNextPathWay()
-            
-        if thisGame.fruitScoreTimer > 0:
-            thisGame.fruitScoreTimer -= 1
-            
-        
-    def Draw (self):
-        
-        if thisGame.mode == 3:
-            return False
-        
-        # set the current frame array to match the direction pacman is facing
-        if self.velX > 0:
-            self.anim_pacmanCurrent = self.anim_pacmanR
-        elif self.velX < 0:
-            self.anim_pacmanCurrent = self.anim_pacmanL
-        elif self.velY > 0:
-            self.anim_pacmanCurrent = self.anim_pacmanD
-        elif self.velY < 0:
-            self.anim_pacmanCurrent = self.anim_pacmanU
-            
-        screen.blit (self.anim_pacmanCurrent[ self.animFrame ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
-        
-        if thisGame.mode == 1:
-            if not self.velX == 0 or not self.velY == 0:
-                # only Move mouth when pacman is moving
-                self.animFrame += 1 
-            
-            if self.animFrame == 9:
-                # wrap to beginning
-                self.animFrame = 1
-            
-class level ():
-    
-    def __init__ (self):
-        self.lvlWidth = 0
-        self.lvlHeight = 0
-        self.edgeLightColor = (255, 255, 0, 255)
-        self.edgeShadowColor = (255, 150, 0, 255)
-        self.fillColor = (0, 255, 255, 255)
-        self.pelletColor = (255, 255, 255, 255)
-        
-        self.map = {}
-        
-        self.pellets = 0
-        self.powerPelletBlinkTimer = 0
-        
-    def SetMapTile (self, row, col, newValue):
-        self.map[ (row * self.lvlWidth) + col ] = newValue
-        
-    def GetMapTile (self, row, col):
-        if row >= 0 and row < self.lvlHeight and col >= 0 and col < self.lvlWidth:
-            return self.map[ (row * self.lvlWidth) + col ]
-        else:
-            return 0
-    
-    def IsWall (self, row, col):
-    
-        if row > thisLevel.lvlHeight - 1 or row < 0:
-            return True
-        
-        if col > thisLevel.lvlWidth - 1 or col < 0:
-            return True
-    
-        # check the offending tile ID
-        result = thisLevel.GetMapTile(row, col)
-
-        # if the tile was a wall
-        if result >= 100 and result <= 199:
-            return True
-        else:
-            return False
-    
-                    
-    def CheckIfHitWall (self, possiblePlayerX, possiblePlayerY, row, col):
-    
-        numCollisions = 0
-        
-        # check each of the 9 surrounding tiles for a collision
-        for iRow in range(row - 1, row + 2, 1):
-            for iCol in range(col - 1, col + 2, 1):
-            
-                if  (possiblePlayerX - (iCol * 16) < 16) and (possiblePlayerX - (iCol * 16) > -16) and (possiblePlayerY - (iRow * 16) < 16) and (possiblePlayerY - (iRow * 16) > -16):
-                    
-                    if self.IsWall(iRow, iCol):
-                        numCollisions += 1
-                        
-        if numCollisions > 0:
-            return True
-        else:
-            return False
-        
-        
-    def CheckIfHit (self, playerX, playerY, x, y, cushion):
-    
-        if (playerX - x < cushion) and (playerX - x > -cushion) and (playerY - y < cushion) and (playerY - y > -cushion):
-            return True
-        else:
-            return False
-
-
-    def CheckIfHitSomething (self, playerX, playerY, row, col):
-    
-        for iRow in range(row - 1, row + 2, 1):
-            for iCol in range(col - 1, col + 2, 1):
-            
-                if  (playerX - (iCol * 16) < 16) and (playerX - (iCol * 16) > -16) and (playerY - (iRow * 16) < 16) and (playerY - (iRow * 16) > -16):
-                    # check the offending tile ID
-                    result = thisLevel.GetMapTile(iRow, iCol)
-        
-                    if result == tileID[ 'pellet' ]:
-                        # got a pellet
-                        thisLevel.SetMapTile(iRow, iCol, 0)
-                        snd_pellet[player.pelletSndNum].play()
-                        player.pelletSndNum = 1 - player.pelletSndNum
-                        
-                        thisLevel.pellets -= 1
-                        
-                        thisGame.AddToScore(10)
-                        
-                        if thisLevel.pellets == 0:
-                            # no more pellets left!
-                            # WON THE LEVEL
-                            thisGame.SetMode( 6 )
-                            
-                        
-                    elif result == tileID[ 'pellet-power' ]:
-                        # got a power pellet
-                        thisLevel.SetMapTile(iRow, iCol, 0)
-                        snd_powerpellet.play()
-                        
-                        thisGame.AddToScore(100)
-                        thisGame.ghostValue = 200
-                        
-                        thisGame.ghostTimer = 360
-                        for i in range(0, 4, 1):
-                            if ghosts[i].state == 1:
-                                ghosts[i].state = 2
-                        
-                    elif result == tileID[ 'door-h' ]:
-                        # ran into a horizontal door
-                        for i in range(0, thisLevel.lvlWidth, 1):
-                            if not i == iCol:
-                                if thisLevel.GetMapTile(iRow, i) == tileID[ 'door-h' ]:
-                                    player.x = i * 16
-                                    
-                                    if player.velX > 0:
-                                        player.x += 16
-                                    else:
-                                        player.x -= 16
-                                        
-                    elif result == tileID[ 'door-v' ]:
-                        # ran into a vertical door
-                        for i in range(0, thisLevel.lvlHeight, 1):
-                            if not i == iRow:
-                                if thisLevel.GetMapTile(i, iCol) == tileID[ 'door-v' ]:
-                                    player.y = i * 16
-                                    
-                                    if player.velY > 0:
-                                        player.y += 16
-                                    else:
-                                        player.y -= 16
-                                        
-    def GetGhostBoxPos (self):
-        
-        for row in range(0, self.lvlHeight, 1):
-            for col in range(0, self.lvlWidth, 1):
-                if self.GetMapTile(row, col) == tileID[ 'ghost-door' ]:
-                    return (row, col)
-                
-        return False
-    
-    def GetPathwayPairPos (self):
-        
-        doorArray = []
-        
-        for row in range(0, self.lvlHeight, 1):
-            for col in range(0, self.lvlWidth, 1):
-                if self.GetMapTile(row, col) == tileID[ 'door-h' ]:
-                    # found a horizontal door
-                    doorArray.append( (row, col) )
-                elif self.GetMapTile(row, col) == tileID[ 'door-v' ]:
-                    # found a vertical door
-                    doorArray.append( (row, col) )
-        
-        if len(doorArray) == 0:
-            return False
-        
-        chosenDoor = random.randint(0, len(doorArray) - 1)
-        
-        if self.GetMapTile( doorArray[chosenDoor][0],doorArray[chosenDoor][1] ) == tileID[ 'door-h' ]:
-            # horizontal door was chosen
-            # look for the opposite one
-            for i in range(0, thisLevel.lvlWidth, 1):
-                if not i == doorArray[chosenDoor][1]:
-                    if thisLevel.GetMapTile(doorArray[chosenDoor][0], i) == tileID[ 'door-h' ]:
-                        return doorArray[chosenDoor], (doorArray[chosenDoor][0], i)
-        else:
-            # vertical door was chosen
-            # look for the opposite one
-            for i in range(0, thisLevel.lvlHeight, 1):
-                if not i == doorArray[chosenDoor][0]:
-                    if thisLevel.GetMapTile(i, doorArray[chosenDoor][1]) == tileID[ 'door-v' ]:
-                        return doorArray[chosenDoor], (i, doorArray[chosenDoor][1])
-                    
-        return False
-        
-    def PrintMap (self):
-        
-        for row in range(0, self.lvlHeight, 1):
-            outputLine = ""
-            for col in range(0, self.lvlWidth, 1):
-            
-                outputLine += str( self.GetMapTile(row, col) ) + ", "
-                
-            # print outputLine
-            
-    def DrawMap (self):
-        
-        self.powerPelletBlinkTimer += 1
-        if self.powerPelletBlinkTimer == 60:
-            self.powerPelletBlinkTimer = 0
-        
-        for row in range(-1, thisGame.screenTileSize[0] +1, 1):
-            outputLine = ""
-            for col in range(-1, thisGame.screenTileSize[1] +1, 1):
-
-                # row containing tile that actually goes here
-                actualRow = thisGame.screenNearestTilePos[0] + row
-                actualCol = thisGame.screenNearestTilePos[1] + col
-
-                useTile = self.GetMapTile(actualRow, actualCol)
-                if not useTile == 0 and not useTile == tileID['door-h'] and not useTile == tileID['door-v']:
-                    # if this isn't a blank tile
-
-                    if useTile == tileID['pellet-power']:
-                        if self.powerPelletBlinkTimer < 30:
-                            screen.blit (tileIDImage[ useTile ], (col * 16 - thisGame.screenPixelOffset[0], row * 16 - thisGame.screenPixelOffset[1]) )
-
-                    elif useTile == tileID['showlogo']:
-                        screen.blit (thisGame.imLogo, (col * 16 - thisGame.screenPixelOffset[0], row * 16 - thisGame.screenPixelOffset[1]) )
-                    
-                    elif useTile == tileID['hiscores']:
-                            screen.blit(thisGame.imHiscores,(col*16-thisGame.screenPixelOffset[0],row*16-thisGame.screenPixelOffset[1]))
-                    
-                    else:
-                        screen.blit (tileIDImage[ useTile ], (col * 16 - thisGame.screenPixelOffset[0], row * 16 - thisGame.screenPixelOffset[1]) )
-        
-    def LoadLevel (self, levelNum):
-        
-        self.map = {}
-        
-        self.pellets = 0
-        
-        f = open(os.path.join(SCRIPT_PATH,"res","levels",str(levelNum) + ".txt"), 'r')
-        # ANDY -- edit this
-        #fileOutput = f.read()
-        #str_splitByLine = fileOutput.split('\n')
-        lineNum=-1
-        rowNum = 0
-        useLine = False
-        isReadingLevelData = False
-          
-        for line in f:
-
-          lineNum += 1
-        
-            # print " ------- Level Line " + str(lineNum) + " -------- "
-          while len(line)>0 and (line[-1]=="\n" or line[-1]=="\r"): line=line[:-1]
-          while len(line)>0 and (line[0]=="\n" or line[0]=="\r"): line=line[1:]
-          str_splitBySpace = line.split(' ')
-            
-            
-          j = str_splitBySpace[0]
-                
-          if (j == "'" or j == ""):
-                # comment / whitespace line
-                # print " ignoring comment line.. "
-                useLine = False
-          elif j == "#":
-                # special divider / attribute line
-                useLine = False
-                
-                firstWord = str_splitBySpace[1]
-                
-                if firstWord == "lvlwidth":
-                    self.lvlWidth = int( str_splitBySpace[2] )
-                    # print "Width is " + str( self.lvlWidth )
-                    
-                elif firstWord == "lvlheight":
-                    self.lvlHeight = int( str_splitBySpace[2] )
-                    # print "Height is " + str( self.lvlHeight )
-                    
-                elif firstWord == "edgecolor":
-                    # edge color keyword for backwards compatibility (single edge color) mazes
-                    red = int( str_splitBySpace[2] )
-                    green = int( str_splitBySpace[3] )
-                    blue = int( str_splitBySpace[4] )
-                    self.edgeLightColor = (red, green, blue, 255)
-                    self.edgeShadowColor = (red, green, blue, 255)
-                    
-                elif firstWord == "edgelightcolor":
-                    red = int( str_splitBySpace[2] )
-                    green = int( str_splitBySpace[3] )
-                    blue = int( str_splitBySpace[4] )
-                    self.edgeLightColor = (red, green, blue, 255)
-                    
-                elif firstWord == "edgeshadowcolor":
-                    red = int( str_splitBySpace[2] )
-                    green = int( str_splitBySpace[3] )
-                    blue = int( str_splitBySpace[4] )
-                    self.edgeShadowColor = (red, green, blue, 255)
-                
-                elif firstWord == "fillcolor":
-                    red = int( str_splitBySpace[2] )
-                    green = int( str_splitBySpace[3] )
-                    blue = int( str_splitBySpace[4] )
-                    self.fillColor = (red, green, blue, 255)
-                    
-                elif firstWord == "pelletcolor":
-                    red = int( str_splitBySpace[2] )
-                    green = int( str_splitBySpace[3] )
-                    blue = int( str_splitBySpace[4] )
-                    self.pelletColor = (red, green, blue, 255)
-                    
-                elif firstWord == "fruittype":
-                    thisFruit.fruitType = int( str_splitBySpace[2] )
-                    
-                elif firstWord == "startleveldata":
-                    isReadingLevelData = True
-                        # print "Level data has begun"
-                    rowNum = 0
-                    
-                elif firstWord == "endleveldata":
-                    isReadingLevelData = False
-                    # print "Level data has ended"
-                    
-          else:
-                useLine = True
-                
-                
-            # this is a map data line   
-          if useLine == True:
-                
-                if isReadingLevelData == True:
-                        
-                    # print str( len(str_splitBySpace) ) + " tiles in this column"
-                    
-                    for k in range(0, self.lvlWidth, 1):
-                        self.SetMapTile(rowNum, k, int(str_splitBySpace[k]) )
-                        
-                        thisID = int(str_splitBySpace[k])
-                        if thisID == 4: 
-                            # starting position for pac-man
-                            
-                            player.homeX = k * 16
-                            player.homeY = rowNum * 16
-                            self.SetMapTile(rowNum, k, 0 )
-                            
-                        elif thisID >= 10 and thisID <= 13:
-                            # one of the ghosts
-                            
-                            ghosts[thisID - 10].homeX = k * 16
-                            ghosts[thisID - 10].homeY = rowNum * 16
-                            self.SetMapTile(rowNum, k, 0 )
-                        
-                        elif thisID == 2:
-                            # pellet
-                            
-                            self.pellets += 1
-                            
-                    rowNum += 1
-                    
-                
-        # reload all tiles and set appropriate colors
-        GetCrossRef()
-
-        # load map into the pathfinder object
-        path.ResizeMap( self.lvlHeight, self.lvlWidth )
-        
-        for row in range(0, path.size[0], 1):
-            for col in range(0, path.size[1], 1):
-                if self.IsWall( row, col ):
-                    path.SetType( row, col, 1 )
-                else:
-                    path.SetType( row, col, 0 )
-        
-        # do all the level-starting stuff
-        self.Restart()
-        
-    def Restart (self):
-        
-        for i in range(0, 4, 1):
-            # move ghosts back to home
-
-            ghosts[i].x = ghosts[i].homeX
-            ghosts[i].y = ghosts[i].homeY
-            ghosts[i].velX = 0
-            ghosts[i].velY = 0
-            ghosts[i].state = 1
-            ghosts[i].speed = 1
-            ghosts[i].Move()
-            
-            # give each ghost a path to a random spot (containing a pellet)
-            (randRow, randCol) = (0, 0)
-
-            while not self.GetMapTile(randRow, randCol) == tileID[ 'pellet' ] or (randRow, randCol) == (0, 0):
-                randRow = random.randint(1, self.lvlHeight - 2)
-                randCol = random.randint(1, self.lvlWidth - 2)
-            
-            # print "Ghost " + str(i) + " headed towards " + str((randRow, randCol))
-            ghosts[i].currentPath = path.FindPath( (ghosts[i].nearestRow, ghosts[i].nearestCol), (randRow, randCol) )
-            ghosts[i].FollowNextPathWay()
-            
-        thisFruit.active = False
-            
-        thisGame.fruitTimer = 0
-
-        player.x = player.homeX
-        player.y = player.homeY
-        player.velX = 0
-        player.velY = 0
-        
-        player.anim_pacmanCurrent = player.anim_pacmanS
-        player.animFrame = 3
-
-
-def CheckIfCloseButton(events):
-    for event in events: 
-        if event.type == pygame.QUIT: 
-            sys.exit(0)
-
-
-def CheckInputs(): 
-    
-    if thisGame.mode == 1:
-        if pygame.key.get_pressed()[ pygame.K_RIGHT ] or (js!=None and js.get_axis(JS_XAXIS)>0):
-            if not thisLevel.CheckIfHitWall(player.x + player.speed, player.y, player.nearestRow, player.nearestCol): 
-                player.velX = player.speed
-                player.velY = 0
-                
-        elif pygame.key.get_pressed()[ pygame.K_LEFT ] or (js!=None and js.get_axis(JS_XAXIS)<0):
-            if not thisLevel.CheckIfHitWall(player.x - player.speed, player.y, player.nearestRow, player.nearestCol): 
-                player.velX = -player.speed
-                player.velY = 0
-            
-        elif pygame.key.get_pressed()[ pygame.K_DOWN ] or (js!=None and js.get_axis(JS_YAXIS)>0):
-            if not thisLevel.CheckIfHitWall(player.x, player.y + player.speed, player.nearestRow, player.nearestCol): 
-                player.velX = 0
-                player.velY = player.speed
-            
-        elif pygame.key.get_pressed()[ pygame.K_UP ] or (js!=None and js.get_axis(JS_YAXIS)<0):
-            if not thisLevel.CheckIfHitWall(player.x, player.y - player.speed, player.nearestRow, player.nearestCol):
-                player.velX = 0
-                player.velY = -player.speed
-                
-    if pygame.key.get_pressed()[ pygame.K_ESCAPE ]:
-        sys.exit(0)
-            
-    elif thisGame.mode == 3:
-        if pygame.key.get_pressed()[ pygame.K_RETURN ] or (js!=None and js.get_button(JS_STARTBUTTON)):
-            thisGame.StartNewGame()
-            
-
-    
-#      _____________________________________________
-# ___/  function: Get ID-Tilename Cross References  \______________________________________ 
-    
-def GetCrossRef ():
-
-    f = open(os.path.join(SCRIPT_PATH,"res","crossref.txt"), 'r')
-    # ANDY -- edit
-    #fileOutput = f.read()
-    #str_splitByLine = fileOutput.split('\n')
-
-    lineNum = 0
-    useLine = False
-
-    for i in f.readlines():
-        # print " ========= Line " + str(lineNum) + " ============ "
-        while len(i)>0 and (i[-1]=='\n' or i[-1]=='\r'): i=i[:-1]
-        while len(i)>0 and (i[0]=='\n' or i[0]=='\r'): i=i[1:]
-        str_splitBySpace = i.split(' ')
-        
-        j = str_splitBySpace[0]
-            
-        if (j == "'" or j == "" or j == "#"):
-            # comment / whitespace line
-            # print " ignoring comment line.. "
-            useLine = False
-        else:
-            # print str(wordNum) + ". " + j
-            useLine = True
-        
-        if useLine == True:
-            tileIDName[ int(str_splitBySpace[0]) ] = str_splitBySpace[1]
-            tileID[ str_splitBySpace[1] ] = int(str_splitBySpace[0])
-            
-            thisID = int(str_splitBySpace[0])
-            if not thisID in NO_GIF_TILES:
-                tileIDImage[ thisID ] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","tiles",str_splitBySpace[1] + ".gif")).convert()
-            else:
-                    tileIDImage[ thisID ] = pygame.Surface((16,16))
-            
-            # change colors in tileIDImage to match maze colors
-            for y in range(0, 16, 1):
-                for x in range(0, 16, 1):
-                
-                    if tileIDImage[ thisID ].get_at( (x, y) ) == (255, 206, 255, 255):
-                        # wall edge
-                        tileIDImage[ thisID ].set_at( (x, y), thisLevel.edgeLightColor )
-                        
-                    elif tileIDImage[ thisID ].get_at( (x, y) ) == (132, 0, 132, 255):
-                        # wall fill
-                        tileIDImage[ thisID ].set_at( (x, y), thisLevel.fillColor ) 
-                        
-                    elif tileIDImage[ thisID ].get_at( (x, y) ) == (255, 0, 255, 255):
-                        # pellet color
-                        tileIDImage[ thisID ].set_at( (x, y), thisLevel.edgeShadowColor )   
-                        
-                    elif tileIDImage[ thisID ].get_at( (x, y) ) == (128, 0, 128, 255):
-                        # pellet color
-                        tileIDImage[ thisID ].set_at( (x, y), thisLevel.pelletColor )   
-                
-            # print str_splitBySpace[0] + " is married to " + str_splitBySpace[1]
-        lineNum += 1
-
-
-#      __________________
-# ___/  main code block  \_____________________________________________________
-
-# create the pacman
-player = pacman()
-
-# create a path_finder object
-path = path_finder()
-
-# create ghost objects
-ghosts = {}
-for i in range(0, 6, 1):
-    # remember, ghost[4] is the blue, vulnerable ghost
-    ghosts[i] = ghost(i)
-    
-# create piece of fruit
-thisFruit = fruit()
-
-tileIDName = {} # gives tile name (when the ID# is known)
-tileID = {} # gives tile ID (when the name is known)
-tileIDImage = {} # gives tile image (when the ID# is known)
-
-# create game and level objects and load first level
-thisGame = game()
-thisLevel = level()
-thisLevel.LoadLevel( thisGame.GetLevelNum() )
-
-window = pygame.display.set_mode( thisGame.screenSize, pygame.DOUBLEBUF | pygame.HWSURFACE )
-
-# initialise the joystick
-if pygame.joystick.get_count()>0:
-  if JS_DEVNUM<pygame.joystick.get_count(): js=pygame.joystick.Joystick(JS_DEVNUM)
-  else: js=pygame.joystick.Joystick(0)
-  js.init()
-else: js=None   
-while True: 
-
-    CheckIfCloseButton( pygame.event.get() )
-    
-    if thisGame.mode == 1:
-        # normal gameplay mode
-        CheckInputs()
-        
-        thisGame.modeTimer += 1
-        player.Move()
-        for i in range(0, 4, 1):
-            ghosts[i].Move()
-        thisFruit.Move()
-            
-    elif thisGame.mode == 2:
-        # waiting after getting hit by a ghost
-        thisGame.modeTimer += 1
-        
-        if thisGame.modeTimer == 90:
-            thisLevel.Restart()
-            
-            thisGame.lives -= 1
-            if thisGame.lives == -1:
-                thisGame.updatehiscores(thisGame.score)
-                thisGame.SetMode( 3 )
-                thisGame.drawmidgamehiscores()
-            else:
-                thisGame.SetMode( 4 )
-                
-    elif thisGame.mode == 3:
-        # game over
-        CheckInputs()
-            
-    elif thisGame.mode == 4:
-        # waiting to start
-        thisGame.modeTimer += 1
-        
-        if thisGame.modeTimer == 90:
-            thisGame.SetMode( 1 )
-            player.velX = player.speed
-            
-    elif thisGame.mode == 5:
-        # brief pause after munching a vulnerable ghost
-        thisGame.modeTimer += 1
-        
-        if thisGame.modeTimer == 30:
-            thisGame.SetMode( 1 )
-            
-    elif thisGame.mode == 6:
-        # pause after eating all the pellets
-        thisGame.modeTimer += 1
-        
-        if thisGame.modeTimer == 60:
-            thisGame.SetMode( 7 )
-            oldEdgeLightColor = thisLevel.edgeLightColor
-            oldEdgeShadowColor = thisLevel.edgeShadowColor
-            oldFillColor = thisLevel.fillColor
-            
-    elif thisGame.mode == 7:
-        # flashing maze after finishing level
-        thisGame.modeTimer += 1
-        
-        whiteSet = [10, 30, 50, 70]
-        normalSet = [20, 40, 60, 80]
-        
-        if not whiteSet.count(thisGame.modeTimer) == 0:
-            # member of white set
-            thisLevel.edgeLightColor = (255, 255, 255, 255)
-            thisLevel.edgeShadowColor = (255, 255, 255, 255)
-            thisLevel.fillColor = (0, 0, 0, 255)
-            GetCrossRef()
-        elif not normalSet.count(thisGame.modeTimer) == 0:
-            # member of normal set
-            thisLevel.edgeLightColor = oldEdgeLightColor
-            thisLevel.edgeShadowColor = oldEdgeShadowColor
-            thisLevel.fillColor = oldFillColor
-            GetCrossRef()
-        elif thisGame.modeTimer == 150:
-            thisGame.SetMode ( 8 )
-            
-    elif thisGame.mode == 8:
-        # blank screen before changing levels
-        thisGame.modeTimer += 1
-        if thisGame.modeTimer == 10:
-            thisGame.SetNextLevel()
-
-    thisGame.SmartMoveScreen()
-    
-    screen.blit(img_Background, (0, 0))
-    
-    if not thisGame.mode == 8:
-        thisLevel.DrawMap()
-        
-        if thisGame.fruitScoreTimer > 0:
-            if thisGame.modeTimer % 2 == 0:
-                thisGame.DrawNumber (2500, thisFruit.x - thisGame.screenPixelPos[0] - 16, thisFruit.y - thisGame.screenPixelPos[1] + 4)
-
-        for i in range(0, 4, 1):
-            ghosts[i].Draw()
-        thisFruit.Draw()
-        player.Draw()
-        
-        if thisGame.mode == 3:
-                screen.blit(thisGame.imHiscores,(32,256))
-        
-    if thisGame.mode == 5:
-        thisGame.DrawNumber (thisGame.ghostValue / 2, player.x - thisGame.screenPixelPos[0] - 4, player.y - thisGame.screenPixelPos[1] + 6)
-    
-    
-    
-    thisGame.DrawScore()
-    
-    pygame.display.flip()
-    
-    clock.tick (60)
\ No newline at end of file
diff --git a/games/pacman/pacman_old.py b/games/pacman/pacman_old.py
deleted file mode 100644
index fc711fe..0000000
--- a/games/pacman/pacman_old.py
+++ /dev/null
@@ -1,970 +0,0 @@
-import pygame
-import random
-import numpy as np
-
-class node ():
-    
-    def __init__ (self):
-        self.g = -1 # movement cost to move from previous node to this one (usually +10)
-        self.h = -1 # estimated movement cost to move from this node to the ending node (remaining horizontal and vertical steps * 10)
-        self.f = -1 # total movement cost of this node (= g + h)
-        # parent node - used to trace path back to the starting node at the end
-        self.parent = (-1, -1)
-        # node type - 0 for empty space, 1 for wall (optionally, 2 for starting node and 3 for end)
-        self.type = -1 
-
-
-class path_finder ():
-    
-    def __init__ (self):
-        # map is a 1-DIMENSIONAL array.
-        # use the Unfold( (row, col) ) function to convert a 2D coordinate pair
-        # into a 1D index to use with this array.
-        self.map = {}
-        self.size = (-1, -1) # rows by columns
-        
-        self.pathChainRev = ""
-        self.pathChain = ""
-                
-        # starting and ending nodes
-        self.start = (-1, -1)
-        self.end = (-1, -1)
-        
-        # current node (used by algorithm)
-        self.current = (-1, -1)
-        
-        # open and closed lists of nodes to consider (used by algorithm)
-        self.openList = []
-        self.closedList = []
-        
-        # used in algorithm (adjacent neighbors path finder is allowed to consider)
-        self.neighborSet = [ (0, -1), (0, 1), (-1, 0), (1, 0) ]
-        
-    def ResizeMap (self, numRows, numCols):
-        self.map = {}
-        self.size = (numRows, numCols)
-
-        # initialize path_finder map to a 2D array of empty nodes
-        for row in range(0, self.size[0], 1):
-            for col in range(0, self.size[1], 1):
-                self.Set( row, col, node() )
-                self.SetType( row, col, 0 )
-        
-    def CleanUpTemp (self):
-        
-        # this resets variables needed for a search (but preserves the same map / maze)
-    
-        self.pathChainRev = ""
-        self.pathChain = ""
-        self.current = (-1, -1)
-        self.openList = []
-        self.closedList = []
-        
-    def FindPath (self, startPos, endPos ):
-        
-        self.CleanUpTemp()
-        
-        # (row, col) tuples
-        self.start = startPos
-        self.end = endPos
-        
-        # add start node to open list
-        self.AddToOpenList( self.start )
-        self.SetG ( self.start, 0 )
-        self.SetH ( self.start, 0 )
-        self.SetF ( self.start, 0 )
-        
-        doContinue = True
-        
-        while (doContinue == True):
-        
-            thisLowestFNode = self.GetLowestFNode()
-
-            if not thisLowestFNode == self.end and not thisLowestFNode == False:
-                self.current = thisLowestFNode
-                self.RemoveFromOpenList( self.current )
-                self.AddToClosedList( self.current )
-                
-                for offset in self.neighborSet:
-                    thisNeighbor = (self.current[0] + offset[0], self.current[1] + offset[1])
-                    
-                    if not thisNeighbor[0] < 0 and not thisNeighbor[1] < 0 and not thisNeighbor[0] > self.size[0] - 1 and not thisNeighbor[1] > self.size[1] - 1 and not self.GetType( thisNeighbor ) == 1:
-                        cost = self.GetG( self.current ) + 10
-                        
-                        if self.IsInOpenList( thisNeighbor ) and cost < self.GetG( thisNeighbor ):
-                            self.RemoveFromOpenList( thisNeighbor )
-                            
-                        #if self.IsInClosedList( thisNeighbor ) and cost < self.GetG( thisNeighbor ):
-                        #   self.RemoveFromClosedList( thisNeighbor )
-                            
-                        if not self.IsInOpenList( thisNeighbor ) and not self.IsInClosedList( thisNeighbor ):
-                            self.AddToOpenList( thisNeighbor )
-                            self.SetG( thisNeighbor, cost )
-                            self.CalcH( thisNeighbor )
-                            self.CalcF( thisNeighbor )
-                            self.SetParent( thisNeighbor, self.current )
-            else:
-                doContinue = False
-                        
-        if thisLowestFNode == False:
-            return False
-                        
-        # reconstruct path
-        self.current = self.end
-        while not self.current == self.start:
-            # build a string representation of the path using R, L, D, U
-            if self.current[1] > self.GetParent(self.current)[1]:
-                self.pathChainRev += 'R' 
-            elif self.current[1] < self.GetParent(self.current)[1]:
-                self.pathChainRev += 'L'
-            elif self.current[0] > self.GetParent(self.current)[0]:
-                self.pathChainRev += 'D'
-            elif self.current[0] < self.GetParent(self.current)[0]:
-                self.pathChainRev += 'U'
-            self.current = self.GetParent(self.current)
-            self.SetType( self.current[0],self.current[1], 4)
-            
-        # because pathChainRev was constructed in reverse order, it needs to be reversed!
-        for i in range(len(self.pathChainRev) - 1, -1, -1):
-            self.pathChain += self.pathChainRev[i]
-        
-        # set start and ending positions for future reference
-        self.SetType( self.start[0],self.start[1], 2)
-        self.SetType( self.end[0],self.start[1], 3)
-        
-        return self.pathChain
-
-    def Unfold (self, row,col):
-        # this function converts a 2D array coordinate pair (row, col)
-        # to a 1D-array index, for the object's 1D map array.
-        return (row * self.size[1]) + col
-    
-    def Set (self, row,col, newNode):
-        # sets the value of a particular map cell (usually refers to a node object)
-        self.map[ self.Unfold(row, col) ] = newNode
-        
-    def GetType (self,val):
-        row,col = val
-        return self.map[ self.Unfold(row, col) ].type
-        
-    def SetType (self,row,col, newValue):
-        self.map[ self.Unfold(row, col) ].type = newValue
-
-    def GetF (self, val):
-        row,col = val
-        return self.map[ self.Unfold(row, col) ].f
-
-    def GetG (self, val):
-        row,col = val
-        return self.map[ self.Unfold(row, col) ].g
-    
-    def GetH (self, val):
-        row,col = val
-        return self.map[ self.Unfold(row, col) ].h
-        
-    def SetG (self, val, newValue ):
-        row,col = val
-        self.map[ self.Unfold(row, col) ].g = newValue
-
-    def SetH (self, val, newValue ):
-        row,col = val
-        self.map[ self.Unfold(row, col) ].h = newValue
-        
-    def SetF (self, val, newValue ):
-        row,col = val
-        self.map[ self.Unfold(row, col) ].f = newValue
-        
-    def CalcH (self, val):
-        row,col = val
-        self.map[ self.Unfold(row, col) ].h = abs(row - self.end[0]) + abs(col - self.end[0])
-        
-    def CalcF (self, val):
-        row,col = val
-        unfoldIndex = self.Unfold(row, col)
-        self.map[unfoldIndex].f = self.map[unfoldIndex].g + self.map[unfoldIndex].h
-    
-    def AddToOpenList (self, val):
-        row,col = val
-        self.openList.append( (row, col) )
-        
-    def RemoveFromOpenList (self, val ):
-        row,col = val
-        self.openList.remove( (row, col) )
-        
-    def IsInOpenList (self, val ):
-        row,col = val
-        if self.openList.count( (row, col) ) > 0:
-            return True
-        else:
-            return False
-        
-    def GetLowestFNode (self):
-        lowestValue = 1000 # start arbitrarily high
-        lowestPair = (-1, -1)
-        
-        for iOrderedPair in self.openList:
-            if self.GetF( iOrderedPair ) < lowestValue:
-                lowestValue = self.GetF( iOrderedPair )
-                lowestPair = iOrderedPair
-        
-        if not lowestPair == (-1, -1):
-            return lowestPair
-        else:
-            return False
-        
-    def AddToClosedList (self, val ):
-        row,col = val
-        self.closedList.append( (row, col) )
-        
-    def IsInClosedList (self, val ):
-        row,col = val
-        if self.closedList.count( (row, col) ) > 0:
-            return True
-        else:
-            return False
-
-    def SetParent (self, val, val2 ):
-        row,col = val
-        parentRow,parentCol = val2
-        self.map[ self.Unfold(row, col) ].parent = (parentRow, parentCol)
-
-    def GetParent (self, val ):
-        row,col = val
-        return self.map[ self.Unfold(row, col) ].parent
-        
-    
-        
-class Color:
-    """
-    Class to store hex values for colors/
-    """
-    def __init__(self):
-        """
-        Constructor Function
-        """
-        self.black = (0, 0, 0)
-        self.grey = (100, 100, 100)
-        self.white = (255, 255, 255)
-        self.blue = (0, 0, 255)
-        self.green = (0, 255, 0)
-        self.red = (255, 0, 0)
-        self.purple = (255, 0, 255)
-        self.yellow = (255, 255, 0)
-
-class PowerUp(pygame.sprite.Sprite):
-    def __init__(self, x, y):
-        super().__init__()
-        self.image = pygame.Surface([20, 20])
-        self.image.fill(Color().purple)  # Color indicating special power-up
-        self.rect = self.image.get_rect()
-        self.rect.x = x
-        self.rect.y = y
-        self.type = 'eat_ghosts'  # Specific type for eating ghosts
-        self.duration = 7000  # Lasts for 7 seconds
-
-    def apply_effect(self, player):
-        if self.type == 'eat_ghosts':
-            player.enable_ghost_eating(self.duration)
-
-
-class Wall(pygame.sprite.Sprite):
-    def __init__(self, x, y, width, height, color):
-        """
-        Constructor function
-        :param x:
-        :type x:
-        :param y:
-        :type y:
-        :param width:
-        :type width:
-        :param height:
-        :type height:
-        :param color:
-        :type color:
-        """
-
-        # Call the parent's constructor
-        pygame.sprite.Sprite.__init__(self)
-
-        # Make a wall, of the size specified in the parameters
-        self.image = pygame.Surface([width, height])
-        self.image.fill(color)
-
-        # Make our top-left corner the passed-in location.
-        self.rect = self.image.get_rect()
-        self.rect.top = y
-        self.rect.left = x
-
-
-class Block(pygame.sprite.Sprite):
-    """
-    This class represents the ball
-    It derives from the "Sprite" class in Pygame
-    """
-
-    def __init__(self, color, width, height):
-        """
-        Constructor. Pass in the color of the block and its x and y position
-        :param color:
-        :type color:
-        :param width:
-        :type width:
-        :param height:
-        :type height:
-        """
-
-        # Call the parent class (Sprite) constructor
-        pygame.sprite.Sprite.__init__(self)
-
-        # Create an image of the block, and fill it with a color.
-        # This could also be an image loaded from the disk.
-        self.color = Color()
-        self.image = pygame.Surface([width, height])
-        self.image.fill(self.color.white)
-        self.image.set_colorkey(self.color.white)
-        pygame.draw.ellipse(self.image, color, [0, 0, width, height])
-
-        # Fetch the rectangle object that has the dimensions of the image.
-        # Update the position of this object by setting the values
-        # of rect.x and rect.y
-        self.rect = self.image.get_rect()
-
-
-class Player(pygame.sprite.Sprite):
-    """
-    This class represents the bar at the bottom that the player controls
-    """
-
-    change_x = 0
-    change_y = 0
-
-    def __init__(self, x, y, filename):
-        """
-        Constructor function
-        :param x:
-        :type x:
-        :param y:
-        :type y:
-        :param filename:
-        :type filename:
-        """
-
-        # Call the parent's constructor
-        pygame.sprite.Sprite.__init__(self)
-
-        # Set height, width
-        self.image = pygame.image.load(filename).convert()
-
-        # Make our top-left corner the passed-in location.
-        self.rect = self.image.get_rect()
-        self.rect.top = y
-        self.rect.left = x
-        self.prev_x = x
-        self.prev_y = y
-        self.goal = None
-
-    def prev_direction(self):
-        """
-        Clear the speed of the player
-        """
-        self.prev_x = self.change_x
-        self.prev_y = self.change_y
-
-    def change_speed(self, x, y):
-        """
-        Change the speed of the player
-        :param x:
-        :type x:
-        :param y:
-        :type y:
-        """
-        self.change_x += x
-        self.change_y += y
-
-    def update(self, walls, gate):
-        """
-        Find a new position for the player
-        :param walls: 
-        :type walls: 
-        :param gate: 
-        :type gate: 
-        """
-        for event in pygame.event.get():
-            if event.type == pygame.USEREVENT + 3:  # Timer for ghost eating power-up
-                self.ghost_eating = False
-        # Get the old position, in case we need to go back to it
-        old_x = self.rect.left
-        new_x = old_x + self.change_x
-        self.rect.left = new_x
-
-        old_y = self.rect.top
-        new_y = old_y + self.change_y
-
-        x_collide = pygame.sprite.spritecollide(self, walls, False)
-        if x_collide:
-            self.rect.left = old_x
-        else:
-            self.rect.top = new_y
-            y_collide = pygame.sprite.spritecollide(self, walls, False)
-            if y_collide:
-                self.rect.top = old_y
-
-        if gate:
-            gate_hit = pygame.sprite.spritecollide(self, gate, False)
-            if gate_hit:
-                self.rect.left = old_x
-                self.rect.top = old_y 
-    
-    def enable_ghost_eating(self, duration):
-        self.ghost_eating = True
-        pygame.time.set_timer(pygame.USEREVENT + 3, duration)
-
-
-
-class Ghost(Player):
-    def __init__(self, x, y, filename):
-        """
-        Constructor Function
-        """
-        super().__init__(x, y, filename)
-        self.ghost_eating = False 
-        self.goal = None
-    """
-    Class to handle ghosts
-    """
-    def flee_or_chase(self, player):
-        """
-        Determine if the ghost should flee from or chase the player
-        :param player: the player character, Pacman
-        """
-        if player.ghost_eating:
-            self.run_away_from_pacman(player)
-        else:
-            self.chase_pacman(player)
-
-    def run_away_from_pacman(self, player):
-        """
-        Set direction away from Pacman
-        :param player: the player character, Pacman
-        """
-        pacman_x, pacman_y = player.rect.center
-        ghost_x, ghost_y = self.rect.center
-        dx, dy = pacman_x - ghost_x, pacman_y - ghost_y
-        # Ghost moves in the opposite direction of Pacman
-        self.change_x = -5 if dx > 0 else 5
-        self.change_y = -5 if dy > 0 else 5
-
-    def chase_pacman(self, player):
-        """
-        Set direction towards Pacman
-        :param player: the player character, Pacman
-        """
-        pacman_x, pacman_y = player.rect.center
-        ghost_x, ghost_y = self.rect.center
-        dx, dy = pacman_x - ghost_x, pacman_y - ghost_y
-        # Ghost reduces the distance to Pacman
-        self.change_x = 5 if dx > 0 else -5
-        self.change_y = 5 if dy > 0 else -5
-
-    def ghost_change_speed(self, direction_list, ghost, turn, steps, l):
-        """
-        Change the speed of the ghost
-        :param direction_list: 
-        :type direction_list: 
-        :param ghost: 
-        :type ghost: 
-        :param turn: 
-        :type turn: 
-        :param steps: 
-        :type steps: 
-        :param l: 
-        :type l: 
-        :return: 
-        :rtype: 
-        """
-        try:
-            z = direction_list[turn][2]
-            if steps < z:
-                self.change_x = direction_list[turn][0]
-                self.change_y = direction_list[turn][1]
-                steps += 1
-            else:
-                if turn < l:
-                    turn += 1
-                elif ghost == 'ghost_four':
-                    turn = 2
-                else:
-                    turn = 0
-                self.change_x = direction_list[turn][0]
-                self.change_y = direction_list[turn][1]
-                steps = 0
-            return [turn, steps]
-        except IndexError:
-            return [0, 0]
-
-
-class Game:
-    """
-    Class to run the game.
-    """
-
-    def __init__(self):
-        """
-        Constructor Function
-        """
-
-        # This is a list of walls. Each is in the form [x, y, width, height]
-        self.walls = [
-            [0, 0, 6, 600],
-            [0, 0, 600, 6],
-            [0, 600, 606, 6],
-            [600, 0, 6, 606],
-            [300, 0, 6, 66],
-            [60, 60, 186, 6],
-            [360, 60, 186, 6],
-            [60, 120, 66, 6],
-            [60, 120, 6, 126],
-            [180, 120, 246, 6],
-            [300, 120, 6, 66],
-            [480, 120, 66, 6],
-            [540, 120, 6, 126],
-            [120, 180, 126, 6],
-            [120, 180, 6, 126],
-            [360, 180, 126, 6],
-            [480, 180, 6, 126],
-            [180, 240, 6, 126],
-            [180, 360, 246, 6],
-            [420, 240, 6, 126],
-            [240, 240, 42, 6],
-            [324, 240, 42, 6],
-            [240, 240, 6, 66],
-            [240, 300, 126, 6],
-            [360, 240, 6, 66],
-            [0, 300, 66, 6],
-            [540, 300, 66, 6],
-            [60, 360, 66, 6],
-            [60, 360, 6, 186],
-            [480, 360, 66, 6],
-            [540, 360, 6, 186],
-            [120, 420, 366, 6],
-            [120, 420, 6, 66],
-            [480, 420, 6, 66],
-            [180, 480, 246, 6],
-            [300, 480, 6, 66],
-            [120, 540, 126, 6],
-            [360, 540, 126, 6],
-        ]
-
-        self.ghost_one_directions = [
-            [0, -30, 4],
-            [15, 0, 9],
-            [0, 15, 11],
-            [-15, 0, 23],
-            [0, 15, 7],
-            [15, 0, 3],
-            [0, -15, 3],
-            [15, 0, 19],
-            [0, 15, 3],
-            [15, 0, 3],
-            [0, 15, 3],
-            [15, 0, 3],
-            [0, -15, 15],
-            [-15, 0, 7],
-            [0, 15, 3],
-            [-15, 0, 19],
-            [0, -15, 11],
-            [15, 0, 9],
-        ]
-
-        self.ghost_two_directions = [
-            [0, -15, 4],
-            [15, 0, 9],
-            [0, 15, 11],
-            [15, 0, 3],
-            [0, 15, 7],
-            [-15, 0, 11],
-            [0, 15, 3],
-            [15, 0, 15],
-            [0, -15, 15],
-            [15, 0, 3],
-            [0, -15, 11],
-            [-15, 0, 3],
-            [0, -15, 11],
-            [-15, 0, 3],
-            [0, -15, 3],
-            [-15, 0, 7],
-            [0, -15, 3],
-            [15, 0, 15],
-            [0, 15, 15],
-            [-15, 0, 3],
-            [0, 15, 3],
-            [-15, 0, 3],
-            [0, -15, 7],
-            [-15, 0, 3],
-            [0, 15, 7],
-            [-15, 0, 11],
-            [0, -15, 7],
-            [15, 0, 5],
-        ]
-
-        self.ghost_three_directions = [
-            [30, 0, 2],
-            [0, -15, 4],
-            [15, 0, 10],
-            [0, 15, 7],
-            [15, 0, 3],
-            [0, -15, 3],
-            [15, 0, 3],
-            [0, -15, 15],
-            [-15, 0, 15],
-            [0, 15, 3],
-            [15, 0, 15],
-            [0, 15, 11],
-            [-15, 0, 3],
-            [0, -15, 7],
-            [-15, 0, 11],
-            [0, 15, 3],
-            [-15, 0, 11],
-            [0, 15, 7],
-            [-15, 0, 3],
-            [0, -15, 3],
-            [-15, 0, 3],
-            [0, -15, 15],
-            [15, 0, 15],
-            [0, 15, 3],
-            [-15, 0, 15],
-            [0, 15, 11],
-            [15, 0, 3],
-            [0, -15, 11],
-            [15, 0, 11],
-            [0, 15, 3],
-            [15, 0, 1],
-        ]
-
-        self.ghost_four_directions = [
-            [-30, 0, 2],
-            [0, -15, 4],
-            [15, 0, 5],
-            [0, 15, 7],
-            [-15, 0, 11],
-            [0, -15, 7],
-            [-15, 0, 3],
-            [0, 15, 7],
-            [-15, 0, 7],
-            [0, 15, 15],
-            [15, 0, 15],
-            [0, -15, 3],
-            [-15, 0, 11],
-            [0, -15, 7],
-            [15, 0, 3],
-            [0, -15, 11],
-            [15, 0, 9],
-        ]
-
-        self.color = Color()
-        # Call this function so the Pygame library can initialize itself
-        pygame.init()
-
-        # Create an 606x606 sized screen
-        self.screen = pygame.display.set_mode([606, 606])
-
-        # Set the title of the window
-        pygame.display.set_caption('Pacman')
-
-        # Create a surface we can draw on
-        background = pygame.Surface(self.screen.get_size())
-        background = background.convert()
-        background.fill(self.color.black)
-        self.clock = pygame.time.Clock()
-        pygame.font.init()
-        self.font = pygame.font.SysFont('arial', 30)
-        self.all_sprites_list = None
-        self.power_pellets = pygame.sprite.RenderPlain()
-    def setup_walls(self):
-        """
-        Make the walls. (x_pos, y_pos, width, height)
-        :return:
-        :rtype:
-        """
-        wall_list = pygame.sprite.RenderPlain()
-
-        # Loop through the list. Create the wall, add it to the list
-        for item in self.walls:
-            wall = Wall(item[0], item[1], item[2], item[3], self.color.grey)
-            wall_list.add(wall)
-            self.all_sprites_list.add(wall)
-
-        # return our new list
-        return wall_list
-
-    def setup_gate(self):
-        """
-        Add gates in the walls
-        :return:
-        :rtype:
-        """
-        gate = pygame.sprite.RenderPlain()
-        gate.add(Wall(282, 242, 42, 2, self.color.white))
-        self.all_sprites_list.add(gate)
-        return gate
-    def setup_power_pellets(self):
-        # Define power pellet locations and add them to the game
-        locations = [(100, 200), (500, 300), (300, 100)]  # Example locations
-        for x, y in locations:
-            pellet = PowerUp(x, y)
-            self.power_pellets.add(pellet)
-            self.all_sprites_list.add(pellet) 
-    def start_game(self):
-        """
-        start the game
-        """
-
-        pl = len(self.ghost_one_directions) - 1
-        bl = len(self.ghost_two_directions) - 1
-        il = len(self.ghost_three_directions) - 1
-        cl = len(self.ghost_four_directions) - 1
-
-        # default locations for Pacman and ghosts
-        w = 303 - 16  # Width
-        p_h = 7 * 60 + 19
-        m_h = 4 * 60 + 19
-        b_h = 3 * 60 + 19
-        i_w = 303 - 16 - 32
-        c_w = 303 + 32 - 16
-
-        self.all_sprites_list = pygame.sprite.RenderPlain()
-        block_list = pygame.sprite.RenderPlain()
-        ghost_list = pygame.sprite.RenderPlain()
-        pacman_collide = pygame.sprite.RenderPlain()
-        wall_list = self.setup_walls()
-
-        gate = self.setup_gate()
-
-        p_turn = 0
-        p_steps = 0
-
-        b_turn = 0
-        b_steps = 0
-
-        i_turn = 0
-        i_steps = 0
-
-        c_turn = 0
-        c_steps = 0
-
-        # Create the player  object
-        pacman = Player(w, p_h, 'images/pacman.png')
-        self.all_sprites_list.add(pacman)
-        pacman_collide.add(pacman)
-
-        ghost_two = Ghost(w, b_h, 'images/red.png')
-        ghost_list.add(ghost_two)
-        self.all_sprites_list.add(ghost_two)
-
-        ghost_one = Ghost(w, m_h, 'images/pink.png')
-        ghost_list.add(ghost_one)
-        self.all_sprites_list.add(ghost_one)
-
-        ghost_three = Ghost(i_w, m_h, 'images/blue.png')
-        ghost_list.add(ghost_three)
-        self.all_sprites_list.add(ghost_three)
-
-        ghost_four = Ghost(c_w, m_h, 'images/yellow.png')
-        ghost_list.add(ghost_four)
-        self.all_sprites_list.add(ghost_four)
-
-        # Draw the grid
-        for row in range(19):
-            for column in range(19):
-                if (row == 7 or row == 8) and (column == 8 or column == 9 or column == 10):
-                    continue
-                else:
-                    block = Block(self.color.yellow, 4, 4)
-
-                    # Set a random location for the block
-                    block.rect.x = 30 * column + 6 + 26
-                    block.rect.y = 30 * row + 6 + 26
-
-                    b_collide = pygame.sprite.spritecollide(block, wall_list, False)
-                    p_collide = pygame.sprite.spritecollide(block, pacman_collide, False)
-                    if b_collide:
-                        continue
-                    elif p_collide:
-                        continue
-                    else:
-                        # Add the block to the list of objects
-                        block_list.add(block)
-                        self.all_sprites_list.add(block)
-        # Randomly select four blocks
-        blocks = list(block_list)
-        selected_blocks = random.sample(blocks, 4)
-
-# Replace the selected blocks with power pellets
-        for block in selected_blocks:
-            power_pellet = PowerUp(block.rect.x, block.rect.y)  # Assuming you have a PowerPellet class
-            
-    # Add the power pellet to the game (you might need to modify this part based on your game structure)
-            self.all_sprites_list.add(power_pellet)
-        bll = len(block_list)
-        score = 0
-        done = False
-        while not done:
-            # Events
-            for event in pygame.event.get():
-                if event.type == pygame.QUIT:
-                    done = True
-
-                if event.type == pygame.KEYDOWN:
-                    if event.key == pygame.K_LEFT:
-                        pacman.change_speed(-30, 0)
-                    if event.key == pygame.K_RIGHT:
-                        pacman.change_speed(30, 0)
-                    if event.key == pygame.K_UP:
-                        pacman.change_speed(0, -30)
-                    if event.key == pygame.K_DOWN:
-                        pacman.change_speed(0, 30)
-
-                if event.type == pygame.KEYUP:
-                    if event.key == pygame.K_LEFT:
-                        pacman.change_speed(30, 0)
-                    if event.key == pygame.K_RIGHT:
-                        pacman.change_speed(-30, 0)
-                    if event.key == pygame.K_UP:
-                        pacman.change_speed(0, 30)
-                    if event.key == pygame.K_DOWN:
-                        pacman.change_speed(0, -30)
-
-            pacman.update(wall_list, gate)
-            returned = ghost_one.ghost_change_speed(self.ghost_one_directions, False, p_turn, p_steps, pl)
-            p_turn = returned[0]
-            p_steps = returned[1]
-            ghost_one.ghost_change_speed(self.ghost_one_directions, False, p_turn, p_steps, pl)
-            ghost_one.update(wall_list, False)
-
-            returned = ghost_two.ghost_change_speed(self.ghost_two_directions, False, b_turn, b_steps, bl)
-            b_turn = returned[0]
-            b_steps = returned[1]
-            ghost_two.ghost_change_speed(self.ghost_two_directions, False, b_turn, b_steps, bl)
-            ghost_two.update(wall_list, False)
-
-            returned = ghost_three.ghost_change_speed(self.ghost_three_directions, False, i_turn, i_steps, il)
-            i_turn = returned[0]
-            i_steps = returned[1]
-            ghost_three.ghost_change_speed(self.ghost_three_directions, False, i_turn, i_steps, il)
-            ghost_three.update(wall_list, False)
-
-            returned = ghost_four.ghost_change_speed(self.ghost_four_directions, 'ghost_four', c_turn, c_steps, cl)
-            c_turn = returned[0]
-            c_steps = returned[1]
-            ghost_four.ghost_change_speed(self.ghost_four_directions, 'ghost_four', c_turn, c_steps, cl)
-            ghost_four.update(wall_list, False)
-
-            # See if the pacman block has collided with anything.
-            blocks_hit_list = pygame.sprite.spritecollide(pacman, block_list, True) 
-            # check if pacman hits any power pellet
-            pellet_hit_list = pygame.sprite.spritecollide(pacman, self.power_pellets,True)
-            # if pellet is hit 
-            # Check the list of collisions.
-            if len(blocks_hit_list) > 0:
-                score += len(blocks_hit_list)
-
-            self.screen.fill(self.color.black)
-
-            wall_list.draw(self.screen)
-            gate.draw(self.screen)
-            self.all_sprites_list.draw(self.screen)
-            ghost_list.draw(self.screen)
-
-            text = self.font.render(str(score) + '/' + str(bll), True, self.color.white)
-            self.screen.blit(text, [270, 254])
-
-            if score == bll:
-                self.do_next(
-                    'Congratulations, you won!',
-                    145,
-                    block_list,
-                    ghost_list,
-                    pacman_collide,
-                    wall_list,
-                    gate,
-                )
-                return
-
-            ghost_hit_list = pygame.sprite.spritecollide(pacman, ghost_list, False)
-
-            if ghost_hit_list:
-                self.do_next(
-                    'Game Over',
-                    235,
-                    block_list,
-                    ghost_list,
-                    pacman_collide,
-                    wall_list,
-                    gate,
-                )
-                return
-
-            pygame.display.flip()
-
-            self.clock.tick(10)
-
-    def do_next(self, message, left, block_list, ghost_list, pacman_collide, wall_list, gate):
-        """
-        Go to next configuration in the game
-        :param message:
-        :type message:
-        :param left:
-        :type left:
-        :param block_list:
-        :type block_list:
-        :param ghost_list:
-        :type ghost_list:
-        :param pacman_collide:
-        :type pacman_collide:
-        :param wall_list:
-        :type wall_list:
-        :param gate:
-        :type gate:
-        """
-        while True:
-            for event in pygame.event.get():
-                if event.type == pygame.QUIT:
-                    pygame.quit()
-                    return
-                if event.type == pygame.KEYDOWN:
-                    if event.key == pygame.K_ESCAPE:
-                        pygame.quit()
-                        return
-                    if event.key == pygame.K_RETURN:
-                        del self.all_sprites_list
-                        del block_list
-                        del ghost_list
-                        del pacman_collide
-                        del wall_list
-                        del gate
-                        self.start_game()
-                        return
-
-            # Grey background
-            w_surface = pygame.Surface((400, 200))  # the size of your rect
-            w_surface.fill((255, 255, 255))  # this fills the entire surface
-            self.screen.blit(w_surface, (100, 200))  # (0,0) are the top-left coordinates
-
-            # Won or lost
-            text1 = self.font.render(message, True, self.color.black)
-            self.screen.blit(text1, [left, 233])
-
-            text2 = self.font.render('To play again, press ENTER.', True, self.color.black)
-            self.screen.blit(text2, [135, 300])
-            text3 = self.font.render('To quit, press ESCAPE.', True, self.color.black)
-            self.screen.blit(text3, [165, 340])
-
-            pygame.display.flip()
-            self.clock.tick(10)
-
-
-if __name__ == '__main__':
-    # main function
-    game = Game()
-    game.start_game()
-    pygame.quit()
\ No newline at end of file
diff --git a/games/pacman/pacman_test.py b/games/pacman/pacman_test.py
deleted file mode 100644
index dab7b16..0000000
--- a/games/pacman/pacman_test.py
+++ /dev/null
@@ -1,366 +0,0 @@
-#! /usr/bin/python
-
-# pacman.pyw
-# By David Reilly
-
-# Modified by Andy Sommerville, 8 October 2007:
-# - Changed hard-coded DOS paths to os.path calls
-# - Added constant SCRIPT_PATH (so you don't need to have pacman.pyw and res in your cwd, as long
-# -   as those two are in the same directory)
-# - Changed text-file reading to accomodate any known EOLn method (\n, \r, or \r\n)
-# - I (happily) don't have a Windows box to test this. Blocks marked "WIN???"
-# -   should be examined if this doesn't run in Windows
-# - Added joystick support (configure by changing JS_* constants)
-# - Added a high-score list. Depends on wx for querying the user's name
-
-import pygame, sys, os, random
-from pygame.locals import *
-from player import pacman
-from ghost import ghost
-from path import path_finder
-from level import level
-from game import game
-from fruit import fruit
-from config import *
-
-
-window = pygame.display.set_mode((1, 1))
-pygame.display.set_caption("Pacman")
-
-screen = pygame.display.get_surface()
-
-img_Background = pygame.image.load(os.path.join(SCRIPT_PATH,"res","backgrounds","1.gif")).convert()
-
-snd_pellet = {}
-snd_pellet[0] = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","pellet1.wav"))
-snd_pellet[1] = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","pellet2.wav"))
-snd_powerpellet = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","powerpellet.wav"))
-snd_eatgh = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","eatgh2.wav"))
-snd_fruitbounce = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","fruitbounce.wav"))
-snd_eatfruit = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","eatfruit.wav"))
-snd_extralife = pygame.mixer.Sound(os.path.join(SCRIPT_PATH,"res","sounds","extralife.wav"))
-
-
-
-#      ___________________
-# ___/  class definitions  \_______________________________________________
-
-def CheckIfCloseButton(events):
-    for event in events: 
-        if event.type == pygame.QUIT: 
-            sys.exit(0)
-
-
-def CheckInputs(): 
-    
-    if thisGame.mode == 1:
-        if pygame.key.get_pressed()[ pygame.K_RIGHT ] or (js!=None and js.get_axis(JS_XAXIS)>0):
-            if not thisLevel.CheckIfHitWall(player.x + player.speed, player.y, player.nearestRow, player.nearestCol): 
-                player.velX = player.speed
-                player.velY = 0
-                
-        elif pygame.key.get_pressed()[ pygame.K_LEFT ] or (js!=None and js.get_axis(JS_XAXIS)<0):
-            if not thisLevel.CheckIfHitWall(player.x - player.speed, player.y, player.nearestRow, player.nearestCol): 
-                player.velX = -player.speed
-                player.velY = 0
-            
-        elif pygame.key.get_pressed()[ pygame.K_DOWN ] or (js!=None and js.get_axis(JS_YAXIS)>0):
-            if not thisLevel.CheckIfHitWall(player.x, player.y + player.speed, player.nearestRow, player.nearestCol): 
-                player.velX = 0
-                player.velY = player.speed
-            
-        elif pygame.key.get_pressed()[ pygame.K_UP ] or (js!=None and js.get_axis(JS_YAXIS)<0):
-            if not thisLevel.CheckIfHitWall(player.x, player.y - player.speed, player.nearestRow, player.nearestCol):
-                player.velX = 0
-                player.velY = -player.speed
-                
-    if pygame.key.get_pressed()[ pygame.K_ESCAPE ]:
-        sys.exit(0)
-            
-    elif thisGame.mode == 4 :
-        if pygame.key.get_pressed()[ pygame.K_RETURN ] or (js!=None and js.get_button(JS_STARTBUTTON)):
-            thisGame.StartNewGame(thisLevel, tileID, tileIDImage, tileIDName)
-            
-    
-def GetCrossRef ():
-
-    f = open(os.path.join(SCRIPT_PATH,"res","crossref.txt"), 'r')
-    # ANDY -- edit
-    #fileOutput = f.read()
-    #str_splitByLine = fileOutput.split('\n')
-
-    lineNum = 0
-    useLine = False
-
-    for i in f.readlines():
-        # print " ========= Line " + str(lineNum) + " ============ "
-        while len(i)>0 and (i[-1]=='\n' or i[-1]=='\r'): i=i[:-1]
-        while len(i)>0 and (i[0]=='\n' or i[0]=='\r'): i=i[1:]
-        str_splitBySpace = i.split(' ')
-        
-        j = str_splitBySpace[0]
-            
-        if (j == "'" or j == "" or j == "#"):
-            # comment / whitespace line
-            # print " ignoring comment line.. "
-            useLine = False
-        else:
-            # print str(wordNum) + ". " + j
-            useLine = True
-        
-        if useLine == True:
-            tileIDName[ int(str_splitBySpace[0]) ] = str_splitBySpace[1]
-            tileID[ str_splitBySpace[1] ] = int(str_splitBySpace[0])
-            
-            thisID = int(str_splitBySpace[0])
-            if not thisID in NO_GIF_TILES:
-                tileIDImage[ thisID ] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","tiles",str_splitBySpace[1] + ".gif")).convert()
-            else:
-                    tileIDImage[ thisID ] = pygame.Surface((16,16))
-            
-            # change colors in tileIDImage to match maze colors
-            for y in range(0, 16, 1):
-                for x in range(0, 16, 1):
-                
-                    if tileIDImage[ thisID ].get_at( (x, y) ) == (255, 206, 255, 255):
-                        # wall edge
-                        tileIDImage[ thisID ].set_at( (x, y), thisLevel.edgeLightColor )
-                        
-                    elif tileIDImage[ thisID ].get_at( (x, y) ) == (132, 0, 132, 255):
-                        # wall fill
-                        tileIDImage[ thisID ].set_at( (x, y), thisLevel.fillColor ) 
-                        
-                    elif tileIDImage[ thisID ].get_at( (x, y) ) == (255, 0, 255, 255):
-                        # pellet color
-                        tileIDImage[ thisID ].set_at( (x, y), thisLevel.edgeShadowColor )   
-                        
-                    elif tileIDImage[ thisID ].get_at( (x, y) ) == (128, 0, 128, 255):
-                        # pellet color
-                        tileIDImage[ thisID ].set_at( (x, y), thisLevel.pelletColor )   
-                
-            # print str_splitBySpace[0] + " is married to " + str_splitBySpace[1]
-        lineNum += 1
-
-    
-#      _____________________________
-#      __________________
-# ___/  main code block  \_____________________________________________________
-# create a path_finder object
-
-f = open(os.path.join(SCRIPT_PATH,"res","crossref.txt"), 'r')
-# ANDY -- edit
-#fileOutput = f.read()
-#str_splitByLine = fileOutput.split('\n')
-
-lineNum = 0
-useLine = False
-
-tileIDName = {} # gives tile name (when the ID# is known)
-tileID = {} # gives tile ID (when the name is known)
-tileIDImage = {} # gives tile image (when the ID# is known)
-
-
-path = path_finder()
-
-# create pacman object
-player = pacman(path, screen)
-
-# create ghost objects
-ghosts = {}
-for i in range(0, 6, 1):
-    # remember, ghost[4] is the blue, vulnerable ghost
-    ghosts[i] = ghost(i, path, screen, player)
-    
-# create piece of fruit
-thisFruit = fruit() 
-
-
-
-
-
-# create game and level objects and load first level
-thisGame = game(thisFruit, player, screen)
-thisLevel = level( thisGame, player, ghosts, path, thisFruit, screen)
-for i in f.readlines():
-    # print " ========= Line " + str(lineNum) + " ============ "
-    while len(i)>0 and (i[-1]=='\n' or i[-1]=='\r'): i=i[:-1]
-    while len(i)>0 and (i[0]=='\n' or i[0]=='\r'): i=i[1:]
-    str_splitBySpace = i.split(' ')
-    
-    j = str_splitBySpace[0]
-        
-    if (j == "'" or j == "" or j == "#"):
-        # comment / whitespace line
-        # print " ignoring comment line.. "
-        useLine = False
-    else:
-        # print str(wordNum) + ". " + j
-        useLine = True
-    
-    if useLine == True:
-        tileIDName[ int(str_splitBySpace[0]) ] = str_splitBySpace[1]
-        tileID[ str_splitBySpace[1] ] = int(str_splitBySpace[0])
-        
-        thisID = int(str_splitBySpace[0])
-        if not thisID in NO_GIF_TILES:
-            tileIDImage[ thisID ] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","tiles",str_splitBySpace[1] + ".gif")).convert()
-        else:
-                tileIDImage[ thisID ] = pygame.Surface((16,16))
-        
-        # change colors in tileIDImage to match maze colors
-        for y in range(0, 16, 1):
-            for x in range(0, 16, 1):
-            
-                if tileIDImage[ thisID ].get_at( (x, y) ) == (255, 206, 255, 255):
-                    # wall edge
-                    tileIDImage[ thisID ].set_at( (x, y), thisLevel.edgeLightColor )
-                    
-                elif tileIDImage[ thisID ].get_at( (x, y) ) == (132, 0, 132, 255):
-                    # wall fill
-                    tileIDImage[ thisID ].set_at( (x, y), thisLevel.fillColor ) 
-                    
-                elif tileIDImage[ thisID ].get_at( (x, y) ) == (255, 0, 255, 255):
-                    # pellet color
-                    tileIDImage[ thisID ].set_at( (x, y), thisLevel.edgeShadowColor )   
-                    
-                elif tileIDImage[ thisID ].get_at( (x, y) ) == (128, 0, 128, 255):
-                    # pellet color
-                    tileIDImage[ thisID ].set_at( (x, y), thisLevel.pelletColor )   
-            
-        # print str_splitBySpace[0] + " is married to " + str_splitBySpace[1]
-    lineNum += 1
-thisLevel.LoadLevel( thisGame.GetLevelNum(), tileID, tileIDImage, tileIDName )
-thisGame.StartNewGame( thisLevel, tileID, tileIDImage, tileIDName )
-
-window = pygame.display.set_mode( thisGame.screenSize, pygame.DOUBLEBUF | pygame.HWSURFACE )
-
-# initialise the joystick
-if pygame.joystick.get_count()>0:
-  if JS_DEVNUM<pygame.joystick.get_count(): js=pygame.joystick.Joystick(JS_DEVNUM)
-  else: js=pygame.joystick.Joystick(0)
-  js.init()
-else: js=None   
-print(tileID)
-
-while True: 
-
-    CheckIfCloseButton( pygame.event.get() )
-    
-    if thisGame.mode == 1:
-        # normal gameplay mode
-        CheckInputs()
-        
-        thisGame.modeTimer += 1
-        player.Move(thisGame, thisLevel, ghosts, thisFruit, tileID)
-        for i in range(0, 4, 1):
-            ghosts[i].Move(thisLevel, tileID)
-        thisFruit.Move(thisGame)
-            
-    elif thisGame.mode == 2:
-        # waiting after getting hit by a ghost
-        thisGame.modeTimer += 1
-        
-        if thisGame.modeTimer == 90:
-            # close the game
-            #pygame.quit()
-            thisLevel.Restart(tileID)
-            
-            thisGame.lives -= 1
-            if thisGame.lives == -1:
-                thisGame.updatehiscores(thisGame.score)
-                thisGame.SetMode( 3 )
-                thisGame.drawmidgamehiscores()
-            else:
-                thisGame.SetMode( 4 )
-                
-    elif thisGame.mode == 3:
-        # game over
-        print("Game Over")
-        running = False
-        #pygame.quit()
-        CheckInputs()
-            
-    elif thisGame.mode == 4:
-        # waiting to start
-        print("Waiting to start")
-        thisGame.modeTimer += 1
-        
-        if thisGame.modeTimer == 90:
-            thisGame.SetMode( 1 )
-            player.velX = player.speed
-            
-    elif thisGame.mode == 5:
-        # brief pause after munching a vulnerable ghost
-        thisGame.modeTimer += 1
-        
-        if thisGame.modeTimer == 30:
-            thisGame.SetMode( 1 )
-            
-    elif thisGame.mode == 6:
-        # pause after eating all the pellets
-        thisGame.modeTimer += 1
-        
-        if thisGame.modeTimer == 60:
-            thisGame.SetMode( 7 )
-            oldEdgeLightColor = thisLevel.edgeLightColor
-            oldEdgeShadowColor = thisLevel.edgeShadowColor
-            oldFillColor = thisLevel.fillColor
-            
-    elif thisGame.mode == 7:
-        # flashing maze after finishing level
-        thisGame.modeTimer += 1
-        
-        whiteSet = [10, 30, 50, 70]
-        normalSet = [20, 40, 60, 80]
-        
-        if not whiteSet.count(thisGame.modeTimer) == 0:
-            # member of white set
-            thisLevel.edgeLightColor = (255, 255, 255, 255)
-            thisLevel.edgeShadowColor = (255, 255, 255, 255)
-            thisLevel.fillColor = (0, 0, 0, 255)
-            GetCrossRef()
-        elif not normalSet.count(thisGame.modeTimer) == 0:
-            # member of normal set
-            thisLevel.edgeLightColor = oldEdgeLightColor
-            thisLevel.edgeShadowColor = oldEdgeShadowColor
-            thisLevel.fillColor = oldFillColor
-            GetCrossRef()
-        elif thisGame.modeTimer == 150:
-            thisGame.SetMode ( 8 )
-            
-    elif thisGame.mode == 8:
-        # blank screen before changing levels
-        thisGame.modeTimer += 1
-        if thisGame.modeTimer == 10:
-            thisGame.SetNextLevel()
-
-    thisGame.SmartMoveScreen(thisLevel)
-    
-    screen.blit(img_Background, (0, 0))
-    
-    if not thisGame.mode == 8:
-        thisLevel.DrawMap(tileID, tileIDImage)
-        
-        if thisGame.fruitScoreTimer > 0:
-            if thisGame.modeTimer % 2 == 0:
-                thisGame.DrawNumber (2500, thisFruit.x - thisGame.screenPixelPos[0] - 16, thisFruit.y - thisGame.screenPixelPos[1] + 4)
-
-        for i in range(0, 4, 1):
-            ghosts[i].Draw(thisGame, tileID, tileIDImage, ghosts)
-        thisFruit.Draw(thisGame)
-        player.Draw(thisGame)
-        
-        if thisGame.mode == 3:
-                screen.blit(thisGame.imHiscores,(32,256))
-        
-    if thisGame.mode == 5:
-        thisGame.DrawNumber (thisGame.ghostValue / 2, player.x - thisGame.screenPixelPos[0] - 4, player.y - thisGame.screenPixelPos[1] + 6)
-    
-    
-    
-    thisGame.DrawScore()
-    
-    pygame.display.flip()
-    
-    clock.tick (60)
-
diff --git a/games/pacman/path.py b/games/pacman/path.py
deleted file mode 100644
index bd3d8a6..0000000
--- a/games/pacman/path.py
+++ /dev/null
@@ -1,238 +0,0 @@
-from games.pacman.config import *
-
-class node ():
-    
-    def __init__ (self):
-        self.g = -1 # movement cost to move from previous node to this one (usually +10)
-        self.h = -1 # estimated movement cost to move from this node to the ending node (remaining horizontal and vertical steps * 10)
-        self.f = -1 # total movement cost of this node (= g + h)
-        # parent node - used to trace path back to the starting node at the end
-        self.parent = (-1, -1)
-        # node type - 0 for empty space, 1 for wall (optionally, 2 for starting node and 3 for end)
-        self.type = -1
-        
-class path_finder ():
-    
-    def __init__ (self,):
-        # map is a 1-DIMENSIONAL array.
-        # use the Unfold( (row, col) ) function to convert a 2D coordinate pair
-        # into a 1D index to use with this array.
-        self.map = {}
-        self.size = (-1, -1) # rows by columns
-        
-        self.pathChainRev = ""
-        self.pathChain = ""
-                
-        # starting and ending nodes
-        self.start = (-1, -1)
-        self.end = (-1, -1)
-        
-        # current node (used by algorithm)
-        self.current = (-1, -1)
-        
-        # open and closed lists of nodes to consider (used by algorithm)
-        self.openList = []
-        self.closedList = []
-        
-        # used in algorithm (adjacent neighbors path finder is allowed to consider)
-        self.neighborSet = [ (0, -1), (0, 1), (-1, 0), (1, 0) ]
-        
-    def ResizeMap (self, numRows, numCols):
-        self.map = {}
-        self.size = (numRows, numCols)
-
-        # initialize path_finder map to a 2D array of empty nodes
-        for row in range(0, self.size[0], 1):
-            for col in range(0, self.size[1], 1):
-                self.Set( row, col, node() )
-                self.SetType( row, col, 0 )
-        
-    def CleanUpTemp (self):
-        
-        # this resets variables needed for a search (but preserves the same map / maze)
-    
-        self.pathChainRev = ""
-        self.pathChain = ""
-        self.current = (-1, -1)
-        self.openList = []
-        self.closedList = []
-        
-    def FindPath (self, startPos, endPos ):
-        
-        self.CleanUpTemp()
-        
-        # (row, col) tuples
-        self.start = startPos
-        self.end = endPos
-        
-        # add start node to open list
-        self.AddToOpenList( self.start )
-        self.SetG ( self.start, 0 )
-        self.SetH ( self.start, 0 )
-        self.SetF ( self.start, 0 )
-        
-        doContinue = True
-        
-        while (doContinue == True):
-        
-            thisLowestFNode = self.GetLowestFNode()
-
-            if not thisLowestFNode == self.end and not thisLowestFNode == False:
-                self.current = thisLowestFNode
-                self.RemoveFromOpenList( self.current )
-                self.AddToClosedList( self.current )
-                
-                for offset in self.neighborSet:
-                    thisNeighbor = (self.current[0] + offset[0], self.current[1] + offset[1])
-                    
-                    if not thisNeighbor[0] < 0 and not thisNeighbor[1] < 0 and not thisNeighbor[0] > self.size[0] - 1 and not thisNeighbor[1] > self.size[1] - 1 and not self.GetType( thisNeighbor ) == 1:
-                        cost = self.GetG( self.current ) + 10
-                        
-                        if self.IsInOpenList( thisNeighbor ) and cost < self.GetG( thisNeighbor ):
-                            self.RemoveFromOpenList( thisNeighbor )
-                            
-                        #if self.IsInClosedList( thisNeighbor ) and cost < self.GetG( thisNeighbor ):
-                        #   self.RemoveFromClosedList( thisNeighbor )
-                            
-                        if not self.IsInOpenList( thisNeighbor ) and not self.IsInClosedList( thisNeighbor ):
-                            self.AddToOpenList( thisNeighbor )
-                            self.SetG( thisNeighbor, cost )
-                            self.CalcH( thisNeighbor )
-                            self.CalcF( thisNeighbor )
-                            self.SetParent( thisNeighbor, self.current )
-            else:
-                doContinue = False
-                        
-        if thisLowestFNode == False:
-            return False
-                        
-        # reconstruct path
-        self.current = self.end
-        while not self.current == self.start:
-            # build a string representation of the path using R, L, D, U
-            if self.current[1] > self.GetParent(self.current)[1]:
-                self.pathChainRev += 'R' 
-            elif self.current[1] < self.GetParent(self.current)[1]:
-                self.pathChainRev += 'L'
-            elif self.current[0] > self.GetParent(self.current)[0]:
-                self.pathChainRev += 'D'
-            elif self.current[0] < self.GetParent(self.current)[0]:
-                self.pathChainRev += 'U'
-            self.current = self.GetParent(self.current)
-            self.SetType( self.current[0],self.current[1], 4)
-            
-        # because pathChainRev was constructed in reverse order, it needs to be reversed!
-        for i in range(len(self.pathChainRev) - 1, -1, -1):
-            self.pathChain += self.pathChainRev[i]
-        
-        # set start and ending positions for future reference
-        self.SetType( self.start[0],self.start[1], 2)
-        self.SetType( self.end[0],self.start[1], 3)
-        
-        return self.pathChain
-
-    def Unfold (self, row,col):
-        # this function converts a 2D array coordinate pair (row, col)
-        # to a 1D-array index, for the object's 1D map array.
-        return (row * self.size[1]) + col
-    
-    def Set (self, row,col, newNode):
-        # sets the value of a particular map cell (usually refers to a node object)
-        self.map[ self.Unfold(row, col) ] = newNode
-        
-    def GetType (self,val):
-        row,col = val
-        return self.map[ self.Unfold(row, col) ].type
-        
-    def SetType (self,row,col, newValue):
-        self.map[ self.Unfold(row, col) ].type = newValue
-
-    def GetF (self, val):
-        row,col = val
-        return self.map[ self.Unfold(row, col) ].f
-
-    def GetG (self, val):
-        row,col = val
-        return self.map[ self.Unfold(row, col) ].g
-    
-    def GetH (self, val):
-        row,col = val
-        return self.map[ self.Unfold(row, col) ].h
-        
-    def SetG (self, val, newValue ):
-        row,col = val
-        self.map[ self.Unfold(row, col) ].g = newValue
-
-    def SetH (self, val, newValue ):
-        row,col = val
-        self.map[ self.Unfold(row, col) ].h = newValue
-        
-    def SetF (self, val, newValue ):
-        row,col = val
-        self.map[ self.Unfold(row, col) ].f = newValue
-        
-    def CalcH (self, val):
-        row,col = val
-        self.map[ self.Unfold(row, col) ].h = abs(row - self.end[0]) + abs(col - self.end[0])
-        
-    def CalcF (self, val):
-        row,col = val
-        unfoldIndex = self.Unfold(row, col)
-        self.map[unfoldIndex].f = self.map[unfoldIndex].g + self.map[unfoldIndex].h
-    
-    def AddToOpenList (self, val):
-        row,col = val
-        self.openList.append( (row, col) )
-        
-    def RemoveFromOpenList (self, val ):
-        row,col = val
-        self.openList.remove( (row, col) )
-        
-    def IsInOpenList (self, val ):
-        row,col = val
-        if self.openList.count( (row, col) ) > 0:
-            return True
-        else:
-            return False
-        
-    def GetLowestFNode (self):
-        lowestValue = 1000 # start arbitrarily high
-        lowestPair = (-1, -1)
-        
-        for iOrderedPair in self.openList:
-            if self.GetF( iOrderedPair ) < lowestValue:
-                lowestValue = self.GetF( iOrderedPair )
-                lowestPair = iOrderedPair
-        
-        if not lowestPair == (-1, -1):
-            return lowestPair
-        else:
-            return False
-        
-    def AddToClosedList (self, val ):
-        row,col = val
-        self.closedList.append( (row, col) )
-        
-    def IsInClosedList (self, val ):
-        row,col = val
-        if self.closedList.count( (row, col) ) > 0:
-            return True
-        else:
-            return False
-
-    def SetParent (self, val, val2 ):
-        row,col = val
-        parentRow,parentCol = val2
-        self.map[ self.Unfold(row, col) ].parent = (parentRow, parentCol)
-
-    def GetParent (self, val ):
-        row,col = val
-        return self.map[ self.Unfold(row, col) ].parent
-        
-    # def draw (self):
-    #     for row in range(0, self.size[0], 1):
-    #         for col in range(0, self.size[1], 1):
-            
-    #             thisTile = self.GetType((row, col))
-    #             screen.blit (self.tileIDImage[ thisTile ], (col * 32, row * 32))
-        
\ No newline at end of file
diff --git a/games/pacman/player.py b/games/pacman/player.py
deleted file mode 100644
index 6ddd81e..0000000
--- a/games/pacman/player.py
+++ /dev/null
@@ -1,153 +0,0 @@
-import pygame 
-import os
-from games.pacman.config import SCRIPT_PATH
-class pacman ():
-    
-    def __init__ (self, path, screen):
-        self.screen = screen
-        self.path = path
-        self.x = 0
-        self.y = 0
-        self.velX = 0
-        self.velY = 0
-        self.speed = 2
-        
-        self.nearestRow = 0
-        self.nearestCol = 0
-        
-        self.homeX = 0
-        self.homeY = 0
-        
-        self.anim_pacmanL = {}
-        self.anim_pacmanR = {}
-        self.anim_pacmanU = {}
-        self.anim_pacmanD = {}
-        self.anim_pacmanS = {}
-        self.anim_pacmanCurrent = {}
-        
-        for i in range(1, 9, 1):
-            self.anim_pacmanL[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","pacman-l " + str(i) + ".gif")).convert()
-            self.anim_pacmanR[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","pacman-r " + str(i) + ".gif")).convert()
-            self.anim_pacmanU[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","pacman-u " + str(i) + ".gif")).convert()
-            self.anim_pacmanD[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","pacman-d " + str(i) + ".gif")).convert()
-            self.anim_pacmanS[i] = pygame.image.load(os.path.join(SCRIPT_PATH,"res","sprite","pacman.gif")).convert()
-
-        self.pelletSndNum = 0
-        
-    def Move (self, thisGame, thisLevel, ghosts, thisFruit, tileID):   
-        
-        self.nearestRow = int(((self.y + 8) / 16))
-        self.nearestCol = int(((self.x + 8) / 16))
-
-        # make sure the current velocity will not cause a collision before moving
-        if not thisLevel.CheckIfHitWall(self.x + self.velX, self.y + self.velY, self.nearestRow, self.nearestCol):
-            # it's ok to Move
-            self.x += self.velX
-            self.y += self.velY
-            
-            # check for collisions with other tiles (pellets, etc)
-            thisLevel.CheckIfHitSomething(self.x, self.y, self.nearestRow, self.nearestCol, tileID)
-            
-            # check for collisions with the ghosts
-            for i in range(0, 4, 1):
-                if thisLevel.CheckIfHit( self.x, self.y, ghosts[i].x, ghosts[i].y, 8):
-                    # hit a ghost
-                    
-                    if ghosts[i].state == 1:
-                        # ghost is normal
-                        thisGame.SetMode( 2 )
-                        
-                    elif ghosts[i].state == 2:
-                        # ghost is vulnerable
-                        # give them glasses
-                        # make them run
-                        thisGame.AddToScore(thisGame.ghostValue)
-                        thisGame.ghostValue = thisGame.ghostValue * 2
-                        #snd_eatgh.play()
-                        
-                        ghosts[i].state = 3
-                        ghosts[i].speed = ghosts[i].speed * 4
-                        # and send them to the ghost box
-                        ghosts[i].x = ghosts[i].nearestCol * 16
-                        ghosts[i].y = ghosts[i].nearestRow * 16
-                        ghosts[i].currentPath = self.path.FindPath( (ghosts[i].nearestRow, ghosts[i].nearestCol), (thisLevel.GetGhostBoxPos(tileID)[0]+1, thisLevel.GetGhostBoxPos(tileID)[1]) )
-                        ghosts[i].FollowNextPathWay(thisLevel, tileID)
-                        
-                        # set game mode to brief pause after eating
-                        thisGame.SetMode( 5 )
-                        
-            # check for collisions with the fruit
-            if thisFruit.active == True:
-                if thisLevel.CheckIfHit( self.x, self.y, thisFruit.x, thisFruit.y, 8):
-                    thisGame.AddToScore(2500)
-                    thisFruit.active = False
-                    thisGame.fruitTimer = 0
-                    thisGame.fruitScoreTimer = 120
-                    #snd_eatfruit.play()
-        
-        else:
-            # we're going to hit a wall -- stop moving
-            self.velX = 0
-            self.velY = 0
-            
-        # deal with power-pellet ghost timer
-        if thisGame.ghostTimer > 0:
-            thisGame.ghostTimer -= 1
-            
-            if thisGame.ghostTimer == 0:
-                for i in range(0, 4, 1):
-                    if ghosts[i].state == 2:
-                        ghosts[i].state = 1
-                self.ghostValue = 0
-                
-        # deal with fruit timer
-        thisGame.fruitTimer += 1
-        if thisGame.fruitTimer == 500:
-            pathwayPair = thisLevel.GetPathwayPairPos(tileID)
-            
-            if not pathwayPair == False:
-            
-                pathwayEntrance = pathwayPair[0]
-                pathwayExit = pathwayPair[1]
-                
-                thisFruit.active = True
-                
-                thisFruit.nearestRow = pathwayEntrance[0]
-                thisFruit.nearestCol = pathwayEntrance[1]
-                
-                thisFruit.x = thisFruit.nearestCol * 16
-                thisFruit.y = thisFruit.nearestRow * 16
-                
-                thisFruit.currentPath = self.path.FindPath( (thisFruit.nearestRow, thisFruit.nearestCol), pathwayExit )
-                thisFruit.FollowNextPathWay()
-            
-        if thisGame.fruitScoreTimer > 0:
-            thisGame.fruitScoreTimer -= 1
-            
-        
-    def Draw (self, thisGame):
-        
-        if thisGame.mode == 3:
-            return False
-        
-        # set the current frame array to match the direction pacman is facing
-        if self.velX > 0:
-            self.anim_pacmanCurrent = self.anim_pacmanR
-        elif self.velX < 0:
-            self.anim_pacmanCurrent = self.anim_pacmanL
-        elif self.velY > 0:
-            self.anim_pacmanCurrent = self.anim_pacmanD
-        elif self.velY < 0:
-            self.anim_pacmanCurrent = self.anim_pacmanU
-            
-        self.screen.blit (self.anim_pacmanCurrent[ self.animFrame ], (self.x - thisGame.screenPixelPos[0], self.y - thisGame.screenPixelPos[1]))
-        
-        if thisGame.mode == 1:
-            if not self.velX == 0 or not self.velY == 0:
-                # only Move mouth when pacman is moving
-                self.animFrame += 1 
-            
-            if self.animFrame == 9:
-                # wrap to beginning
-                self.animFrame = 1
-            
\ No newline at end of file
diff --git a/games/pacman/res/VeraMoBd.ttf b/games/pacman/res/VeraMoBd.ttf
deleted file mode 100644
index 9be6547..0000000
Binary files a/games/pacman/res/VeraMoBd.ttf and /dev/null differ
diff --git a/games/pacman/res/backgrounds/1.gif b/games/pacman/res/backgrounds/1.gif
deleted file mode 100644
index fddeb90..0000000
Binary files a/games/pacman/res/backgrounds/1.gif and /dev/null differ
diff --git a/games/pacman/res/crossref.txt b/games/pacman/res/crossref.txt
deleted file mode 100644
index bfb3780..0000000
--- a/games/pacman/res/crossref.txt
+++ /dev/null
@@ -1,68 +0,0 @@
-'    ____                  ____             ____
-'   / __/_ _____  ___ ____/ __/__________  / / /
-'  _\ \/ // / _ \/ -_) __/\ \/ __/ __/ _ \/ / / 
-' /___/\_,_/ .__/\__/_/ /___/\__/_/  \___/_/_/  
-'         /_/                  game engine
-'
-' Cross-reference for tiles and sprites.
-'
-' Syntax for each line is:
-'      [number] [tilename] [tile description]
-' Ex.  5130 wirecornerul upper-left corner of wire path
-'
-' Tile numbers may go from 1-32767. (Tile 0 is empty space.)
-' Tiles 9000-9999 are invisible during gameplay.
-'
-' Commands:
-'      # tiles              < tile declarations start here
-'      # sprites            < sprite descriptions start here
-' __________________________________________________________
-
-
-# tiles
-
-1 ghost-door wall of the ghost box
-2 pellet a normal pellet (required)
-3 pellet-power a power pellet (makes pac-man invincible)
-4 start the starting position for pac-man
-
-10 ghost-blinky blinky
-11 ghost-pinky pinky
-12 ghost-inky inky
-13 ghost-sue sue
-
-20 door-h horizontal door (flip to other side of maze)
-21 door-v vertical door (flip to other side of maze)
-22 showlogo causes the logo to be drawn
-23 hiscores generate and draw a hi-score list
-
-100 wall-straight-horiz a horizontal wall
-101 wall-straight-vert a vertical wall
-
-105 wall-corner-ll lower-left corner of a wall
-106 wall-corner-lr lower-right corner of a wall
-107 wall-corner-ul upper-left corner of a wall
-108 wall-corner-ur upper-right corner of a wall
-
-110 wall-end-b bottom end of a wall
-111 wall-end-l left end of a wall
-112 wall-end-r right end of a wall
-113 wall-end-t top end of a wall
-
-120 wall-nub a one-tile "nub" wall
-
-130 wall-t-bottom a "T"-shaped wall, bottom-orientation
-131 wall-t-left a "T"-shaped wall, left-orientation
-132 wall-t-right a "T"-shaped wall, right-orientation
-133 wall-t-top a "T"-shaped wall, top-orientation
-
-140 wall-x a four-way wall
-
-300 glasses ghost glasses
-
-500 x-paintwall use this tile to paint walls automatically
-
-
-
-# sprites
-
diff --git a/games/pacman/res/hiscore.txt b/games/pacman/res/hiscore.txt
deleted file mode 100644
index 48bdfbf..0000000
--- a/games/pacman/res/hiscore.txt
+++ /dev/null
@@ -1,6 +0,0 @@
-135260 David
-100000 David
-80000 Andy
-60000 Count Pacula
-40000 Cleopacra
-24790 User
diff --git a/games/pacman/res/levels/0.txt b/games/pacman/res/levels/0.txt
deleted file mode 100644
index cd90d89..0000000
--- a/games/pacman/res/levels/0.txt
+++ /dev/null
@@ -1,48 +0,0 @@
-# lvlwidth 35
-# lvlheight 35
-# bgcolor 0 0 0
-# edgelightcolor 0 0 255
-# edgeshadowcolor 0 0 255
-# fillcolor 0 0 0
-# pelletcolor 255 255 255
-# fruittype 1
-
-# startleveldata
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 22 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 107 100 100 100 100 100 100 100 108 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 101 3 2 2 2 2 2 3 101 0 0 0 0 0 0 0 0 0 0 0 0 0 
-111 100 100 100 100 100 100 100 100 100 100 100 100 106 2 0 0 0 0 0 2 105 100 100 100 100 100 100 100 100 100 100 100 100 112 
-20 2 2 2 2 2 2 2 2 2 2 2 2 2 2 0 0 4 0 0 2 2 2 2 2 2 2 2 2 2 2 2 2 2 20 
-120 0 111 100 100 100 100 100 100 100 100 100 100 108 2 0 0 0 0 0 2 107 100 100 100 100 100 100 100 100 100 100 100 100 112 
-0 0 0 0 0 0 0 0 0 0 0 0 0 101 3 2 2 2 2 2 3 101 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 105 100 100 100 100 100 100 100 106 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 23 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 107 112 1 111 108 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 101 11 12 13 101 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 105 100 100 100 106 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-# endleveldata
-
-# sprites
diff --git a/games/pacman/res/levels/1.txt b/games/pacman/res/levels/1.txt
deleted file mode 100644
index f6a84e6..0000000
--- a/games/pacman/res/levels/1.txt
+++ /dev/null
@@ -1,37 +0,0 @@
-# lvlwidth 21
-# lvlheight 25
-# bgcolor 0 0 0
-# edgecolor 0 0 255
-# fillcolor 0 0 0
-# pelletcolor 255 255 255
-# fruittype 1
-
-# startleveldata
-0 0 0 0 0 0 0 0 0 113 21 113 0 0 0 0 0 0 0 0 0 
-0 107 100 100 100 100 100 100 100 106 0 105 100 100 100 100 100 100 100 108 0 
-0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 
-0 101 3 120 2 113 2 111 100 108 2 107 100 112 2 113 2 120 3 101 0 
-0 101 2 2 2 101 2 2 2 101 2 101 2 2 2 101 2 2 2 101 0 
-0 101 2 111 100 106 2 113 2 110 2 110 2 113 2 105 100 112 2 101 0 
-0 101 2 2 2 2 2 101 2 2 2 2 2 101 2 2 2 2 2 101 0 
-0 101 2 120 2 111 100 130 100 112 2 111 100 130 100 112 2 120 2 101 0 
-0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 
-0 105 100 108 2 113 2 111 100 100 100 100 100 112 2 113 2 107 100 106 0 
-0 0 0 101 2 101 2 2 0 0 10 0 0 2 2 101 2 101 0 0 0 
-111 100 100 106 2 105 112 2 107 112 1 111 108 2 111 106 2 105 100 100 112 
-20 0 0 0 2 0 0 2 101 11 12 13 101 2 0 0 2 0 0 0 20 
-111 133 100 112 2 111 112 2 105 100 100 100 106 2 111 112 2 111 100 133 112 
-0 101 2 2 2 0 0 2 0 0 0 0 0 2 0 0 2 2 2 101 0 
-0 101 2 120 2 107 112 2 111 100 100 100 112 2 111 108 2 120 2 101 0 
-0 101 2 2 2 101 2 2 0 0 4 0 0 2 2 101 2 2 2 101 0 
-0 105 133 112 2 110 2 111 100 100 133 100 100 112 2 110 2 111 133 106 0 
-0 0 101 2 2 2 2 2 2 2 101 2 2 2 2 2 2 2 101 0 0 
-0 0 101 2 111 112 2 111 108 2 101 2 107 112 2 111 112 2 101 0 0 
-107 100 106 2 2 2 2 2 101 2 101 2 101 2 2 2 2 2 105 100 108 
-101 2 2 2 111 100 112 2 110 2 110 2 110 2 111 100 112 2 2 2 101 
-101 3 120 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 120 3 101 
-101 2 2 2 107 100 100 100 100 108 0 107 100 100 100 100 108 2 2 2 101 
-105 100 100 100 106 0 0 0 0 110 21 110 0 0 0 0 105 100 100 100 106 
-# endleveldata
-
-# sprites
diff --git a/games/pacman/res/levels/10.txt b/games/pacman/res/levels/10.txt
deleted file mode 100644
index e254045..0000000
--- a/games/pacman/res/levels/10.txt
+++ /dev/null
@@ -1,35 +0,0 @@
-# lvlwidth 21
-# lvlheight 23
-# bgcolor 0 0 0
-# edgecolor 128 0 64
-# fillcolor 215 0 107
-# pelletcolor 0 255 0
-# fruittype 3
-
-# startleveldata
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 107 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 108 0 
-0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 
-111 106 3 120 2 111 100 108 2 111 100 112 2 107 100 112 2 120 3 105 112 
-20 0 2 2 2 2 2 101 2 2 2 2 2 101 2 2 2 2 2 0 20 
-111 100 100 112 2 120 2 110 2 113 2 113 2 110 2 120 2 111 100 100 112 
-20 0 0 0 2 2 2 2 2 101 2 101 2 2 2 2 2 0 0 0 20 
-111 108 0 120 2 113 2 111 100 106 2 105 100 112 2 113 2 120 0 107 112 
-0 101 2 2 2 101 2 0 0 0 10 0 0 0 2 101 2 2 2 101 0 
-0 101 2 111 100 130 112 2 107 112 1 111 108 2 111 130 100 112 2 101 0 
-0 101 2 2 2 2 2 2 101 11 12 13 101 2 2 2 2 2 2 101 0 
-0 101 2 111 133 100 112 2 105 100 100 100 106 2 111 100 133 112 2 101 0 
-0 101 2 2 101 2 2 2 0 0 0 0 0 2 2 2 101 2 2 101 0 
-0 131 112 2 110 2 107 100 112 0 113 0 111 100 108 2 110 2 111 132 0 
-0 101 2 2 2 2 101 2 2 2 101 2 2 2 101 2 2 2 2 101 0 
-111 106 2 120 0 111 106 2 120 2 101 2 120 2 105 112 0 120 2 105 112 
-20 0 2 2 2 2 2 2 2 2 101 2 2 2 2 2 2 2 2 0 20 
-111 100 100 112 2 111 108 2 111 100 130 100 112 2 107 112 2 111 100 100 112 
-20 0 2 2 2 2 101 2 2 2 4 2 2 2 101 2 2 2 2 0 20 
-111 108 3 111 112 2 105 100 112 2 120 2 111 100 106 2 111 112 3 107 112 
-0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 
-0 105 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 106 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-# endleveldata
-
-# sprites
diff --git a/games/pacman/res/levels/11.txt b/games/pacman/res/levels/11.txt
deleted file mode 100644
index c546ac7..0000000
--- a/games/pacman/res/levels/11.txt
+++ /dev/null
@@ -1,36 +0,0 @@
-# lvlwidth 21
-# lvlheight 23
-# bgcolor 0 0 0
-# edgelightcolor 203 211 44
-# edgeshadowcolor 0 64 0
-# fillcolor 0 0 0
-# pelletcolor 255 0 0
-# fruittype 1
-
-# startleveldata
-113 21 107 100 100 100 100 100 100 100 133 100 100 100 100 100 100 100 108 21 113 
-101 0 110 0 0 2 2 2 2 2 110 2 2 2 2 2 0 0 110 0 101 
-101 0 0 0 113 2 113 2 113 2 2 2 113 2 113 2 113 0 0 0 101 
-131 100 100 100 106 3 110 2 110 2 113 2 110 2 110 3 105 100 100 100 132 
-101 2 2 2 2 2 2 2 2 2 101 2 2 2 2 2 2 2 2 2 101 
-101 2 107 100 112 2 113 0 111 100 140 100 112 0 113 2 111 100 108 2 101 
-101 2 101 2 2 2 101 0 0 0 101 0 0 0 101 2 2 2 101 2 101 
-101 2 110 2 111 100 130 100 112 0 110 0 111 100 130 100 112 2 110 2 101 
-101 2 2 2 0 0 0 0 0 0 10 0 0 0 0 0 0 2 2 2 101 
-101 2 111 100 100 100 108 0 107 112 1 111 108 0 107 100 100 100 112 2 101 
-101 2 2 2 2 2 110 0 101 11 12 13 101 0 110 2 2 2 2 2 101 
-105 100 100 100 112 2 2 2 131 100 100 100 132 2 2 2 111 100 100 100 106 
-20 0 0 0 0 0 113 2 110 0 0 0 110 2 113 0 0 0 0 0 20 
-107 100 100 100 100 100 106 2 0 0 113 0 0 2 105 100 100 100 100 100 108 
-101 2 2 2 2 2 2 2 111 100 140 100 112 2 2 2 2 2 2 2 101 
-101 2 113 2 107 100 108 0 0 0 101 0 0 0 107 100 108 2 113 2 101 
-101 2 101 2 110 0 105 100 112 0 110 0 111 100 106 0 110 2 101 2 101 
-101 2 101 2 2 2 2 2 2 2 4 2 2 2 2 2 2 2 101 2 101 
-101 2 110 2 120 2 111 100 108 2 113 2 107 100 112 2 120 2 110 2 101 
-101 2 2 2 3 2 2 2 101 2 101 2 101 2 2 2 3 2 2 2 101 
-101 0 113 2 111 100 112 2 110 2 110 2 110 2 111 100 112 2 113 0 101 
-101 0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 101 
-110 21 105 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 106 21 110 
-# endleveldata
-
-# sprites
diff --git a/games/pacman/res/levels/12.txt b/games/pacman/res/levels/12.txt
deleted file mode 100644
index 137aad1..0000000
--- a/games/pacman/res/levels/12.txt
+++ /dev/null
@@ -1,40 +0,0 @@
-# lvlwidth 21
-# lvlheight 27
-# bgcolor 0 0 0
-# edgelightcolor 52 61 139
-# edgeshadowcolor 35 41 95
-# fillcolor 0 0 0
-# pelletcolor 238 183 128
-# fruittype 3
-
-# startleveldata
-111 112 21 111 100 100 100 100 100 100 100 100 100 100 100 100 100 112 21 111 112 
-20 0 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 0 20 
-111 108 2 107 100 100 100 100 100 100 100 100 100 100 100 100 100 108 2 107 112 
-0 101 2 101 22 0 0 0 0 0 0 0 0 0 0 0 0 101 2 101 0 
-0 101 2 101 0 0 0 0 0 0 0 0 0 0 0 0 0 101 2 101 0 
-111 106 2 101 0 0 0 0 0 0 0 0 0 0 0 0 0 101 2 105 112 
-20 0 2 105 100 100 133 100 100 100 133 100 100 100 133 100 100 106 2 0 20 
-111 108 2 2 2 2 110 2 2 2 110 2 2 2 110 2 2 2 2 107 112 
-0 101 2 111 108 2 2 2 113 0 10 0 113 2 2 2 107 112 2 101 0 
-0 101 2 2 110 0 120 0 131 112 1 111 132 0 120 0 110 2 2 101 0 
-0 131 108 2 2 2 2 2 101 11 12 13 101 2 2 2 2 2 107 132 0 
-111 130 106 2 111 100 112 2 105 100 100 100 106 2 111 100 112 2 105 130 112 
-20 0 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 0 20 
-111 108 2 113 2 120 2 113 2 120 0 120 2 113 2 120 2 113 2 107 112 
-0 101 2 101 2 2 2 101 2 2 4 2 2 101 2 2 2 101 2 101 0 
-0 101 2 110 2 111 100 130 100 112 0 111 100 130 100 112 2 110 2 101 0 
-0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 
-111 106 2 120 3 120 2 120 2 113 2 113 2 120 2 120 3 120 2 105 112 
-20 0 2 2 2 2 2 2 2 101 2 101 2 2 2 2 2 2 2 0 20 
-111 108 2 111 100 112 2 111 100 106 2 105 100 112 2 111 100 112 2 107 112 
-0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 
-0 105 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 106 0 
-0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 
-0 0 0 107 100 100 100 100 100 100 133 100 100 100 100 100 100 108 0 0 0 
-0 107 100 106 2 2 2 2 2 2 110 2 2 2 2 2 2 105 100 108 0 
-0 101 2 2 2 107 100 100 108 2 2 2 107 100 100 108 2 2 2 101 0 
-0 110 21 111 100 106 0 0 105 100 100 100 106 0 0 105 100 112 21 110 0 
-# endleveldata
-
-# sprites
diff --git a/games/pacman/res/levels/2.txt b/games/pacman/res/levels/2.txt
deleted file mode 100644
index b65a9eb..0000000
--- a/games/pacman/res/levels/2.txt
+++ /dev/null
@@ -1,35 +0,0 @@
-# lvlwidth 33
-# lvlheight 23
-# bgcolor 0 0 0
-# edgecolor 85 0 170
-# fillcolor 128 0 255
-# pelletcolor 255 255 255
-# fruittype 2
-
-# startleveldata
-0 113 21 113 0 0 0 0 0 0 0 0 0 0 0 113 21 113 0 0 0 0 0 0 0 0 0 0 0 113 21 113 0 
-0 101 0 105 100 100 100 100 100 100 133 100 100 100 100 106 0 105 100 100 100 100 133 100 100 100 100 100 100 106 0 101 0 
-0 101 2 2 2 2 2 2 2 2 101 2 2 2 2 2 2 2 2 2 2 2 101 2 2 2 2 2 2 2 2 101 0 
-111 106 3 111 112 2 113 2 113 2 110 2 111 100 100 100 133 100 100 100 112 2 110 2 113 2 113 2 111 112 3 105 112 
-20 0 2 2 2 2 101 2 101 0 0 2 2 2 2 2 101 2 2 2 2 2 0 0 101 2 101 2 2 2 2 0 20 
-111 108 0 111 100 100 106 2 105 100 112 2 111 100 108 0 101 0 107 100 112 2 111 100 106 2 105 100 100 112 0 107 112 
-0 101 2 2 2 2 2 2 2 2 2 2 0 0 110 0 110 0 110 0 0 2 2 2 2 2 2 2 2 2 2 101 0 
-0 131 100 100 112 2 111 100 108 2 107 100 112 0 0 0 10 0 0 0 111 100 108 2 107 100 112 2 111 100 100 132 0 
-0 101 2 2 2 2 2 2 110 2 110 0 0 0 107 112 1 111 108 0 0 0 110 2 110 2 2 2 2 2 2 101 0 
-0 101 2 120 0 111 112 2 2 2 2 2 113 0 101 11 12 13 101 0 113 2 2 2 2 2 111 112 0 120 2 101 0 
-0 101 2 2 2 2 2 2 120 0 111 100 132 2 105 100 100 100 106 2 131 100 112 0 120 2 2 2 2 2 2 101 0 
-0 101 2 111 100 100 112 2 2 2 3 2 110 2 2 2 2 2 2 2 110 2 3 2 2 2 111 100 100 112 2 101 0 
-0 101 2 2 2 2 2 2 113 0 113 2 2 2 113 2 113 2 113 2 2 2 113 0 113 2 2 2 2 2 2 101 0 
-0 101 2 111 112 0 120 2 110 0 110 2 111 100 106 2 110 2 105 100 112 2 110 0 110 2 120 0 111 112 2 101 0 
-0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 2 4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 
-0 105 100 108 2 107 112 0 111 100 100 100 112 0 111 100 133 100 112 0 111 100 100 100 112 0 111 108 2 107 100 106 0 
-0 0 0 101 2 101 2 2 2 2 2 2 2 2 2 2 101 2 2 2 2 2 2 2 2 2 2 101 2 101 0 0 0 
-111 100 100 106 2 101 2 113 2 111 133 100 100 100 108 2 110 2 107 100 100 100 133 112 2 113 2 101 2 105 100 100 112 
-20 0 0 0 2 101 2 101 2 2 101 2 2 2 101 2 2 2 101 2 2 2 101 2 2 101 2 101 2 0 0 0 20 
-111 108 0 120 3 110 2 105 112 2 110 2 113 2 110 2 120 2 110 2 113 2 110 2 111 106 2 110 3 120 0 107 112 
-0 101 0 0 2 2 2 2 2 2 2 2 101 2 2 2 2 2 2 2 101 2 2 2 2 2 2 2 2 0 0 101 0 
-0 101 0 107 100 100 100 100 100 100 100 100 130 100 100 108 0 107 100 100 130 100 100 100 100 100 100 100 100 108 0 101 0 
-0 110 21 110 0 0 0 0 0 0 0 0 0 0 0 110 21 110 0 0 0 0 0 0 0 0 0 0 0 110 21 110 0 
-# endleveldata
-
-# sprites
diff --git a/games/pacman/res/levels/3.txt b/games/pacman/res/levels/3.txt
deleted file mode 100644
index e72d1c4..0000000
--- a/games/pacman/res/levels/3.txt
+++ /dev/null
@@ -1,38 +0,0 @@
-# lvlwidth 21
-# lvlheight 25
-# bgcolor 0 0 0
-# edgelightcolor 251 233 130
-# edgeshadowcolor 124 70 16
-# fillcolor 225 151 51
-# pelletcolor 255 255 255
-# fruittype 3
-
-# startleveldata
-0 0 0 0 0 0 0 0 0 113 21 113 0 0 0 0 0 0 0 0 0 
-111 100 100 100 100 100 100 108 0 101 0 101 0 107 100 100 100 100 100 100 112 
-20 0 3 2 2 2 2 101 0 101 0 101 0 101 2 2 2 2 3 0 20 
-111 108 2 107 100 108 2 101 0 101 0 101 0 101 2 107 100 108 2 107 112 
-0 101 2 101 0 101 2 105 100 106 0 105 100 106 2 101 0 101 2 101 0 
-0 101 2 101 0 101 2 2 2 2 2 2 2 2 2 101 0 101 2 101 0 
-0 101 2 101 0 131 133 133 133 133 133 133 133 133 133 132 0 101 2 101 0 
-0 101 2 131 133 140 140 130 130 130 130 130 130 130 140 140 133 132 2 101 0 
-0 101 2 105 130 130 106 2 2 2 10 2 2 2 105 130 130 106 2 101 0 
-0 101 0 2 2 0 0 2 107 112 1 111 108 2 0 0 2 2 0 101 0 
-0 105 100 108 2 107 108 2 101 11 12 13 101 2 107 108 2 107 100 106 0 
-0 0 0 101 2 105 106 2 105 100 100 100 106 2 105 106 2 101 0 0 0 
-0 0 0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 0 0 
-0 0 0 101 2 113 2 107 100 100 100 100 100 108 2 113 2 101 0 0 0 
-0 0 0 101 0 101 2 110 0 0 4 0 0 110 2 101 0 101 0 0 0 
-0 107 100 106 0 101 2 2 2 111 133 112 2 2 2 101 0 105 100 108 0 
-0 101 2 2 2 110 2 113 2 2 101 2 2 113 2 110 2 2 2 101 0 
-0 101 2 113 0 0 2 131 108 2 101 2 107 132 2 0 0 113 2 101 0 
-111 106 2 105 100 108 2 105 106 2 110 2 105 106 2 107 100 106 2 105 112 
-20 0 3 2 2 101 2 2 2 2 0 2 2 2 2 101 2 2 3 0 20 
-111 100 100 108 2 110 2 111 100 100 133 100 100 112 2 110 2 107 100 100 112 
-0 0 0 101 0 2 2 2 2 2 110 2 2 2 2 2 0 101 0 0 0 
-0 0 0 105 100 100 100 100 108 2 2 2 107 100 100 100 100 106 0 0 0 
-0 0 0 0 0 0 0 0 105 108 0 107 106 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 110 21 110 0 0 0 0 0 0 0 0 0 
-# endleveldata
-
-# sprites
diff --git a/games/pacman/res/levels/4.txt b/games/pacman/res/levels/4.txt
deleted file mode 100644
index 11394c2..0000000
--- a/games/pacman/res/levels/4.txt
+++ /dev/null
@@ -1,36 +0,0 @@
-# lvlwidth 21
-# lvlheight 23
-# bgcolor 0 0 0
-# edgelightcolor 128 255 0
-# edgeshadowcolor 128 255 0
-# fillcolor 0 128 0
-# pelletcolor 0 255 255
-# fruittype 4
-
-# startleveldata
-107 100 100 100 108 0 0 0 0 113 21 113 0 0 0 0 0 0 0 0 0 
-101 3 2 2 105 100 100 100 100 106 0 105 100 100 100 100 100 100 100 108 0 
-101 2 113 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 101 0 
-101 2 105 133 100 108 2 111 100 108 2 107 100 112 2 107 100 108 2 101 0 
-101 2 2 101 0 101 2 2 2 101 2 101 2 2 2 101 0 101 2 101 0 
-105 108 2 105 100 106 2 113 2 110 2 110 2 113 2 105 100 106 2 101 0 
-0 101 2 2 2 2 2 101 2 2 2 2 2 101 2 2 2 2 2 101 0 
-0 101 2 113 2 111 100 130 100 112 2 111 100 130 100 112 2 113 2 101 0 
-0 101 2 101 2 2 2 2 2 2 2 2 2 2 2 2 2 101 2 101 0 
-0 101 2 110 2 113 2 111 100 100 100 100 100 112 2 113 2 110 2 101 0 
-0 101 3 2 2 101 2 2 0 0 10 0 0 2 2 101 2 2 3 101 0 
-111 130 100 112 2 105 112 2 107 112 1 111 108 2 111 106 2 111 100 130 112 
-20 0 0 2 2 2 2 2 101 11 12 13 101 2 2 2 2 2 0 0 20 
-111 133 100 112 2 111 112 2 105 100 100 100 106 2 111 112 2 111 100 133 112 
-0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 
-0 101 2 113 0 107 112 2 111 100 100 100 112 2 111 108 0 113 2 101 0 
-0 101 2 101 0 101 2 2 0 0 4 0 0 2 2 101 0 101 2 101 0 
-0 101 2 110 0 110 2 111 100 100 133 100 100 112 2 110 0 110 2 101 0 
-0 101 2 2 2 2 2 2 2 2 101 2 2 2 2 2 2 2 2 101 0 
-0 101 2 120 2 120 2 111 112 2 110 2 111 112 2 120 2 120 2 101 0 
-0 101 3 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 101 0 
-0 105 100 100 100 100 100 100 100 108 0 107 100 100 100 100 100 100 100 106 0 
-0 0 0 0 0 0 0 0 0 110 21 110 0 0 0 0 0 0 0 0 0 
-# endleveldata
-
-# sprites
diff --git a/games/pacman/res/levels/5.txt b/games/pacman/res/levels/5.txt
deleted file mode 100644
index 74a735a..0000000
--- a/games/pacman/res/levels/5.txt
+++ /dev/null
@@ -1,78 +0,0 @@
-# lvlwidth 21
-# lvlheight 65
-# bgcolor 0 0 0
-# edgelightcolor 255 0 128
-# edgeshadowcolor 0 0 0
-# fillcolor 0 0 0
-# pelletcolor 0 0 255
-# fruittype 4
-
-# startleveldata
-113 21 113 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 113 21 113 
-101 0 105 100 100 100 100 100 100 100 100 100 100 100 100 100 100 100 106 0 101 
-101 0 0 0 2 2 2 2 2 0 0 0 2 2 2 2 2 0 0 0 101 
-131 100 100 112 3 120 2 113 2 111 100 112 2 113 2 120 3 111 100 100 132 
-101 2 2 2 2 2 2 101 2 2 2 2 2 101 2 2 2 2 2 2 101 
-101 2 111 108 2 111 100 140 100 112 2 111 100 140 100 112 2 107 112 2 101 
-101 2 2 101 2 2 2 101 2 2 2 2 2 101 2 2 2 101 2 2 101 
-131 112 2 101 2 113 2 110 2 111 133 112 2 110 2 113 2 101 2 111 132 
-101 2 2 101 2 101 2 2 2 2 101 2 2 2 2 101 2 101 2 2 101 
-101 2 111 132 2 105 100 100 112 2 110 2 111 100 100 106 2 131 112 2 101 
-101 2 2 101 2 2 2 2 2 2 0 2 2 2 2 2 2 101 2 2 101 
-105 108 2 110 2 113 2 120 2 111 100 112 2 120 2 113 2 110 2 107 106 
-0 101 2 2 2 101 2 2 2 2 2 2 2 2 2 101 2 2 2 101 0 
-111 130 100 112 2 105 100 100 100 108 2 107 100 100 100 106 2 111 100 130 112 
-20 0 0 0 2 2 2 2 2 101 2 101 2 2 2 2 2 0 0 0 20 
-107 100 100 100 100 100 100 112 2 110 2 110 2 111 100 100 100 100 100 100 108 
-101 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 
-101 2 107 108 3 120 0 113 0 111 133 112 0 113 0 120 3 107 108 2 101 
-101 2 131 132 2 0 0 101 0 0 101 0 0 101 0 0 2 131 132 2 101 
-101 2 131 132 2 111 100 130 112 0 101 0 111 130 100 112 2 131 132 2 101 
-101 2 131 132 2 2 2 2 2 2 101 2 2 2 2 2 2 131 132 2 101 
-101 2 131 132 2 107 112 2 113 2 110 2 113 2 111 108 2 131 132 2 101 
-101 2 131 132 2 110 2 2 101 2 2 2 101 2 2 110 2 131 132 2 101 
-101 2 131 132 2 0 2 111 132 0 120 0 131 112 2 0 2 131 132 2 101 
-101 2 131 132 2 113 2 2 101 0 0 0 101 2 2 113 2 131 132 2 101 
-101 2 131 106 2 105 112 2 110 0 113 0 110 2 111 106 2 105 132 2 101 
-110 2 101 0 2 2 2 2 2 2 101 2 2 2 2 2 2 0 101 2 110 
-20 2 101 0 111 112 2 107 112 2 101 2 111 108 2 111 112 0 101 2 20 
-113 2 101 2 2 2 2 101 2 2 101 2 2 101 2 2 2 2 101 2 113 
-101 2 101 2 113 2 111 106 2 111 130 112 2 105 112 2 113 2 101 2 101 
-101 2 101 2 101 2 2 2 2 0 0 0 2 2 2 2 101 2 101 2 101 
-101 2 101 2 105 100 100 100 112 0 113 0 111 100 100 100 106 2 101 2 101 
-101 2 101 2 2 2 2 0 0 0 101 0 0 0 2 2 2 2 101 2 101 
-101 2 101 3 111 112 2 111 100 100 130 100 100 112 2 111 112 3 101 2 101 
-101 2 101 2 2 2 2 2 0 0 10 0 0 2 2 2 2 2 101 2 101 
-101 2 131 133 133 133 108 2 107 112 1 111 108 2 107 133 133 133 132 2 101 
-101 2 105 130 130 130 106 2 101 11 12 13 101 2 105 130 130 130 106 2 101 
-101 2 2 2 2 2 2 2 105 100 100 100 106 2 2 2 2 2 2 2 101 
-131 133 133 133 133 133 108 0 0 0 0 0 0 0 107 133 133 133 133 133 132 
-131 140 140 130 130 130 130 100 100 108 2 107 100 100 130 130 130 130 140 140 132 
-105 130 132 2 2 2 2 2 2 101 2 101 2 2 2 2 2 2 131 130 106 
-20 0 110 2 107 100 100 112 2 110 2 110 2 111 100 100 108 2 110 0 20 
-113 2 2 2 101 2 2 2 2 2 2 2 2 2 2 2 101 2 2 2 113 
-101 2 111 133 132 2 111 100 100 100 133 100 100 100 112 2 131 133 112 2 101 
-101 2 2 131 132 2 2 2 2 2 101 2 2 2 2 2 131 132 2 2 101 
-131 108 2 105 106 2 113 2 113 2 101 2 113 2 113 2 105 106 2 107 132 
-131 132 2 2 2 2 101 2 110 2 110 2 110 2 101 2 2 2 2 131 132 
-131 140 133 133 108 2 101 2 0 2 2 2 0 2 101 2 107 133 133 140 132 
-131 140 140 140 132 2 101 2 107 112 2 111 108 2 101 2 131 140 140 140 132 
-131 140 140 140 106 2 110 2 110 2 4 2 110 2 110 2 105 140 140 140 132 
-105 130 130 106 2 2 2 2 2 2 113 2 2 2 2 2 2 105 130 130 106 
-20 0 0 2 2 113 2 111 100 100 140 100 100 112 2 113 2 2 0 0 20 
-113 0 113 2 107 132 2 2 2 2 110 2 2 2 2 131 108 2 113 0 113 
-101 0 101 2 131 132 3 111 112 2 0 2 111 112 3 131 132 2 101 0 101 
-101 0 101 2 105 132 2 0 0 2 113 2 0 0 2 131 106 2 101 0 101 
-101 0 101 2 2 101 2 111 112 2 101 2 111 112 2 101 2 2 101 0 101 
-101 0 131 108 2 101 2 2 2 2 101 2 2 2 2 101 2 107 132 0 101 
-101 0 131 106 2 101 2 111 100 100 130 100 100 112 2 101 2 105 132 0 101 
-101 0 101 2 2 101 2 2 2 2 2 2 2 2 2 101 2 2 101 0 101 
-101 0 101 2 107 132 2 111 100 108 2 107 100 112 2 131 108 2 101 0 101 
-101 0 101 2 131 132 2 2 2 101 2 101 2 2 2 131 132 2 101 0 101 
-101 0 101 2 105 130 100 112 2 110 2 110 2 111 100 130 106 2 101 0 101 
-101 0 101 2 2 2 2 2 2 2 3 2 2 2 2 2 2 2 101 0 101 
-101 0 131 133 133 133 133 133 133 133 133 133 133 133 133 133 133 133 132 0 101 
-110 21 105 130 130 130 130 130 130 130 130 130 130 130 130 130 130 130 106 21 110 
-# endleveldata
-
-# sprites
diff --git a/games/pacman/res/levels/6.txt b/games/pacman/res/levels/6.txt
deleted file mode 100644
index fe40285..0000000
--- a/games/pacman/res/levels/6.txt
+++ /dev/null
@@ -1,36 +0,0 @@
-# lvlwidth 21
-# lvlheight 23
-# bgcolor 0 0 0
-# edgelightcolor 255 255 255
-# edgeshadowcolor 0 128 255
-# fillcolor 129 11 168
-# pelletcolor 255 255 255
-# fruittype 3
-
-# startleveldata
-107 100 100 100 133 100 100 100 100 100 100 100 100 100 100 100 133 100 100 100 108 
-101 2 2 2 101 2 2 2 2 2 2 2 2 2 2 2 101 2 2 2 101 
-101 3 120 2 110 2 113 2 111 100 100 100 112 2 113 2 110 2 120 3 101 
-101 2 2 2 2 2 101 2 2 2 2 2 2 2 101 2 2 2 2 2 101 
-131 100 112 2 120 2 105 100 100 100 133 100 100 100 106 2 120 2 111 100 132 
-101 2 2 2 0 2 2 2 2 2 101 2 2 2 2 2 0 2 2 2 101 
-101 2 111 100 112 2 107 100 112 2 110 2 111 100 108 2 111 100 112 2 101 
-101 2 0 2 2 2 110 2 2 2 2 2 2 2 110 2 2 2 0 2 101 
-105 100 108 2 120 2 0 0 111 100 100 100 112 0 0 2 120 2 107 100 106 
-0 0 101 2 2 2 113 0 0 0 10 0 0 0 113 2 2 2 101 0 0 
-0 0 105 100 108 2 101 0 107 112 1 111 108 0 101 2 107 100 106 0 0 
-0 0 0 0 101 2 101 0 101 11 12 13 101 0 101 2 101 0 0 0 0 
-111 100 100 100 106 2 110 0 105 100 100 100 106 0 110 2 105 100 100 100 112 
-20 0 0 0 0 2 2 2 2 2 4 2 2 2 2 2 0 0 0 0 20 
-111 100 100 100 108 2 113 2 111 100 100 100 112 2 113 2 107 100 100 100 112 
-0 0 0 0 101 2 101 2 2 2 0 2 2 2 101 2 101 0 0 0 0 
-0 0 107 100 106 2 131 100 112 2 113 2 111 100 132 2 105 100 108 0 0 
-0 0 101 2 2 2 101 2 2 2 101 2 2 2 101 2 2 2 101 0 0 
-107 100 106 2 120 2 101 2 111 100 130 100 112 2 101 2 120 2 105 100 108 
-101 2 2 2 2 2 101 2 2 2 2 2 2 2 101 2 2 2 2 2 101 
-101 3 120 2 113 2 105 100 112 2 120 2 111 100 106 2 113 2 120 3 101 
-101 2 2 2 101 2 2 2 2 2 2 2 2 2 2 2 101 2 2 2 101 
-105 100 100 100 130 100 100 100 100 100 100 100 100 100 100 100 130 100 100 100 106 
-# endleveldata
-
-# sprites
diff --git a/games/pacman/res/levels/7.txt b/games/pacman/res/levels/7.txt
deleted file mode 100644
index a34c0a9..0000000
--- a/games/pacman/res/levels/7.txt
+++ /dev/null
@@ -1,35 +0,0 @@
-# lvlwidth 21
-# lvlheight 23
-# bgcolor 0 0 0
-# edgecolor 255 128 128
-# fillcolor 100 100 100
-# pelletcolor 170 0 85
-# fruittype 0
-
-# startleveldata
-120 21 111 100 108 0 107 100 100 100 100 100 100 100 108 0 107 100 112 21 120 
-20 2 2 2 105 100 106 2 2 2 2 2 2 2 105 100 106 2 2 2 20 
-113 3 120 2 2 2 2 2 111 100 133 100 112 2 2 2 2 2 120 3 113 
-101 2 2 2 107 100 108 2 2 2 101 2 2 2 107 100 108 2 2 2 101 
-105 100 100 100 106 0 101 2 113 2 101 2 113 2 101 0 105 100 100 100 106 
-0 0 0 0 0 0 101 2 101 2 101 2 101 2 101 0 0 0 0 0 0 
-107 100 100 100 100 100 106 2 101 2 110 2 101 2 105 100 100 100 100 100 108 
-101 2 2 2 2 2 2 2 101 2 2 2 101 2 2 2 2 2 2 2 101 
-101 2 113 2 113 2 111 100 130 112 0 111 130 100 112 2 113 2 113 2 101 
-101 2 101 2 101 2 2 2 2 2 4 2 2 2 2 2 101 2 101 2 101 
-101 2 110 2 105 100 100 112 2 113 0 113 2 111 100 100 106 2 110 2 101 
-101 2 2 2 2 2 2 2 2 101 0 101 2 2 2 2 2 2 2 2 101 
-105 100 108 2 107 112 2 107 100 106 0 105 100 108 2 111 108 2 107 100 106 
-0 0 101 2 101 2 2 101 2 2 2 2 2 101 2 2 101 2 101 0 0 
-0 0 101 2 110 2 111 106 2 111 100 112 2 105 112 2 110 2 101 0 0 
-0 0 101 2 2 2 2 2 2 0 10 0 2 2 2 2 2 2 101 0 0 
-0 0 105 100 108 2 120 2 107 112 1 111 108 2 120 2 107 100 106 0 0 
-0 0 0 0 101 2 2 2 101 11 12 13 101 2 2 2 101 0 0 0 0 
-0 0 0 0 101 2 120 2 105 100 100 100 106 2 120 2 101 0 0 0 0 
-0 0 0 0 101 2 2 2 2 2 2 2 2 2 2 2 101 0 0 0 0 
-111 100 100 100 106 0 113 2 111 100 100 100 112 2 113 0 105 100 100 100 112 
-20 0 0 0 0 0 101 2 2 2 3 2 2 2 101 0 0 0 0 0 20 
-120 21 111 100 100 100 130 100 100 100 100 100 100 100 130 100 100 100 112 21 120 
-# endleveldata
-
-# sprites
diff --git a/games/pacman/res/levels/8.txt b/games/pacman/res/levels/8.txt
deleted file mode 100644
index 21d3396..0000000
--- a/games/pacman/res/levels/8.txt
+++ /dev/null
@@ -1,36 +0,0 @@
-# lvlwidth 21
-# lvlheight 23
-# bgcolor 0 0 0
-# edgelightcolor 0 128 192
-# edgeshadowcolor 0 51 51
-# fillcolor 0 0 0
-# pelletcolor 255 128 0
-# fruittype 2
-
-# startleveldata
-0 0 0 0 0 0 0 0 113 21 113 21 113 0 0 0 0 0 0 0 0 
-0 0 0 107 100 100 100 100 106 0 110 0 105 100 100 100 100 108 0 0 0 
-0 0 0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 0 0 
-0 107 100 106 2 113 2 120 2 111 133 112 2 120 0 113 2 105 100 108 0 
-0 101 2 2 2 101 2 2 2 2 101 2 2 2 0 110 2 0 0 101 0 
-0 101 2 107 100 106 0 111 112 0 110 2 111 112 2 2 2 113 0 101 0 
-107 106 2 110 2 2 2 0 2 2 2 2 0 0 2 120 3 110 0 105 108 
-101 2 2 2 2 113 2 113 2 113 2 111 100 108 2 0 0 10 0 0 101 
-101 2 107 100 100 106 2 110 2 101 2 2 2 101 2 107 112 1 111 133 106 
-101 2 110 2 2 2 2 0 2 105 100 112 2 110 2 101 11 12 13 101 0 
-101 2 0 3 120 2 111 108 2 2 2 2 2 2 2 105 100 100 100 130 108 
-101 2 113 2 2 2 2 105 100 108 2 107 100 112 2 2 2 2 2 2 101 
-101 2 105 100 100 108 2 2 2 101 2 101 2 2 2 107 100 100 112 2 101 
-101 2 0 0 0 105 100 112 2 110 2 110 2 111 100 106 2 2 2 2 101 
-101 2 111 108 2 2 2 2 2 2 2 2 2 2 2 2 2 107 112 2 101 
-101 2 2 110 2 111 100 112 2 120 4 111 100 112 2 120 2 110 2 2 101 
-105 108 2 0 2 2 2 2 2 2 2 2 2 2 2 2 2 0 2 107 106 
-0 101 2 111 112 0 107 100 112 2 113 0 111 100 108 2 111 112 2 101 0 
-0 101 2 2 2 3 101 2 2 2 101 0 0 0 101 2 2 2 2 101 0 
-0 105 100 108 2 111 106 2 111 100 130 100 112 0 105 112 2 107 100 106 0 
-0 0 0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 0 0 
-0 0 0 105 100 100 100 100 108 0 113 0 107 100 100 100 100 106 0 0 0 
-0 0 0 0 0 0 0 0 110 21 110 21 110 0 0 0 0 0 0 0 0 
-# endleveldata
-
-# sprites
diff --git a/games/pacman/res/levels/9.txt b/games/pacman/res/levels/9.txt
deleted file mode 100644
index 3661b14..0000000
--- a/games/pacman/res/levels/9.txt
+++ /dev/null
@@ -1,46 +0,0 @@
-# lvlwidth 34
-# lvlheight 33
-# bgcolor 0 0 0
-# edgelightcolor 128 0 255
-# edgeshadowcolor 64 0 64
-# fillcolor 0 0 0
-# pelletcolor 0 255 0
-# fruittype 1
-
-# startleveldata
-0 0 0 0 0 0 0 0 0 113 21 113 0 0 0 0 0 0 0 0 0 0 113 21 113 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 101 0 101 0 0 0 0 0 0 0 0 0 0 101 0 101 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 101 0 101 0 0 0 0 0 0 0 0 0 0 101 0 101 0 0 0 0 0 0 0 0 0 
-0 0 0 107 100 100 100 100 100 106 0 105 100 100 100 100 100 100 100 100 100 100 106 0 105 100 100 100 100 100 108 0 0 0 
-0 0 0 101 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 0 0 
-111 100 100 106 3 111 100 133 100 112 2 111 100 100 100 108 2 113 2 113 2 111 108 2 113 0 120 3 113 2 105 100 100 112 
-20 0 0 0 2 2 2 101 2 2 2 2 2 2 2 101 2 101 2 101 2 2 101 2 101 0 0 0 101 2 0 0 0 20 
-111 100 100 108 2 113 2 110 2 111 100 133 100 112 2 101 2 101 2 105 112 2 110 2 101 0 111 100 106 2 107 100 100 112 
-0 0 0 101 2 101 2 2 2 2 2 101 2 2 2 101 2 101 2 2 2 2 2 2 101 0 0 0 0 2 101 0 0 0 
-0 0 0 101 2 131 100 112 2 113 2 101 2 111 100 106 2 105 100 100 100 100 112 2 131 100 100 100 112 2 101 0 0 0 
-0 0 0 101 2 101 2 2 2 101 2 101 2 2 2 2 2 2 2 2 2 2 2 2 101 2 2 2 2 2 101 0 0 0 
-0 0 0 101 2 110 2 111 100 132 2 110 2 111 100 100 100 100 100 100 100 100 112 2 101 2 111 100 108 0 101 0 0 0 
-0 0 0 101 2 0 2 2 2 101 2 2 2 0 0 0 0 0 0 0 10 0 0 2 101 2 2 2 101 0 101 0 0 0 
-0 0 0 101 2 111 100 112 2 110 0 113 2 107 100 100 108 0 107 112 1 111 108 2 110 2 120 2 101 0 101 0 0 0 
-0 0 0 101 2 2 2 2 2 0 0 101 2 101 0 0 101 0 101 11 12 13 101 2 2 2 2 2 101 0 101 0 0 0 
-0 0 0 101 2 111 100 100 100 100 100 132 2 105 100 100 106 0 105 100 100 100 106 2 111 100 108 2 101 0 101 0 0 0 
-0 0 0 101 2 2 2 2 2 2 2 101 2 2 2 2 2 2 2 2 2 2 2 2 0 0 101 2 101 0 101 0 0 0 
-0 0 0 101 0 111 100 100 100 108 2 110 0 113 2 113 2 111 100 100 100 100 100 100 112 0 101 2 101 0 101 0 0 0 
-0 0 0 101 2 2 2 2 2 101 2 2 2 101 2 101 2 2 2 2 2 2 2 2 2 0 101 2 101 0 101 0 0 0 
-0 0 0 101 2 107 100 112 2 105 100 112 2 101 2 101 2 111 100 100 133 100 100 112 2 111 106 2 110 0 101 0 0 0 
-0 0 0 101 2 101 0 4 2 2 2 2 2 101 2 101 2 2 2 2 101 2 2 2 2 2 2 2 2 2 101 0 0 0 
-0 0 0 101 2 110 0 107 100 100 100 112 0 110 2 110 2 111 112 2 101 2 107 100 100 100 100 100 108 2 101 0 0 0 
-0 0 0 101 2 0 0 101 2 2 2 2 2 2 2 2 2 2 2 2 101 2 101 0 0 2 2 2 110 2 101 0 0 0 
-0 0 0 101 2 111 100 106 2 113 2 113 2 120 2 113 0 111 112 2 101 2 101 0 113 2 113 2 2 2 101 0 0 0 
-0 0 0 101 2 2 2 2 3 101 2 101 2 2 2 101 2 2 2 2 101 2 101 0 110 3 105 100 112 2 101 0 0 0 
-111 100 100 106 2 111 100 100 100 106 2 101 2 120 2 110 2 111 112 0 110 2 101 2 2 2 2 2 2 2 105 100 100 112 
-20 0 0 0 2 2 2 2 2 2 2 101 2 2 2 2 2 2 2 2 2 2 101 2 107 108 2 107 108 2 0 0 0 20 
-111 100 100 108 2 111 100 100 100 112 2 105 100 100 100 112 0 111 100 100 100 100 106 2 105 106 2 105 106 2 107 100 100 112 
-0 0 0 101 2 2 2 0 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 101 0 0 0 
-0 0 0 105 100 100 100 100 100 108 0 107 100 100 100 100 100 100 100 100 100 100 108 0 107 100 100 100 100 100 106 0 0 0 
-0 0 0 0 0 0 0 0 0 101 0 101 0 0 0 0 0 0 0 0 0 0 101 0 101 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 101 0 101 0 0 0 0 0 0 0 0 0 0 101 0 101 0 0 0 0 0 0 0 0 0 
-0 0 0 0 0 0 0 0 0 110 21 110 0 0 0 0 0 0 0 0 0 0 110 21 110 0 0 0 0 0 0 0 0 0 
-# endleveldata
-
-# sprites
diff --git a/games/pacman/res/sounds/eatfruit.wav b/games/pacman/res/sounds/eatfruit.wav
deleted file mode 100644
index d180209..0000000
Binary files a/games/pacman/res/sounds/eatfruit.wav and /dev/null differ
diff --git a/games/pacman/res/sounds/eatgh2.wav b/games/pacman/res/sounds/eatgh2.wav
deleted file mode 100644
index 7d8b90e..0000000
Binary files a/games/pacman/res/sounds/eatgh2.wav and /dev/null differ
diff --git a/games/pacman/res/sounds/extralife.wav b/games/pacman/res/sounds/extralife.wav
deleted file mode 100644
index 2db3c19..0000000
Binary files a/games/pacman/res/sounds/extralife.wav and /dev/null differ
diff --git a/games/pacman/res/sounds/fruitbounce.wav b/games/pacman/res/sounds/fruitbounce.wav
deleted file mode 100644
index 6e17741..0000000
Binary files a/games/pacman/res/sounds/fruitbounce.wav and /dev/null differ
diff --git a/games/pacman/res/sounds/pellet1.wav b/games/pacman/res/sounds/pellet1.wav
deleted file mode 100644
index 1d39b64..0000000
Binary files a/games/pacman/res/sounds/pellet1.wav and /dev/null differ
diff --git a/games/pacman/res/sounds/pellet2.wav b/games/pacman/res/sounds/pellet2.wav
deleted file mode 100644
index d8363d0..0000000
Binary files a/games/pacman/res/sounds/pellet2.wav and /dev/null differ
diff --git a/games/pacman/res/sounds/powerpellet.wav b/games/pacman/res/sounds/powerpellet.wav
deleted file mode 100644
index 489de59..0000000
Binary files a/games/pacman/res/sounds/powerpellet.wav and /dev/null differ
diff --git a/games/pacman/res/sprite/fruit 0.gif b/games/pacman/res/sprite/fruit 0.gif
deleted file mode 100644
index 8cc3dc4..0000000
Binary files a/games/pacman/res/sprite/fruit 0.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/fruit 1.gif b/games/pacman/res/sprite/fruit 1.gif
deleted file mode 100644
index 8adcf61..0000000
Binary files a/games/pacman/res/sprite/fruit 1.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/fruit 2.gif b/games/pacman/res/sprite/fruit 2.gif
deleted file mode 100644
index bda9369..0000000
Binary files a/games/pacman/res/sprite/fruit 2.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/fruit 3.gif b/games/pacman/res/sprite/fruit 3.gif
deleted file mode 100644
index ea8f006..0000000
Binary files a/games/pacman/res/sprite/fruit 3.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/fruit 4.gif b/games/pacman/res/sprite/fruit 4.gif
deleted file mode 100644
index 0be5f73..0000000
Binary files a/games/pacman/res/sprite/fruit 4.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/ghost 1.gif b/games/pacman/res/sprite/ghost 1.gif
deleted file mode 100644
index af02492..0000000
Binary files a/games/pacman/res/sprite/ghost 1.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/ghost 2.gif b/games/pacman/res/sprite/ghost 2.gif
deleted file mode 100644
index 89845aa..0000000
Binary files a/games/pacman/res/sprite/ghost 2.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/ghost 3.gif b/games/pacman/res/sprite/ghost 3.gif
deleted file mode 100644
index 5777f39..0000000
Binary files a/games/pacman/res/sprite/ghost 3.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/ghost 4.gif b/games/pacman/res/sprite/ghost 4.gif
deleted file mode 100644
index e95b7d7..0000000
Binary files a/games/pacman/res/sprite/ghost 4.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/ghost 5.gif b/games/pacman/res/sprite/ghost 5.gif
deleted file mode 100644
index 9956c84..0000000
Binary files a/games/pacman/res/sprite/ghost 5.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/ghost 6.gif b/games/pacman/res/sprite/ghost 6.gif
deleted file mode 100644
index 56533bf..0000000
Binary files a/games/pacman/res/sprite/ghost 6.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-d 1.gif b/games/pacman/res/sprite/pacman-d 1.gif
deleted file mode 100644
index b3db2db..0000000
Binary files a/games/pacman/res/sprite/pacman-d 1.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-d 2.gif b/games/pacman/res/sprite/pacman-d 2.gif
deleted file mode 100644
index 2e257c5..0000000
Binary files a/games/pacman/res/sprite/pacman-d 2.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-d 3.gif b/games/pacman/res/sprite/pacman-d 3.gif
deleted file mode 100644
index 84f4cf0..0000000
Binary files a/games/pacman/res/sprite/pacman-d 3.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-d 4.gif b/games/pacman/res/sprite/pacman-d 4.gif
deleted file mode 100644
index ee009c5..0000000
Binary files a/games/pacman/res/sprite/pacman-d 4.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-d 5.gif b/games/pacman/res/sprite/pacman-d 5.gif
deleted file mode 100644
index 5fa29e9..0000000
Binary files a/games/pacman/res/sprite/pacman-d 5.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-d 6.gif b/games/pacman/res/sprite/pacman-d 6.gif
deleted file mode 100644
index ee009c5..0000000
Binary files a/games/pacman/res/sprite/pacman-d 6.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-d 7.gif b/games/pacman/res/sprite/pacman-d 7.gif
deleted file mode 100644
index 84f4cf0..0000000
Binary files a/games/pacman/res/sprite/pacman-d 7.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-d 8.gif b/games/pacman/res/sprite/pacman-d 8.gif
deleted file mode 100644
index 2e257c5..0000000
Binary files a/games/pacman/res/sprite/pacman-d 8.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-l 1.gif b/games/pacman/res/sprite/pacman-l 1.gif
deleted file mode 100644
index ee7f79a..0000000
Binary files a/games/pacman/res/sprite/pacman-l 1.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-l 2.gif b/games/pacman/res/sprite/pacman-l 2.gif
deleted file mode 100644
index 93907ad..0000000
Binary files a/games/pacman/res/sprite/pacman-l 2.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-l 3.gif b/games/pacman/res/sprite/pacman-l 3.gif
deleted file mode 100644
index 00d1fea..0000000
Binary files a/games/pacman/res/sprite/pacman-l 3.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-l 4.gif b/games/pacman/res/sprite/pacman-l 4.gif
deleted file mode 100644
index c687f08..0000000
Binary files a/games/pacman/res/sprite/pacman-l 4.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-l 5.gif b/games/pacman/res/sprite/pacman-l 5.gif
deleted file mode 100644
index b446def..0000000
Binary files a/games/pacman/res/sprite/pacman-l 5.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-l 6.gif b/games/pacman/res/sprite/pacman-l 6.gif
deleted file mode 100644
index c687f08..0000000
Binary files a/games/pacman/res/sprite/pacman-l 6.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-l 7.gif b/games/pacman/res/sprite/pacman-l 7.gif
deleted file mode 100644
index 00d1fea..0000000
Binary files a/games/pacman/res/sprite/pacman-l 7.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-l 8.gif b/games/pacman/res/sprite/pacman-l 8.gif
deleted file mode 100644
index 93907ad..0000000
Binary files a/games/pacman/res/sprite/pacman-l 8.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-r 1.gif b/games/pacman/res/sprite/pacman-r 1.gif
deleted file mode 100644
index 7719686..0000000
Binary files a/games/pacman/res/sprite/pacman-r 1.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-r 2.gif b/games/pacman/res/sprite/pacman-r 2.gif
deleted file mode 100644
index d99ef73..0000000
Binary files a/games/pacman/res/sprite/pacman-r 2.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-r 3.gif b/games/pacman/res/sprite/pacman-r 3.gif
deleted file mode 100644
index 6a0ab97..0000000
Binary files a/games/pacman/res/sprite/pacman-r 3.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-r 4.gif b/games/pacman/res/sprite/pacman-r 4.gif
deleted file mode 100644
index acbb20c..0000000
Binary files a/games/pacman/res/sprite/pacman-r 4.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-r 5.gif b/games/pacman/res/sprite/pacman-r 5.gif
deleted file mode 100644
index 1fe5419..0000000
Binary files a/games/pacman/res/sprite/pacman-r 5.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-r 6.gif b/games/pacman/res/sprite/pacman-r 6.gif
deleted file mode 100644
index acbb20c..0000000
Binary files a/games/pacman/res/sprite/pacman-r 6.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-r 7.gif b/games/pacman/res/sprite/pacman-r 7.gif
deleted file mode 100644
index 6a0ab97..0000000
Binary files a/games/pacman/res/sprite/pacman-r 7.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-r 8.gif b/games/pacman/res/sprite/pacman-r 8.gif
deleted file mode 100644
index d99ef73..0000000
Binary files a/games/pacman/res/sprite/pacman-r 8.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-u 1.gif b/games/pacman/res/sprite/pacman-u 1.gif
deleted file mode 100644
index 01ef0a3..0000000
Binary files a/games/pacman/res/sprite/pacman-u 1.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-u 2.gif b/games/pacman/res/sprite/pacman-u 2.gif
deleted file mode 100644
index bceebda..0000000
Binary files a/games/pacman/res/sprite/pacman-u 2.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-u 3.gif b/games/pacman/res/sprite/pacman-u 3.gif
deleted file mode 100644
index 77f41cc..0000000
Binary files a/games/pacman/res/sprite/pacman-u 3.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-u 4.gif b/games/pacman/res/sprite/pacman-u 4.gif
deleted file mode 100644
index d67a385..0000000
Binary files a/games/pacman/res/sprite/pacman-u 4.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-u 5.gif b/games/pacman/res/sprite/pacman-u 5.gif
deleted file mode 100644
index d4698b0..0000000
Binary files a/games/pacman/res/sprite/pacman-u 5.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-u 6.gif b/games/pacman/res/sprite/pacman-u 6.gif
deleted file mode 100644
index d67a385..0000000
Binary files a/games/pacman/res/sprite/pacman-u 6.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-u 7.gif b/games/pacman/res/sprite/pacman-u 7.gif
deleted file mode 100644
index 77f41cc..0000000
Binary files a/games/pacman/res/sprite/pacman-u 7.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman-u 8.gif b/games/pacman/res/sprite/pacman-u 8.gif
deleted file mode 100644
index bceebda..0000000
Binary files a/games/pacman/res/sprite/pacman-u 8.gif and /dev/null differ
diff --git a/games/pacman/res/sprite/pacman.gif b/games/pacman/res/sprite/pacman.gif
deleted file mode 100644
index a584c10..0000000
Binary files a/games/pacman/res/sprite/pacman.gif and /dev/null differ
diff --git a/games/pacman/res/text/0.gif b/games/pacman/res/text/0.gif
deleted file mode 100644
index f01b653..0000000
Binary files a/games/pacman/res/text/0.gif and /dev/null differ
diff --git a/games/pacman/res/text/1.gif b/games/pacman/res/text/1.gif
deleted file mode 100644
index 7349994..0000000
Binary files a/games/pacman/res/text/1.gif and /dev/null differ
diff --git a/games/pacman/res/text/2.gif b/games/pacman/res/text/2.gif
deleted file mode 100644
index 3254d6f..0000000
Binary files a/games/pacman/res/text/2.gif and /dev/null differ
diff --git a/games/pacman/res/text/3.gif b/games/pacman/res/text/3.gif
deleted file mode 100644
index c88635d..0000000
Binary files a/games/pacman/res/text/3.gif and /dev/null differ
diff --git a/games/pacman/res/text/4.gif b/games/pacman/res/text/4.gif
deleted file mode 100644
index f3b5c3b..0000000
Binary files a/games/pacman/res/text/4.gif and /dev/null differ
diff --git a/games/pacman/res/text/5.gif b/games/pacman/res/text/5.gif
deleted file mode 100644
index dae0fd7..0000000
Binary files a/games/pacman/res/text/5.gif and /dev/null differ
diff --git a/games/pacman/res/text/6.gif b/games/pacman/res/text/6.gif
deleted file mode 100644
index dae7821..0000000
Binary files a/games/pacman/res/text/6.gif and /dev/null differ
diff --git a/games/pacman/res/text/7.gif b/games/pacman/res/text/7.gif
deleted file mode 100644
index dda359b..0000000
Binary files a/games/pacman/res/text/7.gif and /dev/null differ
diff --git a/games/pacman/res/text/8.gif b/games/pacman/res/text/8.gif
deleted file mode 100644
index 01305d4..0000000
Binary files a/games/pacman/res/text/8.gif and /dev/null differ
diff --git a/games/pacman/res/text/9.gif b/games/pacman/res/text/9.gif
deleted file mode 100644
index b29bb19..0000000
Binary files a/games/pacman/res/text/9.gif and /dev/null differ
diff --git a/games/pacman/res/text/gameover.gif b/games/pacman/res/text/gameover.gif
deleted file mode 100644
index e854b89..0000000
Binary files a/games/pacman/res/text/gameover.gif and /dev/null differ
diff --git a/games/pacman/res/text/life.gif b/games/pacman/res/text/life.gif
deleted file mode 100644
index 0e8f1bf..0000000
Binary files a/games/pacman/res/text/life.gif and /dev/null differ
diff --git a/games/pacman/res/text/logo.gif b/games/pacman/res/text/logo.gif
deleted file mode 100644
index 1cd71a7..0000000
Binary files a/games/pacman/res/text/logo.gif and /dev/null differ
diff --git a/games/pacman/res/text/ready.gif b/games/pacman/res/text/ready.gif
deleted file mode 100644
index 0cdcd89..0000000
Binary files a/games/pacman/res/text/ready.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/blank.gif b/games/pacman/res/tiles/blank.gif
deleted file mode 100644
index ae631b0..0000000
Binary files a/games/pacman/res/tiles/blank.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/door-h.gif b/games/pacman/res/tiles/door-h.gif
deleted file mode 100644
index 49687f5..0000000
Binary files a/games/pacman/res/tiles/door-h.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/door-v.gif b/games/pacman/res/tiles/door-v.gif
deleted file mode 100644
index 2e7568d..0000000
Binary files a/games/pacman/res/tiles/door-v.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/ghost-blinky.gif b/games/pacman/res/tiles/ghost-blinky.gif
deleted file mode 100644
index af02492..0000000
Binary files a/games/pacman/res/tiles/ghost-blinky.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/ghost-door.gif b/games/pacman/res/tiles/ghost-door.gif
deleted file mode 100644
index cffd09a..0000000
Binary files a/games/pacman/res/tiles/ghost-door.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/ghost-inky.gif b/games/pacman/res/tiles/ghost-inky.gif
deleted file mode 100644
index 4753970..0000000
Binary files a/games/pacman/res/tiles/ghost-inky.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/ghost-pinky.gif b/games/pacman/res/tiles/ghost-pinky.gif
deleted file mode 100644
index 6fd82ec..0000000
Binary files a/games/pacman/res/tiles/ghost-pinky.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/ghost-sue.gif b/games/pacman/res/tiles/ghost-sue.gif
deleted file mode 100644
index 14b057d..0000000
Binary files a/games/pacman/res/tiles/ghost-sue.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/glasses.gif b/games/pacman/res/tiles/glasses.gif
deleted file mode 100644
index f17ba54..0000000
Binary files a/games/pacman/res/tiles/glasses.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/hiscores.gif b/games/pacman/res/tiles/hiscores.gif
deleted file mode 100644
index c504d3c..0000000
Binary files a/games/pacman/res/tiles/hiscores.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/pellet-power.gif b/games/pacman/res/tiles/pellet-power.gif
deleted file mode 100644
index 806f7f4..0000000
Binary files a/games/pacman/res/tiles/pellet-power.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/pellet.gif b/games/pacman/res/tiles/pellet.gif
deleted file mode 100644
index 5284dd8..0000000
Binary files a/games/pacman/res/tiles/pellet.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/showlogo.gif b/games/pacman/res/tiles/showlogo.gif
deleted file mode 100644
index 35abd50..0000000
Binary files a/games/pacman/res/tiles/showlogo.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/start.gif b/games/pacman/res/tiles/start.gif
deleted file mode 100644
index 8b0fafe..0000000
Binary files a/games/pacman/res/tiles/start.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/wall-corner-ll.gif b/games/pacman/res/tiles/wall-corner-ll.gif
deleted file mode 100644
index 86b0398..0000000
Binary files a/games/pacman/res/tiles/wall-corner-ll.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/wall-corner-lr.gif b/games/pacman/res/tiles/wall-corner-lr.gif
deleted file mode 100644
index c43af41..0000000
Binary files a/games/pacman/res/tiles/wall-corner-lr.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/wall-corner-ul.gif b/games/pacman/res/tiles/wall-corner-ul.gif
deleted file mode 100644
index 5acadaa..0000000
Binary files a/games/pacman/res/tiles/wall-corner-ul.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/wall-corner-ur.gif b/games/pacman/res/tiles/wall-corner-ur.gif
deleted file mode 100644
index be16253..0000000
Binary files a/games/pacman/res/tiles/wall-corner-ur.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/wall-end-b.gif b/games/pacman/res/tiles/wall-end-b.gif
deleted file mode 100644
index 9041b06..0000000
Binary files a/games/pacman/res/tiles/wall-end-b.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/wall-end-l.gif b/games/pacman/res/tiles/wall-end-l.gif
deleted file mode 100644
index 2ed728a..0000000
Binary files a/games/pacman/res/tiles/wall-end-l.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/wall-end-r.gif b/games/pacman/res/tiles/wall-end-r.gif
deleted file mode 100644
index 25c7848..0000000
Binary files a/games/pacman/res/tiles/wall-end-r.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/wall-end-t.gif b/games/pacman/res/tiles/wall-end-t.gif
deleted file mode 100644
index 2155e70..0000000
Binary files a/games/pacman/res/tiles/wall-end-t.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/wall-nub.gif b/games/pacman/res/tiles/wall-nub.gif
deleted file mode 100644
index 113941b..0000000
Binary files a/games/pacman/res/tiles/wall-nub.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/wall-straight-horiz.gif b/games/pacman/res/tiles/wall-straight-horiz.gif
deleted file mode 100644
index 6308eef..0000000
Binary files a/games/pacman/res/tiles/wall-straight-horiz.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/wall-straight-vert.gif b/games/pacman/res/tiles/wall-straight-vert.gif
deleted file mode 100644
index 6b7ddb7..0000000
Binary files a/games/pacman/res/tiles/wall-straight-vert.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/wall-t-bottom.gif b/games/pacman/res/tiles/wall-t-bottom.gif
deleted file mode 100644
index 10ac483..0000000
Binary files a/games/pacman/res/tiles/wall-t-bottom.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/wall-t-left.gif b/games/pacman/res/tiles/wall-t-left.gif
deleted file mode 100644
index 3006e2a..0000000
Binary files a/games/pacman/res/tiles/wall-t-left.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/wall-t-right.gif b/games/pacman/res/tiles/wall-t-right.gif
deleted file mode 100644
index 27bb644..0000000
Binary files a/games/pacman/res/tiles/wall-t-right.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/wall-t-top.gif b/games/pacman/res/tiles/wall-t-top.gif
deleted file mode 100644
index 11f0e1e..0000000
Binary files a/games/pacman/res/tiles/wall-t-top.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/wall-x.gif b/games/pacman/res/tiles/wall-x.gif
deleted file mode 100644
index 3ba8eaa..0000000
Binary files a/games/pacman/res/tiles/wall-x.gif and /dev/null differ
diff --git a/games/pacman/res/tiles/x-paintwall.gif b/games/pacman/res/tiles/x-paintwall.gif
deleted file mode 100644
index 78f60c4..0000000
Binary files a/games/pacman/res/tiles/x-paintwall.gif and /dev/null differ
diff --git a/games/pong/__pycache__/__init__.cpython-310.pyc b/games/pong/__pycache__/__init__.cpython-310.pyc
index e5567cc..8ff616f 100644
Binary files a/games/pong/__pycache__/__init__.cpython-310.pyc and b/games/pong/__pycache__/__init__.cpython-310.pyc differ
diff --git a/games/pong/__pycache__/run_supervised_cnn.cpython-310.pyc b/games/pong/__pycache__/run_supervised_cnn.cpython-310.pyc
index 4a9782b..4c71db8 100644
Binary files a/games/pong/__pycache__/run_supervised_cnn.cpython-310.pyc and b/games/pong/__pycache__/run_supervised_cnn.cpython-310.pyc differ
diff --git a/games/pong/__pycache__/run_supervised_gnn.cpython-310.pyc b/games/pong/__pycache__/run_supervised_gnn.cpython-310.pyc
index b861ab4..867d5e6 100644
Binary files a/games/pong/__pycache__/run_supervised_gnn.cpython-310.pyc and b/games/pong/__pycache__/run_supervised_gnn.cpython-310.pyc differ
diff --git a/games/pong/eval.py b/games/pong/eval.py
index 5714338..a145849 100644
--- a/games/pong/eval.py
+++ b/games/pong/eval.py
@@ -32,33 +32,32 @@ def evaluate_model_on_configs(model_path, env_configs, n_eval_episodes=10):
     return results
 
 if __name__ == "__main__":
-    num_envs = 4  # Number of parallel environments
+    # num_envs = 4  # Number of parallel environments
 
-    # Create a vectorized environment with DummyVecEnv
-    def make_env(rank, seed=0):
-        def _init():
-            env = PongEnvNew(render_mode='rgb_array', observation_type='pixel')
-            env.seed(seed + rank)
-            return env
-        return _init
+    # # Create a vectorized environment with DummyVecEnv
+    # def make_env(rank, seed=0):
+    #     def _init():
+    #         env = PongEnvNew(render_mode='rgb_array', observation_type='pixel')
+    #         env.seed(seed + rank)
+    #         return env
+    #     return _init
 
-    env = DummyVecEnv([make_env(i) for i in range(num_envs)])
+    # env = DummyVecEnv([make_env(i) for i in range(num_envs)])
 
     
 
     # Save the model
-    model.save("ppo_custom_env")
 
     # Define environment configurations for evaluation
     env_configs = [
-        {"render_mode": "rgb_array", "observation_type": "pixel", "paddle_width": 10, "ball_speed_x": 8, "ball_speed_y": 8},
-        {"render_mode": "rgb_array", "observation_type": "pixel", "paddle_width": 15, "ball_speed_x": 10, "ball_speed_y": 10},
-        {"render_mode": "rgb_array", "observation_type": "pixel", "paddle_width": 20, "ball_speed_x": 12, "ball_speed_y": 12},
-        {"render_mode": "rgb_array", "observation_type": "pixel", "paddle_width": 25, "ball_speed_x": 15, "ball_speed_y": 15}
+        {"render_mode": "human", "observation_type": "pixel", "paddle_width": 5, "ball_speed": 4},
+        {"render_mode": "human", "observation_type": "pixel", "paddle_width": 5, "ball_speed": 3},
+        {"render_mode": "human", "observation_type": "pixel", "paddle_width": 5, "ball_speed": 2},
+        {"render_mode": "human", "observation_type": "pixel", "paddle_width": 5, "ball_speed": 1}
     ]
 
     # Evaluate the model on different configurations
-    results = evaluate_model_on_configs("ppo_custom_env", env_configs)
+    results = evaluate_model_on_configs("ppo_pong_pixel", env_configs)
 
     for result in results:
         config = result["config"]
diff --git a/games/pong/pong_envs/__pycache__/__init__.cpython-310.pyc b/games/pong/pong_envs/__pycache__/__init__.cpython-310.pyc
index 77d606b..801035a 100644
Binary files a/games/pong/pong_envs/__pycache__/__init__.cpython-310.pyc and b/games/pong/pong_envs/__pycache__/__init__.cpython-310.pyc differ
diff --git a/games/pong/pong_envs/__pycache__/pong_env.cpython-310.pyc b/games/pong/pong_envs/__pycache__/pong_env.cpython-310.pyc
index 79ef559..5e7aee3 100644
Binary files a/games/pong/pong_envs/__pycache__/pong_env.cpython-310.pyc and b/games/pong/pong_envs/__pycache__/pong_env.cpython-310.pyc differ
diff --git a/games/pong/pong_envs/__pycache__/pong_env_new.cpython-310.pyc b/games/pong/pong_envs/__pycache__/pong_env_new.cpython-310.pyc
index cf8f660..7921221 100644
Binary files a/games/pong/pong_envs/__pycache__/pong_env_new.cpython-310.pyc and b/games/pong/pong_envs/__pycache__/pong_env_new.cpython-310.pyc differ
diff --git a/games/pong/pong_envs/pong_env.py b/games/pong/pong_envs/pong_env.py
index 2ce3468..57a94dc 100644
--- a/games/pong/pong_envs/pong_env.py
+++ b/games/pong/pong_envs/pong_env.py
@@ -1,18 +1,20 @@
 import gymnasium as gym
 from gymnasium import spaces
+from matplotlib import pyplot as plt
 import pygame
 import numpy as np
 import random
-import torch
-from torch_geometric.data import Data
-import stable_baselines3.common.env_checker
+from skimage.color import rgb2gray
 from skimage.transform import resize
+from collections import deque
+import torch
+from stable_baselines3 import PPO
 
 class PongEnvNew(gym.Env):
-    metadata = {"render_modes": ["human", "rgb_array"], "render_fps": 60, "observation_types": ["pixel", "graph"]}
+    metadata = {"render_modes": ["human", "rgb_array"], "render_fps": 60}
 
-    def __init__(self, render_mode='human', observation_type='pixel', paddle_width=5, paddle_height=20, ball_size=5, paddle_speed=5, frame_stack=4):
-        pygame.init()
+    def __init__(self, render_mode=None, observation_type='pixel', paddle_width=5, paddle_height=20, ball_size=5, paddle_speed=10, ai_paddle_speed=10, frame_stack=4, ai_reaction_delay=5, ball_speed = 4):
+        super(PongEnvNew, self).__init__()
         self.width = 210
         self.height = 160
         self.render_mode = render_mode
@@ -21,26 +23,22 @@ class PongEnvNew(gym.Env):
         self.paddle_height = paddle_height
         self.ball_size = ball_size
         self.paddle_speed = paddle_speed
-        self.frame_stack = frame_stack  # Number of frames to stack
+        self.ai_paddle_speed = ai_paddle_speed
+        self.frame_stack = frame_stack
+        self.ai_reaction_delay = ai_reaction_delay  # Number of frames to delay AI reaction
+        self.ai_delay_counter = 0  # Initialize delay counter
         self.action_space = spaces.Discrete(3)  # [Stay, Up, Down]
 
         if observation_type == "pixel":
-            self.observation_space = gym.spaces.Box(low=0, high=255, shape=(self.frame_stack, 84, 84), dtype=np.uint8)
+            self.observation_space = gym.spaces.Box(low=0, high=255, shape=(frame_stack, 84, 84), dtype=np.uint8)
         else:
-            # Define a generic observation space for graph data
-            self.observation_space = gym.spaces.Box(low=-np.inf, high=np.inf, shape=(3, 7), dtype=np.float32)  # Number of objects and feature length
+            self.observation_space = gym.spaces.Box(low=-np.inf, high=np.inf, shape=(3, 7), dtype=np.float32)
 
-        if self.render_mode == "human" or self.render_mode == "rgb_array":
-            self.screen = pygame.display.set_mode((self.width, self.height))
-            pygame.display.set_caption("Pong")
-        else:
-            self.screen = pygame.Surface((self.width, self.height))
-        
-        self.clock = pygame.time.Clock()
-        self.ai_reaction_time = 10  # milliseconds
-        self.np_random = None
-        self.frame_buffer = np.zeros((self.height, self.width, self.frame_stack), dtype=np.uint8)
-        self.proximity_threshold = 50
+        self.screen = None
+        self.offscreen_surface = None
+        self.clock = None
+        self.frame_buffer = deque(maxlen=frame_stack)
+        self.ball_speed = ball_speed
     
     def seed(self, seed=None):
         self.np_random, seed = gym.utils.seeding.np_random(seed)
@@ -48,69 +46,84 @@ class PongEnvNew(gym.Env):
     
     def reset(self, seed=None, options=None):
         super().reset(seed=seed, options=options)
-        if not pygame.display.get_init():
-            pygame.display.init()
-            self.screen = pygame.display.set_mode((self.width, self.height))
         if seed is not None:
-            self.seed(seed)  # Seed the RNG for the environment
+            self.seed(seed)
         self.ball = pygame.Rect(self.width // 2 - self.ball_size // 2, self.height // 2 - self.ball_size // 2, self.ball_size, self.ball_size)
         self.left_paddle = pygame.Rect(20, self.height // 2 - self.paddle_height // 2, self.paddle_width, self.paddle_height)
         self.right_paddle = pygame.Rect(self.width - 20 - self.paddle_width, self.height // 2 - self.paddle_height // 2, self.paddle_width, self.paddle_height)
-        self.ai_last_reaction_time = pygame.time.get_ticks()
-        self.ball_speed_x, self.ball_speed_y = 2 * random.choice((1, -1)), 2 * random.choice((1, -1))
+        
+        angle = random.uniform(-np.pi / 4, np.pi / 4)
+        speed = 4
+        self.ball_speed_x = speed * np.cos(angle) * random.choice([1, -1])
+        self.ball_speed_y = speed * np.sin(angle) * random.choice([1, -1])
+        
         self.left_player_score = 0
         self.right_player_score = 0
-        self.frame_buffer = np.zeros((self.height, self.width, self.frame_stack), dtype=np.uint8)
-        
-        # Fill the frame buffer with the initial frame
+        self.frame_buffer.clear()
+        self.ai_delay_counter = 0  # Reset the AI delay counter
         if self.observation_type == "pixel":
+            obs = self._get_obs()
             for _ in range(self.frame_stack):
-                self._get_observation()
+                self.frame_buffer.append(obs)
+            return np.array(self.frame_buffer),{}
         else:
-            return self.get_graph_data(), {}
+            return self.get_graph_data(),{}
 
-        return self._get_observation(), {}
-
-    def render(self):
-        if not self.render_mode in ['human', 'rgb_array']:
-            # If not in a mode that requires rendering, skip the rendering.
-            return None
-        if not pygame.display.get_init():
-            # Reinitialize display if needed
-            pygame.display.init()
-            self.screen = pygame.display.set_mode((self.width, self.height))
-        try:
-            self.screen.fill((0, 0, 0))
-            pygame.draw.rect(self.screen, (255, 255, 255), self.left_paddle)
-            pygame.draw.rect(self.screen, (255, 255, 255), self.right_paddle)
-            pygame.draw.ellipse(self.screen, (255, 255, 255), self.ball)
-
-            if self.render_mode == "human":
-                pygame.display.flip()
-            elif self.render_mode == "rgb_array":
-                return np.array(pygame.surfarray.pixels3d(self.screen))
-        except pygame.error as e:
-            print("Pygame error:", e)
-            return None
+    def step(self, action):
+        self.ai_move()
+        self._apply_action(action)
+        reward, done = self._update_game_state()
 
-    def _get_observation(self):
+        
+        info = {}
+        truncated = False
         if self.observation_type == "pixel":
-            self.render()
-            frame = pygame.surfarray.array3d(pygame.display.get_surface())
-            frame = np.transpose(frame, (1, 0, 2))  # Transpose to match (height, width, channels)
-            grayscale = np.dot(frame[..., :3], [0.2989, 0.5870, 0.1140]).astype(np.uint8)  # Convert to grayscale
-            self.frame_buffer = np.roll(self.frame_buffer, shift=-1, axis=2)
-            self.frame_buffer[:, :, -1] = grayscale  # Update the last frame
+            obs = self._get_obs()
+            self.frame_buffer.append(obs)
+            return np.array(self.frame_buffer), reward, done, truncated, info
+        else:
+            return self.get_graph_data(), reward, done, truncated, info
+
+    def render(self, mode="human"):
+        if mode == "human":
+            if self.screen is None:
+                pygame.init()
+                self.screen = pygame.display.set_mode((self.width, self.height))
+                pygame.display.set_caption("Pong")
+                self.clock = pygame.time.Clock()
+            self._render_on_surface(self.screen)
+            pygame.display.flip()
+            self.clock.tick(60)
 
-            # Resize the frame buffer to 84x84 pixels
-            resized_frame_buffer = np.zeros((84, 84, self.frame_stack), dtype=np.uint8)
-            for i in range(self.frame_stack):
-                resized_frame_buffer[:, :, i] = resize(self.frame_buffer[:, :, i], (84, 84), anti_aliasing=True, preserve_range=True).astype(np.uint8)
+    def close(self):
+        pygame.quit()
 
-            # Convert to (batch_size, 4, 84, 84)
-            return resized_frame_buffer.transpose(2, 0, 1)
-        else:
-            return self.get_graph_data()
+    def _get_obs(self):
+        if self.offscreen_surface is None:
+            self.offscreen_surface = pygame.Surface((self.width, self.height))
+        self._render_on_surface(self.offscreen_surface)
+        frame = pygame.surfarray.array3d(self.offscreen_surface)
+        frame = np.transpose(frame, (1, 0, 2))  # Transpose to match (height, width, channels)
+        grayscale = rgb2gray(frame)  # Convert to grayscale
+        # Plot the grayscale frame
+    
+        # Convert to grayscale
+        grayscale = rgb2gray(frame)
+        
+        # Normalize the grayscale image to enhance contrast
+        normalized_frame = (grayscale - grayscale.min()) / (grayscale.max() - grayscale.min())
+        
+        # Resize the frame
+        resized_frame = resize(normalized_frame, (84, 84), anti_aliasing=True, mode='reflect', preserve_range=True)
+
+        
+        return resized_frame
+    
+    def _render_on_surface(self, surface):
+        surface.fill((0, 0, 0))
+        pygame.draw.rect(surface, (255, 255, 255), self.left_paddle)
+        pygame.draw.rect(surface, (255, 255, 255), self.right_paddle)
+        pygame.draw.ellipse(surface, (255, 255, 255), self.ball)
 
     def _apply_action(self, action):
         if action == 1 and self.left_paddle.top > 0:
@@ -119,191 +132,101 @@ class PongEnvNew(gym.Env):
             self.left_paddle.y += self.paddle_speed
 
     def ai_move(self):
-        current_time = pygame.time.get_ticks()
-        # AI paddle movement
-        if current_time - self.ai_last_reaction_time > self.ai_reaction_time:
+        if self.ai_delay_counter % self.ai_reaction_delay == 0:
             if self.ball.y < self.right_paddle.y + self.paddle_height / 2 and self.right_paddle.top > 0:
-                self.right_paddle.y -= self.paddle_speed
+                self.right_paddle.y -= self.ai_paddle_speed
             if self.ball.y > self.right_paddle.y + self.paddle_height / 2 and self.right_paddle.bottom < self.height:
-                self.right_paddle.y += self.paddle_speed
-            self.ai_last_reaction_time = current_time
+                self.right_paddle.y += self.ai_paddle_speed
+        self.ai_delay_counter += 1
 
     def _update_game_state(self):
-        # Existing game state update logic
+        reward = 0  # Initialize reward
+
+        # Update ball position
         self.ball.x += self.ball_speed_x
         self.ball.y += self.ball_speed_y
-        
-        # Check for collisions with top and bottom of the screen
-        if self.ball.top <= 0:
-            self.ball.top = 1  # Prevent sticking to the top wall
-            self.ball_speed_y *= -1
-        elif self.ball.bottom >= self.height:
-            self.ball.bottom = self.height - 1  # Prevent sticking to the bottom wall
+
+        # Ball collision with walls
+        if self.ball.y <= 0 or self.ball.y >= self.height - self.ball_size:
             self.ball_speed_y *= -1
-        
-        # AI paddle move
-        self.ai_move()
-        
-        # Check for collisions with paddles
-        collision = False
-        if self.ball.colliderect(self.left_paddle) or self.ball.colliderect(self.right_paddle):
-            collision = True
-            paddle = self.left_paddle if self.ball.colliderect(self.left_paddle) else self.right_paddle
-            
-            # Calculate the difference between the center of the paddle and the ball's y position
-            paddle_center_y = paddle.y + paddle.height / 2
-            difference = self.ball.centery - paddle_center_y
-            
-            # Normalize the difference to a reasonable range, e.g., between -1 and 1
-            normalized_difference = difference / (paddle.height / 2)
-            
-            # Reflect the ball's horizontal speed
-            self.ball_speed_x *= -1
-            
-            # Adjust the ball's vertical speed based on the difference, ensuring the speed remains constant
-            angle = normalized_difference * np.pi / 4  # Adjust the angle as needed
-            speed = np.sqrt(self.ball_speed_x**2 + self.ball_speed_y**2)
-            self.ball_speed_y = speed * np.sin(angle)
-            self.ball_speed_x = np.sign(self.ball_speed_x) * speed * np.cos(angle)
-            
-            # Ensure the ball's speed is within a reasonable range
-            max_speed = 10
-            self.ball_speed_y = max(-max_speed, min(max_speed, self.ball_speed_y))
-            
-            # Adjust the ball's position to prevent sticking
-            if paddle == self.left_paddle:
-                self.ball.left = self.left_paddle.right  # Place the ball right outside the left paddle
-            else:
-                self.ball.right = self.right_paddle.left  # Place the ball right outside the right paddle
 
-        # Check for scoring
-        score = 0
+        # Ball collision with paddles
+        if self.ball.colliderect(self.right_paddle):
+            if self.ball_speed_x > 0:  # Ensure collision only from left side of right paddle
+                self.ball_speed_x *= -1
+                hit_pos = (self.ball.centery - self.right_paddle.centery) / (self.paddle_height / 2)
+                self.ball_speed_y = hit_pos * abs(self.ball_speed_x)  # Simple deflection logic
+                reward = 0.5  # Reward for hitting the paddle
+                # Move the ball out of the paddle's collision box
+                self.ball.right = self.right_paddle.left - 1
+
+        if self.ball.colliderect(self.left_paddle):
+            if self.ball_speed_x < 0:  # Ensure collision only from right side of left paddle
+                self.ball_speed_x *= -1
+                hit_pos = (self.ball.centery - self.left_paddle.centery) / (self.paddle_height / 2)
+                self.ball_speed_y = hit_pos * abs(self.ball_speed_x)  # Simple deflection logic
+                reward = 0.5  # Reward for hitting the paddle
+                # Move the ball out of the paddle's collision box
+                self.ball.left = self.left_paddle.right + 1
+
+        # Check if the ball goes out of bounds
+        done = False
         if self.ball.left <= 0:
-            self.right_player_score += 1
-            score = -1  # Negative reward for the agent 
             self.ball_reset()
+            self.right_player_score += 1
+            reward = -10  # More significant negative reward for losing the ball
         elif self.ball.right >= self.width:
-            self.left_player_score += 1
-            score = 1  # Positive reward for the agent
             self.ball_reset()
-
-        return collision, score
-
-
-    def ball_reset(self):
-        self.ball.x, self.ball.y = self.width // 2 - self.ball_size // 2, self.height // 2 - self.ball_size // 2
-        self.ball_speed_x, self.ball_speed_y = 2 * random.choice((1, -1)), 2 * random.choice((1, -1))
-
-    def step(self, action):
-        if not pygame.display.get_init():
-            pygame.display.init()
-            self.screen = pygame.display.set_mode((self.width, self.height))
-        for event in pygame.event.get():
-            if event.type == pygame.QUIT:
-                pygame.display.quit()
-                pygame.quit()
-                raise SystemExit("Pygame QUIT event received.")
-        
-        self._apply_action(action)
-        collision, score = self._update_game_state()
-        observation = self._get_observation()
-
-        # Initialize reward
-        reward = 0
-
-        # Handle collision reward
-        if collision:
-            reward = 0.5  # Reward for hitting the ball
-        
-        # Handle scoring reward
-        if score != 0:
-            reward = score*2  # Reward for scoring (1 or -1)
-        
-        # Check if the game is done
+            self.left_player_score += 1
+            reward = 10  # More significant positive reward for scoring
         done = self._check_done()
-        if done:
-            if self.left_player_score >= 20:
-                reward = 10  # Positive reward for winning
-            elif self.right_player_score >= 20:
-                reward = -10  # Negative reward for losing
+        # Ensure the ball's speed remains constant
+        speed = np.sqrt(self.ball_speed_x**2 + self.ball_speed_y**2)
+        constant_speed = 4  # Set the desired constant speed
+        self.ball_speed_x = (self.ball_speed_x / speed) * constant_speed
+        self.ball_speed_y = (self.ball_speed_y / speed) * constant_speed
 
-        info = {}
-        truncated = False
+        return reward, done
 
-        return observation, reward, done, truncated, info
+    def ball_reset(self):
+        self.ball.x = self.width // 2 - self.ball_size // 2
+        self.ball.y = self.height // 2 - self.ball_size // 2
+        # Ensure the angle is not too close to 0 or 90 degrees
+        angle = random.uniform(-np.pi / 4, np.pi / 4)  # Random angle between -45 and 45 degrees
+        self.ball_speed_x = self.ball_speed * np.cos(angle) * random.choice([1, -1])
+        self.ball_speed_y = self.ball_speed * np.sin(angle) * random.choice([1, -1])
 
     def get_graph_data(self):
-        # Define the features for each object in the environment
         objects = {
             "ball": [self.ball.x, self.ball.y, self.ball_speed_x, self.ball_speed_y, 1, 0, 0],
             "left_paddle": [self.left_paddle.x, self.left_paddle.y, 0, 0, 0, 1, 0],
             "right_paddle": [self.right_paddle.x, self.right_paddle.y, 0, 0, 0, 1, 0],
-            # "top_wall": [0, 0, 0, 0, 0, 0, 1],
-            # "bottom_wall": [0, self.height, 0, 0, 0, 0, 1]
         }
 
-        # Convert the object features to a tensor
         node_features = [features for features in objects.values()]
         x = torch.tensor(node_features, dtype=torch.float32)
+        x = x.cpu().numpy()
 
         return x 
 
     def _check_done(self):
-        # Define the conditions under which the game is considered done
-        if self.left_player_score >= 20 or self.right_player_score >= 20:
+        if self.left_player_score >= 10 or self.right_player_score >= 10:
             return True
         return False
 
-    def close(self):
-        pygame.display.quit()
-        pygame.quit()
-
-# if __name__ == "__main__":
-#     env = PongEnvNew(render_mode='human', observation_type='pixel')
-    
-#     env.reset()
-
-#     num_episodes = 100
-#     for i_episode in range(num_episodes):
-#         done = False
-#         try:
-#             while not done:
-#                 action = env.action_space.sample()
-#                 _, _, done, _, _ = env.step(action)
-#                 env.render()
-#                 pygame.time.wait(10)
-#         finally:
-#             env.close()
-
-from stable_baselines3 import PPO
-
 if __name__ == "__main__":
-    # #env = PongEnvNew(render_mode='human', observation_type='pixel')
-    # env = PongEnvNew(render_mode='human', observation_type='pixel')
-    # #model = PPO.load("ppo_pong_custom_cnn")
-    # model = PPO.load("ppo_custom_env")
-    # num_episodes = 100
-
-    # for i_episode in range(num_episodes):
-    #     done = False
-    #     obs, _ = env.reset()  # Reset the environment at the start of each episode
-    #     try:
-    #         while not done:
-    #             action, _ = model.predict(obs)
-    #             obs, _, done, _, _ = env.step(action)
-    #             env.render()
-    #             pygame.time.wait(10)
-    #     except Exception as e:
-    #         print(f"An error occurred: {e}")
-    #         break
-    #     finally:
-    #         env.close()
-    # Create a single instance of the environment for evaluation
-    eval_env = PongEnvNew(render_mode='human', observation_type='pixel')
-    model = PPO.load("ppo_custom_env")
-    # Evaluate the policy
-    from stable_baselines3.common.evaluation import evaluate_policy
-    mean_reward, std_reward = evaluate_policy(model, eval_env, n_eval_episodes=10)
-
-    print(f"Mean reward: {mean_reward}  {std_reward}")
-
+    env = PongEnvNew(render_mode='human', observation_type='graph')
+    obs, _ = env.reset()
+    print(f"Observation shape: {obs.shape}")
+    total_reward = 0
+    done = False
+    model = PPO.load("ppo_custom_heterognn")
+    obs, _ = env.reset()
+    while not done:
+        action,_ = model.predict(obs)
+        #action = env.action_space.sample()
+        obs, reward, done, _, _ = env.step(action)
+        print(f"Action: {action}, Reward: {reward}")
+        total_reward += reward
+        env.render()
+    print(f"Total reward: {total_reward}")
diff --git a/games/pong/run_supervised_cnn.py b/games/pong/run_supervised_cnn.py
index cd73ff9..64606ea 100644
--- a/games/pong/run_supervised_cnn.py
+++ b/games/pong/run_supervised_cnn.py
@@ -1,77 +1,113 @@
+import os
+import numpy as np
 import torch as th
 import torch.nn as nn
 from gymnasium import spaces
 from stable_baselines3 import PPO
 from stable_baselines3.common.torch_layers import BaseFeaturesExtractor
-from stable_baselines3.common.vec_env import DummyVecEnv
-from games.pong.pong_envs.pong_env import PongEnvNew
+from stable_baselines3.common.vec_env import DummyVecEnv, SubprocVecEnv
 from stable_baselines3.common.env_util import make_vec_env
-from stable_baselines3.common.vec_env import VecFrameStack
+from stable_baselines3.common.monitor import Monitor
+from stable_baselines3.common.callbacks import BaseCallback, EvalCallback
+from stable_baselines3.common.monitor import load_results
+from stable_baselines3.common.results_plotter import ts2xy
+from wandb.integration.sb3 import WandbCallback
+from gymnasium.wrappers.time_limit import TimeLimit
+from games.pong.pong_envs.pong_env import PongEnvNew
+from collections import OrderedDict
+import wandb
+from stable_baselines3.common.utils import get_schedule_fn
 
-class CustomCNN(BaseFeaturesExtractor):
-    """
-    :param observation_space: (gym.Space)
-    :param features_dim: (int) Number of features extracted.
-    This corresponds to the number of units for the last layer.
-    """
 
-    def __init__(self, observation_space: spaces.Box, features_dim: int = 128):
-        super().__init__(observation_space, features_dim)
-        n_input_channels = observation_space.shape[0]
-        print(f"n_input_channels: {n_input_channels}")
-        self.cnn = nn.Sequential(
-            nn.Conv2d(n_input_channels, 32, kernel_size=8, stride=4, padding=0),
-            nn.ReLU(),
-            nn.Conv2d(32, 64, kernel_size=4, stride=2, padding=0),
-            nn.ReLU(),
-            nn.Conv2d(64, 128, kernel_size=3, stride=1, padding=0),
-            nn.ReLU(),
-            nn.Flatten(),
-        )
+class SaveOnBestTrainingRewardCallback(BaseCallback):
+    def __init__(self, check_freq, log_dir, verbose=1):
+        super(SaveOnBestTrainingRewardCallback, self).__init__(verbose)
+        self.check_freq = check_freq
+        self.log_dir = log_dir
+        self.save_path = os.path.join(log_dir, "best_model")
+        self.best_mean_reward = -np.inf
 
-        # Compute shape by doing one forward pass
-        with th.no_grad():
-            sample_input = th.as_tensor(observation_space.sample()[None]).float() 
-            n_flatten = self.cnn(sample_input).view(-1).shape[0]
+    def _init_callback(self) -> None:
+        if self.save_path is not None:
+            os.makedirs(self.save_path, exist_ok=True)
 
-        self.linear = nn.Sequential(
-            nn.Linear(n_flatten, features_dim),
-            nn.ReLU()
-        )
+    def _on_step(self) -> bool:
+        if self.n_calls % self.check_freq == 0:
+            x, y = ts2xy(load_results(self.log_dir), "timesteps")
+            if len(x) > 0:
+                mean_reward = np.mean(y[-100:])
+                if self.verbose > 0:
+                    print(f"Num timesteps: {self.num_timesteps}")
+                    print(f"Best mean reward: {self.best_mean_reward:.2f} - Last mean reward per episode: {mean_reward:.2f}")
+                if mean_reward > self.best_mean_reward:
+                    self.best_mean_reward = mean_reward
+                    if self.verbose > 0:
+                        print(f"Saving new best model at {x[-1]} timesteps")
+                        print(f"Saving new best model to {self.save_path}.zip")
+                    self.model.save(self.save_path)
+            wandb.log({"mean_reward": mean_reward, "timesteps": self.num_timesteps})
+        return True
 
-    def forward(self, observations: th.Tensor) -> th.Tensor:
-        features = self.cnn(observations)
-        output = self.linear(features)
-        return output
 
-def make_env(rank, seed=0):
+def make_pong_env(rank, seed=0, config=None):
     def _init():
-        env = PongEnvNew(render_mode='rgb_array', observation_type='pixel')
+        env = PongEnvNew(**config)
+        env = TimeLimit(env, max_episode_steps=3000)  # Set a reasonable max_episode_steps
+        monitor_path = os.path.join(log_dir, f"monitor_{rank}.csv")
+        os.makedirs(log_dir, exist_ok=True)  # Create log directory if it doesn't exist
+        env = Monitor(env, filename=monitor_path, allow_early_resets=True)
         env.seed(seed + rank)
         return env
     return _init
 
-if __name__ == '__main__':
-    num_envs = 4  # Number of parallel environments
 
-    # Create a vectorized environment with DummyVecEnv
-    env = DummyVecEnv([make_env(i) for i in range(num_envs)])
-    env = VecFrameStack(env, n_stack=4)
+if __name__ == "__main__":
+    num_envs = 8  # Number of parallel environments
+
+    params = OrderedDict([
+        ('batch_size', 256),
+        ('clip_range', get_schedule_fn(0.1)),  # Linear schedule for clip range
+        ('ent_coef', 0.01),
+        ('learning_rate', get_schedule_fn(2.5e-4)),  # Linear schedule for learning rate
+        ('n_epochs', 4),
+        ('n_steps', 128),
+        ('vf_coef', 0.5),
+    ])
+    env_configs = [
+        {"render_mode": None, "observation_type": "pixel", "paddle_width": 5, "ball_speed": 4},
+        {"render_mode": None, "observation_type": "pixel", "paddle_width": 5, "ball_speed": 2},
+        {"render_mode": None, "observation_type": "pixel", "paddle_width": 2, "ball_speed": 4},
+        {"render_mode": None, "observation_type": "pixel", "paddle_width": 2, "ball_speed": 2},
+        {"render_mode": None, "observation_type": "pixel", "paddle_width": 2, "ball_speed": 4},
+        {"render_mode": None, "observation_type": "pixel", "paddle_width": 2, "ball_speed": 2},
+        {"render_mode": None, "observation_type": "pixel", "paddle_width": 5, "ball_speed": 2},
+        {"render_mode": None, "observation_type": "pixel", "paddle_width": 5, "ball_speed": 4}
+    ]
+    log_dir = "./logs/Pong-CNN-training/"
 
-    model = PPO("CnnPolicy", env, verbose=1)
-    model.learn(total_timesteps=10000)
+    # Create a vectorized environment with SubprocVecEnv
+    envs = SubprocVecEnv([make_pong_env(i, config=env_configs[i]) for i in range(num_envs)])
 
-    # Save the model
-    model.save("ppo_custom_env")
+    wandb.init(
+        project="cnn_atari_pong",  # Replace with your project name
+        sync_tensorboard=True,           # Automatically sync SB3 logs with wandb
+        monitor_gym=True,                # Automatically log gym environments
+        save_code=True                   # Save the code used for this run
+    )
+    env = PongEnvNew(observation_type="pixel", render_mode=None, paddle_width=5, ball_speed=2)
+    env = TimeLimit(env, max_episode_steps=3000)  # Set a reasonable max_episode_steps
+    env = Monitor(env, filename=log_dir, allow_early_resets=True)
+    eval_callback = EvalCallback(env, best_model_save_path='./logs/pong-CNN-eval',
+                                 log_path='./logs/pong-CNN-eval', eval_freq=5000,
+                                 deterministic=True, render=False)
 
-    # Load the model
-    model = PPO.load("ppo_custom_env")
+    device = "cuda" if th.cuda.is_available() else "cpu"
 
-    # Create a single instance of the environment for evaluation
-    eval_env = PongEnvNew(render_mode='human', observation_type='pixel')
+    model = PPO("CnnPolicy", envs, device=device, verbose=2)
 
-    # Evaluate the policy
-    from stable_baselines3.common.evaluation import evaluate_policy
-    mean_reward, std_reward = evaluate_policy(model, eval_env, n_eval_episodes=10)
+    # SaveOnBestTrainingRewardCallback
+    callback = SaveOnBestTrainingRewardCallback(check_freq=5000, log_dir=log_dir)
+    # wandb_callback = WandbCallback(model_save_path="./models/", model_save_freq=5000, verbose=2)
 
-    print(f"Mean reward: {mean_reward}  {std_reward}")
+    model.learn(total_timesteps=1000000, callback=[callback, eval_callback])
+    model.save("ppo_pong_pixel")
diff --git a/games/pong/run_supervised_gnn.py b/games/pong/run_supervised_gnn.py
index 534df35..f2470c3 100644
--- a/games/pong/run_supervised_gnn.py
+++ b/games/pong/run_supervised_gnn.py
@@ -1,44 +1,136 @@
-import wandb
+import os
+import numpy as np
+import torch as th
+import torch.nn as nn
+from gymnasium import spaces
 from stable_baselines3 import PPO
+from stable_baselines3.common.torch_layers import BaseFeaturesExtractor
+from stable_baselines3.common.vec_env import DummyVecEnv, SubprocVecEnv
 from stable_baselines3.common.env_util import make_vec_env
-from wandb.integration.sb3 import WandbCallback
 from stable_baselines3.common.monitor import Monitor
-#from games.model.policy import CustomActorCriticPolicy
-from games.pong.pong_envs.pong_env_new import PongEnvNew
-from games.model.policy import CustomCNN, CustomHeteroGNN
-import pygame
-#Initialize wandb
+from stable_baselines3.common.callbacks import BaseCallback, EvalCallback
+from stable_baselines3.common.monitor import load_results
+from stable_baselines3.common.results_plotter import ts2xy
+from wandb.integration.sb3 import WandbCallback
+from gymnasium.wrappers.time_limit import TimeLimit
+from games.pong.pong_envs.pong_env import PongEnvNew
+from collections import OrderedDict
+import wandb
+from stable_baselines3.common.utils import get_schedule_fn
+
+from games.model.policy import CustomHeteroGNN
+
+
+# Initialize wandb
 wandb.init(
     project="gnn_atari_pong",  # Replace with your project name
-    sync_tensorboard=True,        # Automatically sync SB3 logs with wandb
-    monitor_gym=True,             # Automatically log gym environments
-    save_code=True                # Save the code used for this run
+    sync_tensorboard=True,     # Automatically sync SB3 logs with wandb
+    monitor_gym=True,          # Automatically log gym environments
+    save_code=True             # Save the code used for this run
 )
 
+class SaveOnBestTrainingRewardCallback(BaseCallback):
+    def __init__(self, check_freq, log_dir, verbose=1):
+        super(SaveOnBestTrainingRewardCallback, self).__init__(verbose)
+        self.check_freq = check_freq
+        self.log_dir = log_dir
+        self.save_path = os.path.join(log_dir, "best_model")
+        self.best_mean_reward = -np.inf
 
+    def _init_callback(self) -> None:
+        if self.save_path is not None:
+            os.makedirs(self.save_path, exist_ok=True)
 
-env = PongEnvNew(render_mode='human', observation_type='graph', training=True)
-# policy_kwargs = dict(
-#     features_extractor_class=CustomCNN,
-#     features_extractor_kwargs=dict(features_dim=128),
-# )
+    def _on_step(self) -> bool:
+        if self.n_calls % self.check_freq == 0:
+            x, y = ts2xy(load_results(self.log_dir), "timesteps")
+            if len(x) > 0:
+                mean_reward = np.mean(y[-100:])
+                if self.verbose > 0:
+                    print(f"Num timesteps: {self.num_timesteps}")
+                    print(f"Best mean reward: {self.best_mean_reward:.2f} - Last mean reward per episode: {mean_reward:.2f}")
+                if mean_reward > self.best_mean_reward:
+                    self.best_mean_reward = mean_reward
+                    if self.verbose > 0:
+                        print(f"Saving new best model at {x[-1]} timesteps")
+                        print(f"Saving new best model to {self.save_path}.zip")
+                    self.model.save(self.save_path)
+            wandb.log({"mean_reward": mean_reward, "timesteps": self.num_timesteps})
+        return True
 
-policy_kwargs = dict(
-    features_extractor_class=CustomHeteroGNN,
-    features_extractor_kwargs=dict(
-        features_dim=64,
-        hidden_size=64,
-        num_layer=2,
-        obj_type_id='obj',
-        arity_dict={'atom': 2},
-        game  = 'pong'
-    ),
-)
 
-# # Create the PPO model with the custom feature extractor
-model = PPO('MlpPolicy', env, policy_kwargs=policy_kwargs, verbose=2, tensorboard_log="./logs")
-# # Train the model with WandbCallback
-model.learn(total_timesteps=1000000, callback=WandbCallback())
-# # Save the model
-model.save("ppo_custom_heterognn")
+def make_pong_env(rank, seed=0, config=None):
+    def _init():
+        env = PongEnvNew(**config)
+        env = TimeLimit(env, max_episode_steps=3000)  # Set a reasonable max_episode_steps
+        monitor_path = os.path.join(log_dir, f"monitor_{rank}.csv")
+        os.makedirs(log_dir, exist_ok=True)  # Create log directory if it doesn't exist
+        env = Monitor(env, filename=monitor_path, allow_early_resets=True)
+        env.seed(seed + rank)
+        return env
+    return _init
+
+if __name__ == "__main__":
+    params = OrderedDict([
+        ('batch_size', 256),
+        ('clip_range', 'lin_0.1'),
+        ('ent_coef', 0.01),
+        ('env_wrapper', []),  # No AtariWrapper for MlpPolicy
+        ('frame_stack', 4),
+        ('learning_rate', 'lin_2.5e-4'),
+        ('n_envs', 8),
+        ('n_epochs', 4),
+        ('n_steps', 128),
+        ('n_timesteps', 10000000.0),
+        ('policy', 'MlpPolicy'),
+        ('vf_coef', 0.5),
+        ('normalize', False)
+    ])
+
+    log_dir = "./logs/Pong-GNN-training/"
+    num_envs = params['n_envs']
+    env_configs = [
+        {"render_mode": None, "observation_type": "graph", "paddle_width": 5, "ball_speed": 4},
+        {"render_mode": None, "observation_type": "graph", "paddle_width": 5, "ball_speed": 2},
+        {"render_mode": None, "observation_type": "graph", "paddle_width": 2, "ball_speed": 4},
+        {"render_mode": None, "observation_type": "graph", "paddle_width": 2, "ball_speed": 2},
+        {"render_mode": None, "observation_type": "graph", "paddle_width": 2, "ball_speed": 4},
+        {"render_mode": None, "observation_type": "graph", "paddle_width": 2, "ball_speed": 2},
+        {"render_mode": None, "observation_type": "graph", "paddle_width": 5, "ball_speed": 2},
+        {"render_mode": None, "observation_type": "graph", "paddle_width": 5, "ball_speed": 4}
+    ]
+    num_envs = len(env_configs)
+
+    envs = SubprocVecEnv([make_pong_env(i, config=env_configs[i]) for i in range(num_envs)])
+    env = PongEnvNew(observation_type="graph", render_mode=None, paddle_width=5, ball_speed=2)
+    env = TimeLimit(env, max_episode_steps=3000)  # Set a reasonable max_episode_steps
+    env = Monitor(env, filename=log_dir, allow_early_resets=True)
+    eval_callback = EvalCallback(env, best_model_save_path='./logs/pong-GNN-eval',
+                                 log_path='./logs/pong-GNN-eval', eval_freq=5000,
+                                 deterministic=True, render=False)
+    # if params['normalize']:
+    #     envs = VecNormalize(envs, norm_reward=True)
+
+    policy_kwargs = dict(
+        features_extractor_class=CustomHeteroGNN,
+        features_extractor_kwargs=dict(
+            features_dim=64,
+            hidden_size=64,
+            num_layer=2,
+            obj_type_id='obj',
+            arity_dict={'atom': 2},
+            game='pong'
+        ),
+    )
+
+    
+    model = PPO("MlpPolicy", envs, verbose=1, policy_kwargs=policy_kwargs, device='cuda' if th.cuda.is_available() else 'cpu')
+
+    callback = SaveOnBestTrainingRewardCallback(check_freq=10000, log_dir=log_dir)
+    eval_callback = EvalCallback(env, best_model_save_path='./logs/pong-CNN-eval',
+                                 log_path='./logs/pong-CNN-eval', eval_freq=5000,
+                                 deterministic=True, render=False)
+    #wandb_callback = WandbCallback(model_save_path="./models/", model_save_freq=5000, verbose=2)
 
+    model.learn(total_timesteps=10000000, callback=[callback, eval_callback])
+    model.save("ppo_custom_heterognn_pong")
diff --git a/games/shoot/shoot_env.py b/games/shoot/shoot_env.py
index 4ef7c69..df01ef0 100644
--- a/games/shoot/shoot_env.py
+++ b/games/shoot/shoot_env.py
@@ -1,127 +1,224 @@
-import gym
-from gym import spaces
+import gymnasium as gym
+from gymnasium import spaces
 import pygame
-import random
 import numpy as np
-import time
-
-class ShootingEnv(gym.Env):
-    metadata = {"render_modes": ["human"], "render_fps": 60}
-
-    def __init__(self):
-        super(ShootingEnv, self).__init__()
-        pygame.init()
+import random
+from skimage.transform import resize
+from stable_baselines3 import PPO
+from collections import deque
+
+class PongEnvNew(gym.Env):
+    metadata = {"render_modes": ["human", "rgb_array"], "render_fps": 60, "observation_types": ["pixel", "graph"]}
+
+    def __init__(self, render_mode=None, observation_type='pixel', paddle_width=5, paddle_height=20, ball_size=5, paddle_speed=10, ai_paddle_speed=10, frame_stack=4):
+        super(PongEnvNew, self).__init__()
+        self.width = 210
+        self.height = 160
+        self.render_mode = render_mode
+        self.observation_type = observation_type
+        self.paddle_width = paddle_width
+        self.paddle_height = paddle_height
+        self.ball_size = ball_size
+        self.paddle_speed = paddle_speed
+        self.ai_paddle_speed = ai_paddle_speed  # AI paddle speed
+        self.frame_stack = frame_stack  # Number of frames to stack
+        self.action_space = spaces.Discrete(3)  # [Stay, Up, Down]
+
+        if observation_type == "pixel":
+            self.observation_space = gym.spaces.Box(low=0, high=255, shape=(self.frame_stack, 84, 84), dtype=np.uint8)
+        else:
+            # Define a generic observation space for graph data
+            self.observation_space = gym.spaces.Box(low=-np.inf, high=np.inf, shape=(3, 7), dtype=np.float32)  # Number of objects and feature length
+
+        self.screen = None  # Delay screen creation until rendering
+        self.clock = None
+        self.ai_reaction_time = 5  # milliseconds
+        self.frame_buffer = deque(maxlen=self.frame_stack)
+    
+    def seed(self, seed=None):
+        self.np_random, seed = gym.utils.seeding.np_random(seed)
+        return [seed]
+    
+    def reset(self, seed=None, options=None):
+        super().reset(seed=seed, options=options)
+        if seed is not None:
+            self.seed(seed)  # Seed the RNG for the environment
+        self.ball = pygame.Rect(self.width // 2 - self.ball_size // 2, self.height // 2 - self.ball_size // 2, self.ball_size, self.ball_size)
+        self.left_paddle = pygame.Rect(20, self.height // 2 - self.paddle_height // 2, self.paddle_width, self.paddle_height)
+        self.right_paddle = pygame.Rect(self.width - 20 - self.paddle_width, self.height // 2 - self.paddle_height // 2, self.paddle_width, self.paddle_height)
+        self.ai_last_reaction_time = pygame.time.get_ticks()
+        
+        # Set random speeds for the ball
+        angle = random.uniform(-np.pi / 4, np.pi / 4)  # Random angle between -45 and 45 degrees
+        speed = 2  # Constant speed
+        self.ball_speed_x = speed * np.cos(angle) * random.choice([1, -1])
+        self.ball_speed_y = speed * np.sin(angle) * random.choice([1, -1])
         
-        # Game window dimensions
-        self.WIDTH, self.HEIGHT = 800, 600
-        self.win = pygame.display.set_mode((self.WIDTH, self.HEIGHT))
-        pygame.display.set_caption("Shooting Game")
-
-        # Colors
-        self.WHITE = (255, 255, 255)
-        self.RED = (255, 0, 0)
-        self.BLACK = (0, 0, 0)
-
-        # Shooter settings
-        self.shooter_pos = [self.WIDTH // 2, self.HEIGHT - 50]
-        self.shooter_speed = 5
-
-        # Target settings
-        self.target_pos = [random.randint(20, self.WIDTH - 20), random.randint(20, self.HEIGHT // 2)]
-        self.target_speed = 2
-        self.target_direction = 1
-
-        # Bullet settings
-        self.bullet_pos = []
-        self.bullet_speed = 10
-
-        # Gym spaces
-        self.action_space = spaces.Discrete(2)  # 0: do nothing, 1: shoot bullet
-        self.observation_space = spaces.Box(low=0, high=255, shape=(self.HEIGHT, self.WIDTH, 3), dtype=np.uint8)
-
-        self.clock = pygame.time.Clock()
-
-    def reset(self):
-        self.shooter_pos = [self.WIDTH // 2, self.HEIGHT - 50]
-        self.target_pos = [random.randint(20, self.WIDTH - 20), random.randint(20, self.HEIGHT // 2)]
-        self.bullet_pos = []
-        self.target_direction = 1
-        return self._get_obs()
+        self.left_player_score = 0
+        self.right_player_score = 0
+        self.frame_buffer.clear()
+        
+        # Fill the frame buffer with the initial frame
+        if self.observation_type == "pixel":
+            obs = self._get_obs()
+            for _ in range(self.frame_stack):
+                self.frame_buffer.append(obs)
+            return np.array(self.frame_buffer), {}
+        else:
+            return self.get_graph_data(), {}
 
     def step(self, action):
+        if not pygame.display.get_init():
+            pygame.display.init()
+            self.screen = pygame.display.set_mode((self.width, self.height))
+        for event in pygame.event.get():
+            if event.type == pygame.QUIT:
+                pygame.display.quit()
+                pygame.quit()
+                raise SystemExit("Pygame QUIT event received.")
+        self.ai_move()
+        self._apply_action(action)
+        self._update_game_state()
+        
         reward = 0
         done = False
-        
-        # Shoot bullet if action is 1
-        if action == 1:
-            self._shoot_bullet()
-        
-        # Move target
-        self._move_target()
-        
-        # Move bullets
-        self._move_bullets()
-
-        # Check collision
-        reward, done = self._check_collision()
+        if self.ball.left <= 0 or self.ball.right >= self.width:
+            reward = 1 if self.ball.left <= 0 else -1
+            done = True
 
         obs = self._get_obs()
-        return obs, reward, done, {}
+        self.frame_buffer.append(obs)
+        info = {}
+        truncated = False
+
+        return np.array(self.frame_buffer), reward, done, truncated, info
 
     def render(self, mode="human"):
-        self.win.fill(self.BLACK)
-        pygame.draw.circle(self.win, self.RED, self.target_pos, 20)
-        pygame.draw.rect(self.win, self.WHITE, (*self.shooter_pos, 50, 20))
-        for bullet in self.bullet_pos:
-            pygame.draw.rect(self.win, self.WHITE, (*bullet, 10, 5))
-        pygame.display.update()
+        if mode == "human":
+            if self.screen is None:
+                pygame.init()
+                self.screen = pygame.display.set_mode((self.width, self.height))
+                pygame.display.set_caption("Pong")
+                self.clock = pygame.time.Clock()
+            self._render_on_surface(self.screen)
+            pygame.display.flip()
+            self.clock.tick(60)
 
     def close(self):
         pygame.quit()
 
     def _get_obs(self):
-        self.render()  # Render to the pygame display
-        obs = pygame.surfarray.array3d(pygame.display.get_surface())
-        return np.transpose(obs, (1, 0, 2))  # Transpose to match the shape (height, width, channels)
-
-    def _move_target(self):
-        self.target_pos[0] += self.target_speed * self.target_direction
-        if self.target_pos[0] >= self.WIDTH - 20 or self.target_pos[0] <= 20:
-            self.target_direction *= -1
-
-    def _shoot_bullet(self):
-        self.bullet_pos.append([self.shooter_pos[0] + 20, self.shooter_pos[1]])
-
-    def _move_bullets(self):
-        for bullet in self.bullet_pos[:]:
-            bullet[1] -= self.bullet_speed
-            if bullet[1] < 0:
-                self.bullet_pos.remove(bullet)
+        if self.render_mode == "rgb_array":
+            self._render_on_surface(self.offscreen_surface)
+            frame = pygame.surfarray.array3d(self.offscreen_surface)
+        else:
+            self._render_on_surface(self.screen)
+            frame = pygame.surfarray.array3d(self.screen)
+        
+        frame = np.transpose(frame, (1, 0, 2))  # Transpose to match (height, width, channels)
+        grayscale = np.dot(frame[..., :3], [0.2989, 0.5870, 0.1140]).astype(np.uint8)  # Convert to grayscale
+        resized_frame = resize(grayscale, (84, 84), anti_aliasing=True, preserve_range=True).astype(np.uint8)  # Resize and update the last frame
+        return resized_frame
+
+    def _render_on_surface(self, surface):
+        surface.fill((0, 0, 0))
+        pygame.draw.rect(surface, (255, 255, 255), self.left_paddle)
+        pygame.draw.rect(surface, (255, 255, 255), self.right_paddle)
+        pygame.draw.ellipse(surface, (255, 255, 255), self.ball)
+
+    def _apply_action(self, action):
+        if action == 1 and self.left_paddle.top > 0:
+            self.left_paddle.y -= self.paddle_speed
+        elif action == 2 and self.left_paddle.bottom < self.height:
+            self.left_paddle.y += self.paddle_speed
+
+    def ai_move(self):
+        current_time = pygame.time.get_ticks()
+        # AI paddle movement
+        if current_time - self.ai_last_reaction_time > self.ai_reaction_time:
+            if self.ball.y < self.right_paddle.y + self.paddle_height / 2 and self.right_paddle.top > 0:
+                self.right_paddle.y -= self.ai_paddle_speed
+            if self.ball.y > self.right_paddle.y + self.paddle_height / 2 and self.right_paddle.bottom < self.height:
+                self.right_paddle.y += self.ai_paddle_speed
+            self.ai_last_reaction_time = current_time
+
+    def _update_game_state(self):
+        self.ball.x += self.ball_speed_x
+        self.ball.y += self.ball_speed_y
+
+        # Check for collisions with top and bottom of the screen
+        if self.ball.top <= 0:
+            self.ball.top = 0
+            self.ball_speed_y *= -1
+        elif self.ball.bottom >= self.height:
+            self.ball.bottom = self.height
+            self.ball_speed_y *= -1
+
+        # Check if the ball goes out of bounds
+        if self.ball.left <= 0:
+            self.ball_reset()
+            self.right_player_score += 1
+        elif self.ball.right >= self.width:
+            self.ball_reset()
+            self.left_player_score += 1
+
+        # Check for paddle collisions
+        if (self.ball.x > self.right_paddle.left and self.ball.x < self.right_paddle.right and 
+            self.ball.y > self.right_paddle.top and self.ball.y < self.right_paddle.bottom):
+            self.ball.x = self.right_paddle.left - self.ball.width
+            angle = random.uniform(-np.pi / 4, np.pi / 4)  # Slight random angle variation
+            speed = np.hypot(self.ball_speed_x, self.ball_speed_y)  # Keep the speed constant
+            self.ball_speed_x = -speed * np.cos(angle)
+            self.ball_speed_y = speed * np.sin(angle)
+
+        if (self.ball.x < self.left_paddle.right and self.ball.x > self.left_paddle.left and 
+            self.ball.y > self.left_paddle.top and self.ball.y < self.left_paddle.bottom):
+            self.ball.x = self.left_paddle.right
+            angle = random.uniform(-np.pi / 4, np.pi / 4)  # Slight random angle variation
+            speed = np.hypot(self.ball_speed_x, self.ball_speed_y)  # Keep the speed constant
+            self.ball_speed_x = speed * np.cos(angle)
+            self.ball_speed_y = speed * np.sin(angle)
+
+    def ball_reset(self):
+        self.ball.x = self.width // 2 - self.ball_size // 2
+        self.ball.y = self.height // 2 - self.ball_size // 2
+        # Ensure the angle is not too close to 0 or 90 degrees
+        angle = random.uniform(np.pi / 6, np.pi / 3)  # Random angle between 30 and 60 degrees
+        speed = 2  # Constant speed
+        self.ball_speed_x = speed * np.cos(angle) * random.choice([1, -1])
+        self.ball_speed_y = speed * np.sin(angle) * random.choice([1, -1])
+
+    def get_graph_data(self):
+        objects = {
+            "ball": [self.ball.x, self.ball.y, self.ball_speed_x, self.ball_speed_y, 1, 0, 0],
+            "left_paddle": [self.left_paddle.x, self.left_paddle.y, 0, 0, 0, 1, 0],
+            "right_paddle": [self.right_paddle.x, self.right_paddle.y, 0, 0, 0, 1, 0],
+        }
+
+        node_features = [features for features in objects.values()]
+        x = torch.tensor(node_features, dtype=torch.float32)
+
+        return x 
+
+    def _check_done(self):
+        if self.left_player_score >= 20 or self.right_player_score >= 20:
+            return True
+        return False
 
-    def _check_collision(self):
-        reward = 0
-        done = False
-        for bullet in self.bullet_pos:
-            if self.target_pos[0] - 20 < bullet[0] < self.target_pos[0] + 20 and self.target_pos[1] - 20 < bullet[1] < self.target_pos[1] + 20:
-                self.shooter_pos = [self.WIDTH // 2, self.HEIGHT - 50]
-                self.target_pos = [random.randint(20, self.WIDTH - 20), random.randint(20, self.HEIGHT // 2)]
-                self.bullet_pos.remove(bullet)
-                reward = 1
-                done = True
-            else:
-                reward = 0
-        return reward, done
-
-# Example usage
 if __name__ == "__main__":
-    env = ShootingEnv()
-    obs = env.reset()
-
+    env = make_vec_env(lambda: PongEnvNew(render_mode=None, observation_type='pixel'), n_envs=4, vec_env_cls=SubprocVecEnv)
+    model = PPO('CnnPolicy', env, verbose=1)
+    model.learn(total_timesteps=100000)
+    model.save("ppo_custom_env_pixel")
+
+    # Test the trained model
+    env = PongEnvNew(render_mode='human', observation_type='pixel')
+    obs, _ = env.reset()
+    total_reward = 0
     done = False
     while not done:
-        action = env.action_space.sample()  # Random action for illustration
-        obs, reward, done, info = env.step(action)
-        time.sleep(0.1)
+        action, _ = model.predict(obs)
+        obs, reward, done, _, _ = env.step(action)
+        total_reward += reward
         env.render()
-
-    env.close()
+    print(f"Total reward: {total_reward}")
diff --git a/ppo_custom_cnn_pong.zip b/ppo_custom_cnn_pong.zip
deleted file mode 100644
index 6cfc7cf..0000000
Binary files a/ppo_custom_cnn_pong.zip and /dev/null differ
diff --git a/ppo_custom_env.zip b/ppo_custom_env.zip
deleted file mode 100644
index 80f3b33..0000000
Binary files a/ppo_custom_env.zip and /dev/null differ
diff --git a/ppo_custom_heterognn.zip b/ppo_custom_heterognn.zip
deleted file mode 100644
index c29e880..0000000
Binary files a/ppo_custom_heterognn.zip and /dev/null differ
diff --git a/ppo_custom_heterognn_new.zip b/ppo_custom_heterognn_new.zip
deleted file mode 100644
index af2e024..0000000
Binary files a/ppo_custom_heterognn_new.zip and /dev/null differ
diff --git a/ppo_freeway_pixel.zip b/ppo_freeway_pixel.zip
index 72cd310..0a68bc8 100644
Binary files a/ppo_freeway_pixel.zip and b/ppo_freeway_pixel.zip differ
diff --git a/wandb/debug-internal.log b/wandb/debug-internal.log
index a7e2754..cb91fea 120000
--- a/wandb/debug-internal.log
+++ b/wandb/debug-internal.log
@@ -1 +1 @@
-run-20240627_175509-kfssyjeq/logs/debug-internal.log
\ No newline at end of file
+run-20240712_030934-a0393trx/logs/debug-internal.log
\ No newline at end of file
diff --git a/wandb/debug.log b/wandb/debug.log
index 78950f7..eb48ad3 120000
--- a/wandb/debug.log
+++ b/wandb/debug.log
@@ -1 +1 @@
-run-20240627_175509-kfssyjeq/logs/debug.log
\ No newline at end of file
+run-20240712_030934-a0393trx/logs/debug.log
\ No newline at end of file
diff --git a/wandb/latest-run b/wandb/latest-run
index 847fe7f..e2bc567 120000
--- a/wandb/latest-run
+++ b/wandb/latest-run
@@ -1 +1 @@
-run-20240627_175509-kfssyjeq
\ No newline at end of file
+run-20240712_030934-a0393trx
\ No newline at end of file
