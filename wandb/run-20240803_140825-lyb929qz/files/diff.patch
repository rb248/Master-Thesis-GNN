diff --git a/games/encoder/GraphEncoder.py b/games/encoder/GraphEncoder.py
index a0dbe69..ab0fdac 100644
--- a/games/encoder/GraphEncoder.py
+++ b/games/encoder/GraphEncoder.py
@@ -6,6 +6,7 @@ from itertools import combinations, product
 import os
 import matplotlib.pyplot as plt
 from typing import List
+import numpy as np
 
 class HeteroGNNEncoderPong:
     def __init__(self, obj_type_id: str = "obj", atom_type_id: str = "atom"):
@@ -399,13 +400,33 @@ class HeteroGNNEncoderPongProximity:
 
 #         return data_list
 
+def visualize_graph(graph: nx.Graph):
+        pos = nx.spring_layout(graph)
+        plt.figure(figsize=(12, 8))
+        node_labels = {node: f"{node}\n{attrs['type']}" for node, attrs in graph.nodes(data=True)}
+        #edge_labels = {(src, dst): f"{attrs['position']}" for src, dst, attrs in graph.edges(data=True)}
+
+        nx.draw(graph, pos, with_labels=True, labels=node_labels, node_size=500, node_color='lightblue', font_size=10)
+        #nx.draw_networkx_edge_labels(graph, pos, edge_labels=edge_labels, font_color='red')
+
+        plt.show()
+
+def print_graph_details(graph: nx.Graph):
+    print("Nodes:")
+    for node, attrs in graph.nodes(data=True):
+        print(f"  Node {node}: Type: {attrs['type']}, Features: {attrs['features']}")
+    
+    print("Edges:")
+    for src, dst, attrs in graph.edges(data=True):
+        print(f"Edge from {src} to {dst}")
 class GraphEncoderFreeway:
-    def __init__(self, obj_type_id: str = "obj"):
+    def __init__(self, obj_type_id: str = "obj", proximity_threshold: float = 30.0):
         self.obj_type_id = obj_type_id
+        self.proximity_threshold = proximity_threshold
 
-    def encode(self, batch_node_features: torch.Tensor, proximity_threshold: float = 50) -> Batch:
-        # remove the values from batch_node_features that have all zeros in the vector
-        # batch_node_features = batch_node_features[~torch.all(batch_node_features == 0, dim=1)]
+    def encode(self, batch_node_features: torch.Tensor) -> Batch:
+        # remove vectors which have all zeros
+        batch_node_features = batch_node_features[batch_node_features.sum(dim=1) != 0]
         batch_data = []
         batch_size = batch_node_features.size(0)
 
@@ -428,7 +449,7 @@ class GraphEncoderFreeway:
 
             for i in chicken_indices:
                 for j in lane_indices:
-                    if abs(node_features[i, 1] - node_features[j, 1]) <= proximity_threshold:
+                    if node_features[i, 1] == node_features[j, 1]:  # Check if y-coordinates are the same
                         atom_features = torch.zeros((2, object_feature_length)).tolist()
                         graph.add_node(atom_index, type="ChickenOnLane", features=atom_features)
                         graph.add_edge(i, atom_index, position=0)
@@ -440,7 +461,7 @@ class GraphEncoderFreeway:
 
             for i in car_indices:
                 for j in lane_indices:
-                    if abs(node_features[i, 1] - node_features[j, 1]) <= proximity_threshold:
+                    if node_features[i, 1] == node_features[j, 1]:  # Check if y-coordinates are the same
                         atom_features = torch.zeros((2, object_feature_length)).tolist()
                         graph.add_node(atom_index, type="CarOnLane", features=atom_features)
                         graph.add_edge(i, atom_index, position=0)
@@ -455,11 +476,24 @@ class GraphEncoderFreeway:
                 graph.add_edge(lane_indices[i + 1], atom_index, position=1)
                 atom_index += 1
 
+            # Add LaneNearPlayer atoms and edges based on distance
+            for i in chicken_indices:
+                for j in lane_indices:
+                    distance = np.linalg.norm(node_features[i, :2] - node_features[j, :2])
+                    if distance <= self.proximity_threshold:
+                        atom_features = torch.zeros((2, object_feature_length)).tolist()
+                        graph.add_node(atom_index, type="LaneNearPlayer", features=atom_features)
+                        graph.add_edge(i, atom_index, position=0)
+                        graph.add_edge(j, atom_index, position=1)
+                        atom_index += 1
+            visualize_graph(graph)
+            print_graph_details(graph)
             batch_data.append(graph)
+            
 
         return Batch.from_data_list(self.to_pyg_data(batch_data))
 
-    def to_pyg_data(self, batch_graphs: List[nx.Graph]) -> List[HeteroData]:
+    def to_pyg_data(self, batch_graphs: list[nx.Graph]) -> list[HeteroData]:
         data_list = []
 
         for graph in batch_graphs:
@@ -513,18 +547,22 @@ class GraphEncoderFreeway:
                 data[edge_type].edge_index = edge_tensor
 
             data_list.append(data)
-
+        
         return data_list
+
+    
 class GraphEncoderFreewayProximity:
     def __init__(self, obj_type_id: str = "obj"):
         self.obj_type_id = obj_type_id
 
-    def encode(self, batch_node_features: torch.Tensor, proximity_threshold: float = 50) -> Batch:
+    def encode(self, batch_node_features: torch.Tensor, proximity_threshold: float = 20) -> Batch:
+        # Filter out all-zero vectors across the batch
+        non_zero_mask = torch.any(batch_node_features != 0, dim=-1)  # Shape [batch_size, num_nodes, feature_size] -> [batch_size, num_nodes]
         batch_data = []
-        batch_size = batch_node_features.size(0)
 
-        for b in range(batch_size):
-            node_features = batch_node_features[b]
+        for b in range(batch_node_features.size(0)):
+            # Apply mask to current batch's node features
+            node_features = batch_node_features[b][non_zero_mask[b]]
             num_nodes = node_features.size(0)
             graph = nx.Graph()
 
@@ -537,14 +575,24 @@ class GraphEncoderFreewayProximity:
 
             if player_indices:
                 player_index = player_indices[0]
-                # Add edges between the player node and other cars and lanes
+                # Add edges based on proximity threshold
                 for i in range(num_nodes):
                     if i != player_index:
                         dist = torch.norm(node_features[player_index, :2] - node_features[i, :2]).item()
                         if dist <= proximity_threshold:
                             graph.add_edge(player_index, i)
-                            graph.add_edge(i, player_index)  # Add reverse edge for bidirectionality
-
+                            graph.add_edge(i, player_index)  # Adding bidirectional edges
+            #add edges for car on a particular lane
+            lane_indices = [i for i in range(num_nodes) if node_features[i, -2] == 1]
+            # car_indices = [i for i in range(num_nodes) if node_features[i, -1] == 1]
+            # for i in car_indices:
+            #     for j in lane_indices:
+            #         if node_features[i, 1] == node_features[j, 1]:  # Check if y-coordinates are the same
+            #             graph.add_edge(i, j)
+            #             graph.add_edge(j, i)
+            for i in range(len(lane_indices) - 1):
+                graph.add_edge(lane_indices[i], lane_indices[i+1])
+                graph.add_edge(lane_indices[i+1], lane_indices[i])
             batch_data.append(graph)
 
         return Batch.from_data_list(self.to_pyg_data(batch_data))
@@ -556,38 +604,24 @@ class GraphEncoderFreewayProximity:
             data = HeteroData()
             node_index_mapping = defaultdict(dict)
             obj_features = []
-            edge_dict = defaultdict(list)
-
-            current_obj_features = []
 
             for node, attrs in graph.nodes(data=True):
                 node_type = attrs['type']
                 features = torch.tensor(attrs['features'])
-                if node_type == self.obj_type_id:
-                    node_index_mapping[node_type][node] = len(current_obj_features)
-                    current_obj_features.append(features)
-
-            if current_obj_features:
-                obj_features.append(torch.stack(current_obj_features))
+                node_index = len(obj_features)
+                node_index_mapping[node_type][node] = node_index
+                obj_features.append(features)
 
             if obj_features:
-                data[self.obj_type_id].x = torch.cat(obj_features)
+                data[self.obj_type_id].x = torch.stack(obj_features)
 
             for src, dst in graph.edges:
                 src_type = graph.nodes[src]['type']
                 dst_type = graph.nodes[dst]['type']
-                edge_type = (src_type, 'to', dst_type)
-
                 src_idx = node_index_mapping[src_type][src]
                 dst_idx = node_index_mapping[dst_type][dst]
-                edge_dict[edge_type].append((src_idx, dst_idx))
-                # Add reverse edges for bidirectionality
-                reverse_edge_type = (dst_type, 'to', src_type)
-                edge_dict[reverse_edge_type].append((dst_idx, src_idx))
-
-            for edge_type, edges in edge_dict.items():
-                edge_tensor = torch.tensor(edges, dtype=torch.long).t().contiguous()
-                data[edge_type].edge_index = edge_tensor
+                edge_type = (src_type, 'to', dst_type)
+                data[edge_type].edge_index = torch.tensor([[src_idx, dst_idx], [dst_idx, src_idx]], dtype=torch.long)
 
             data_list.append(data)
 
diff --git a/games/encoder/__pycache__/GraphEncoder.cpython-310.pyc b/games/encoder/__pycache__/GraphEncoder.cpython-310.pyc
index b9ee24e..fe14a12 100644
Binary files a/games/encoder/__pycache__/GraphEncoder.cpython-310.pyc and b/games/encoder/__pycache__/GraphEncoder.cpython-310.pyc differ
diff --git a/games/freeway/__pycache__/run_supervised_gnn.cpython-310.pyc b/games/freeway/__pycache__/run_supervised_gnn.cpython-310.pyc
index 1e98d70..368d6ac 100644
Binary files a/games/freeway/__pycache__/run_supervised_gnn.cpython-310.pyc and b/games/freeway/__pycache__/run_supervised_gnn.cpython-310.pyc differ
diff --git a/games/freeway/freeway_envs/__pycache__/freeway_env.cpython-310.pyc b/games/freeway/freeway_envs/__pycache__/freeway_env.cpython-310.pyc
index 07abeb1..cb5d7fe 100644
Binary files a/games/freeway/freeway_envs/__pycache__/freeway_env.cpython-310.pyc and b/games/freeway/freeway_envs/__pycache__/freeway_env.cpython-310.pyc differ
diff --git a/games/freeway/freeway_envs/freeway_env.py b/games/freeway/freeway_envs/freeway_env.py
index ae1b6af..c2805b6 100644
--- a/games/freeway/freeway_envs/freeway_env.py
+++ b/games/freeway/freeway_envs/freeway_env.py
@@ -507,8 +507,8 @@ class FreewayEnvConstant(gym.Env):
         # lane_combinations = [[60, 90], [60, 90, 120], [60, 120]]
         # # 
         #lane_combinations =[[50,80,120],[50,80],[80,120],[50,120]]
-        #lane_combinations = [[30, 60, 90, 120, 150]]
-        lane_combinations = [[50, 80, 120]]
+        lane_combinations = [[30, 60, 90, 120, 150]]
+        #lane_combinations = [[50, 80, 120]]
         number_cars = [10,15]
         car_speeds = [3]
 
@@ -873,8 +873,8 @@ class FreewayEnvDynamic(gym.Env):
             return self.get_object_data(), {}
 
     def _update_environment(self):
-        lane_combinations = [[50, 80, 120], [50, 80], [80, 120]]
-        number_cars = [5, 10]
+        lane_combinations = [[50, 80, 120], [50, 80], [50, 120]]
+        number_cars = [5,10]
         car_speeds = [3, 4]
 
         self.car_speed = random.choice(car_speeds)
@@ -888,7 +888,7 @@ class FreewayEnvDynamic(gym.Env):
         for _ in range(self.max_cars):
             lane = random.choice(self.lanes)
             if lane_car_count[lane] < 5:
-                car = {'x': random.randint(0, self.window_width - self.car_width), 'lane': lane, 'speed': lane_speeds[lane]}
+                car = {'x': random.randint(0, self.window_width - self.car_width), 'lane': lane, 'speed': random.randint(1, 2)}
                 self.cars.append(car)
                 lane_car_count[lane] += 1
 
@@ -896,22 +896,23 @@ class FreewayEnvDynamic(gym.Env):
         reward = -0.5
         self.episode_step += 1
         player_pos = self.player_rect.y
-        if self.steps_since_collision < self.collision_wait_steps:
-            self.steps_since_collision += 1
-        else:
-            if action == 1:  # Up
-                self.player_rect.y = max(0, self.player_rect.y - 5)
-            elif action == 2:  # Down
-                self.player_rect.y = min(self.window_height - self.player_height, self.player_rect.y + 5)
-            self.player_speed = self.player_rect.y - player_pos
+        # if self.steps_since_collision < self.collision_wait_steps:
+        #     self.steps_since_collision += 1
+        #else:
+        if action == 1:  # Up
+            self.player_rect.y = max(0, self.player_rect.y - 5)
+        elif action == 2:  # Down
+            self.player_rect.y = min(self.window_height - self.player_height, self.player_rect.y + 5)
+        self.player_speed = self.player_rect.y - player_pos
         for car in self.cars:
             car['x'] += car['speed']
             if car['x'] > self.window_width:
                 car['x'] = 0
-                # car['speed'] = random.randint(1, 2)
+                # car['speed'] = random.randint(1, 2)}
 
         hit = any(self.player_rect.colliderect(pygame.Rect(car['x'], car['lane'], self.car_width, self.car_height)) for car in self.cars)
         if hit:
+            #reward -= 1
             self.player_rect.y = self.window_height - self.player_height - 10
             self.steps_since_collision = 0  # Reset the counter on collision
 
@@ -953,10 +954,12 @@ class FreewayEnvDynamic(gym.Env):
 
     def get_object_data(self):
         objects = [
-            [self.player_rect.x, self.player_rect.y, self.player_speed , 0, 1, 0, 0],  # Player
-        ]
+            [self.player_rect.x, self.player_rect.y, self.player_speed, 0, 1, 0, 0],  # Player
+            
+        ] 
+        # add lanes
         for lane in self.lanes:
-            objects.append([self.window_width // 2, lane, 0, 0, 0, 1, 0])
+            objects.append([self.window_width//2, lane, 0, 0, 0, 1, 0])
 
         for i, car in enumerate(self.cars):
             objects.append([car['x'], car['lane'], car['speed'], 0, 0, 0, 1])
@@ -965,9 +968,11 @@ class FreewayEnvDynamic(gym.Env):
              objects.append([0, 0, 0, 0, 0, 0, 0])
 
         return torch.tensor(objects, dtype=torch.float32)
-
     def render(self, mode='human'):
+
         self.window.blit(self.background_image, (0, 0))
+        # set frame rate
+        self.clock.tick(30)
         for car in self.cars:
             self.window.blit(self.car_image, (car['x'], car['lane']))
         self.window.blit(self.player_image, (self.player_rect.x, self.player_rect.y))
@@ -998,10 +1003,12 @@ class FreewayEnvDynamic(gym.Env):
 
 
 if __name__=="__main__":
-    env = FreewayEnvTest(render_mode='human', observation_type='graph')
-
+    env = FreewayEnvDynamic(render_mode='human', observation_type='graph')
+    #env = FreewayEnvDynamic(render_mode='human', observation_type='pixel')
     #model = PPO.load("ppo_freeway_pixel")
     model = PPO.load("logs/Freeway-GNN-training/best_model.zip")
+    #model = PPO.load("ppo_freeway_curriculum_3.zip")
+    #model = PPO.load("freeway-gnn-eval.zip")
     #model = PPO.load("ppo_custom_heterognn")
     obs,_ = env.reset()
     done = False
@@ -1012,12 +1019,12 @@ if __name__=="__main__":
         done = False
         while not done:
             action, _ = model.predict(obs)
-            # if action == 2 or action == 0:
-            #     print(f"Player speed: {env.player_speed}")
+            if action == 2 or action == 0:
+                 print(f"Player speed: {env.player_speed}")
             #action = env.action_space.sample()
             obs, reward, done, _,_ = env.step(action)
             total_reward += reward
-            pygame.time.delay(50)
+            #pygame.time.delay(50)
             env.render()
 
         print(f"Total reward: {total_reward}")
diff --git a/games/freeway/run_supervised_gnn.py b/games/freeway/run_supervised_gnn.py
index 4cfdf0a..ae2f0c3 100644
--- a/games/freeway/run_supervised_gnn.py
+++ b/games/freeway/run_supervised_gnn.py
@@ -235,7 +235,7 @@ log_dir = "./logs/Freeway-GNN-training/"
 
 def make_env(lanes, max_cars, car_speed, seed=0, rank=None):
     def _init():
-        env = FreewayEnvTest( render_mode='human', observation_type='graph')
+        env = FreewayEnvDynamic( render_mode='human', observation_type='graph')
         monitor_path = os.path.join(log_dir, f"monitor_{rank}.csv")
         os.makedirs(log_dir, exist_ok=True)  # Create log directory if it doesn't exist
         env = Monitor(env, filename=monitor_path, allow_early_resets=True)
@@ -274,14 +274,15 @@ policy_kwargs = dict(
     features_extractor_kwargs=dict(
         features_dim=64,
         hidden_size=64,
-        num_layer=10,
+        num_layer=2,
         obj_type_id='obj',
-        arity_dict={'ChickenOnLane':2, 'CarOnLane':2, 'LaneNextToLane':2},
+        arity_dict={'ChickenOnLane':2, 'CarOnLane':2, 'LaneNextToLane':2, 'LaneNearPlayer':2},
         game = 'freeway'
     ),
 )
 
 # # Create the PPO model with the custom feature extractor
+#model = PPO('MlpPolicy', envs, verbose=2)
 model = PPO('MlpPolicy', envs, policy_kwargs=policy_kwargs, verbose=2)
 #model = PPO.load("logs/Freeway-GNN-training/best-threelanes-constant-speed.zip") 
 #model.set_env(envs)
diff --git a/games/model/__pycache__/hetero_gnn.cpython-310.pyc b/games/model/__pycache__/hetero_gnn.cpython-310.pyc
index e525d14..7312902 100644
Binary files a/games/model/__pycache__/hetero_gnn.cpython-310.pyc and b/games/model/__pycache__/hetero_gnn.cpython-310.pyc differ
diff --git a/games/model/__pycache__/hetero_message_passing.cpython-310.pyc b/games/model/__pycache__/hetero_message_passing.cpython-310.pyc
index 8b90800..47b2f7f 100644
Binary files a/games/model/__pycache__/hetero_message_passing.cpython-310.pyc and b/games/model/__pycache__/hetero_message_passing.cpython-310.pyc differ
diff --git a/games/model/__pycache__/policy.cpython-310.pyc b/games/model/__pycache__/policy.cpython-310.pyc
index 9044bb9..4609be9 100644
Binary files a/games/model/__pycache__/policy.cpython-310.pyc and b/games/model/__pycache__/policy.cpython-310.pyc differ
diff --git a/games/model/hetero_gnn.py b/games/model/hetero_gnn.py
index c1d824c..41630b0 100644
--- a/games/model/hetero_gnn.py
+++ b/games/model/hetero_gnn.py
@@ -122,35 +122,79 @@ class HeteroGNN(torch.nn.Module):
 
 
 class HeteroGCN(torch.nn.Module):
-    def __init__(self, in_channels_dict, out_channels):
+    def __init__(self, in_channels_dict, hidden_channels, out_channels, num_layers=2):
         super(HeteroGCN, self).__init__()
-        self.convs = torch.nn.ModuleDict()
-        for obj_type, in_channels in in_channels_dict.items():
-            self.convs[obj_type] = GCNConv(in_channels, out_channels)
+        self.layers = torch.nn.ModuleList()
+        for i in range(num_layers):
+            layer = torch.nn.ModuleDict()
+            for obj_type, in_channels in in_channels_dict.items():
+                if i == 0:
+                    layer[obj_type] = GCNConv(in_channels, hidden_channels)
+                else:
+                    layer[obj_type] = GCNConv(hidden_channels, hidden_channels if i < num_layers - 1 else out_channels)
+            self.layers.append(layer)
+        self.global_pool = pyg.nn.GlobalAttention(gate_nn=torch.nn.Sequential(
+            torch.nn.Linear(out_channels, hidden_channels),
+            torch.nn.ReLU(),
+            torch.nn.Linear(hidden_channels, 1)
+        ))
 
     def forward(self, data):
-        for obj_type in data.node_types:
-            x = data[obj_type].x
-            edge_index = data[obj_type, 'to', obj_type].edge_index
-            x = self.convs[obj_type](x, edge_index)
-            x = F.relu(x)
-            data[obj_type].x = x
+        for layer in self.layers:
+            new_x_dict = {}
+            for obj_type, conv in layer.items():
+                x = data[obj_type].x
+                edge_index = data[obj_type, 'to', obj_type].edge_index
+                x = conv(x, edge_index)
+                new_x_dict[obj_type] = F.relu(x) if conv != layer[obj_type] else x
+            for obj_type in new_x_dict:
+                data[obj_type].x = new_x_dict[obj_type]
+
+        # Global pooling across all node types
+        x_all = torch.cat([data[obj_type].x for obj_type in data.node_types], dim=0)
+        x_global = self.global_pool(x_all, None)  # Assuming no batch information is available
+
+        return x_global
 
-        return data
 
 class HeteroGAT(torch.nn.Module):
-    def __init__(self, in_channels_dict, out_channels):
+    def __init__(self, in_channels_dict, hidden_channels, out_channels, num_layers=2):
         super(HeteroGAT, self).__init__()
-        self.convs = torch.nn.ModuleDict()
-        for obj_type, in_channels in in_channels_dict.items():
-            self.convs[obj_type] = GATConv(in_channels, out_channels)
-
-    def forward(self, data):
+        self.layers = torch.nn.ModuleList()
+        for i in range(num_layers):
+            layer = torch.nn.ModuleDict()
+            for obj_type, in_channels in in_channels_dict.items():
+                if i == 0:
+                    layer[obj_type] = GATConv(in_channels, hidden_channels)
+                else:
+                    layer[obj_type] = GATConv(hidden_channels, hidden_channels if i < num_layers - 1 else out_channels)
+            self.layers.append(layer)
+        self.global_pool = pyg.nn.GlobalAttention(gate_nn=torch.nn.Sequential(
+            torch.nn.Linear(out_channels, hidden_channels),
+            torch.nn.ReLU(),
+            torch.nn.Linear(hidden_channels, 1)
+        ))
+
+    def forward(self, data, batch_dict):
+        for layer in self.layers:
+            new_x_dict = {}
+            for obj_type, conv in layer.items():
+                x = data[obj_type].x
+                edge_index = data[obj_type, 'to', obj_type].edge_index
+                x = conv(x, edge_index)
+                new_x_dict[obj_type] = F.relu(x) if conv != layer[obj_type] else x
+            for obj_type in new_x_dict:
+                data[obj_type].x = new_x_dict[obj_type]
+
+        # Collect all node embeddings and corresponding batch indices for global pooling
+        x_all = []
+        batch_all = []
         for obj_type in data.node_types:
-            x = data[obj_type].x
-            edge_index = data[obj_type, 'to', obj_type].edge_index
-            x = self.convs[obj_type](x, edge_index)
-            x = F.relu(x)
-            data[obj_type].x = x
+            x_all.append(data[obj_type].x)
+            batch_all.append(batch_dict[obj_type])
+
+        x_all = torch.cat(x_all, dim=0)
+        batch_all = torch.cat(batch_all, dim=0)
+        x_global = self.global_pool(x_all, batch_all)
 
-        return data
\ No newline at end of file
+        return x_global.view(-1, x_all.size(1))  # Ensuring the shape is [batch_size, embedding_size]
diff --git a/games/model/policy.py b/games/model/policy.py
index 2d9ea67..9657977 100644
--- a/games/model/policy.py
+++ b/games/model/policy.py
@@ -10,8 +10,8 @@ from gymnasium import spaces
 import torch
 import torch.nn as nn
 from stable_baselines3.common.torch_layers import BaseFeaturesExtractor
-from games.encoder.GraphEncoder import HeteroGNNEncoderPong, GraphEncoderFreeway, GraphEncoderPacman, GraphEncoderBreakout
-from games.model.hetero_gnn import HeteroGNN
+from games.encoder.GraphEncoder import HeteroGNNEncoderPong, GraphEncoderFreeway, GraphEncoderPacman, GraphEncoderBreakout, GraphEncoderFreewayProximity
+from games.model.hetero_gnn import HeteroGAT, HeteroGCN, HeteroGNN
 import torch_geometric as pyg
 from games.model.cnn_model import CNNgame
 import time
@@ -21,17 +21,20 @@ class CustomHeteroGNN(BaseFeaturesExtractor):
         if game == 'pong':
             self.encoder = HeteroGNNEncoderPong()
         elif game == 'freeway':
-            self.encoder = GraphEncoderFreeway() 
+            self.encoder = GraphEncoderFreewayProximity() 
         elif game == 'pacman':
             self.encoder = GraphEncoderPacman()
-            self.model = HeteroGNN(hidden_size, num_layer, obj_type_id, arity_dict, input_size=8)
+            #self.model = HeteroGNN(hidden_size, num_layer, obj_type_id, arity_dict, input_size=8)
         elif game == 'breakout':
             self.encoder = GraphEncoderBreakout()
         
         # set device to mps if available
         #self.device = torch.device("mps" if torch.backends.mps.is_available() else "cpu")
         self.device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
-        self.model = HeteroGNN(hidden_size, num_layer, obj_type_id, arity_dict, input_size=7).to(self.device)
+        in_channels_dict = {'obj': 7}  # Update with actual sizes
+
+        self.model = HeteroGAT(in_channels_dict, hidden_channels=64, out_channels=64, num_layers=2)
+        #self.model = HeteroGGNN(hidden_size, num_layer, obj_type_id, arity_dict, input_size=7).to(self.device)
 
 
     def forward(self, observations):
@@ -41,8 +44,9 @@ class CustomHeteroGNN(BaseFeaturesExtractor):
         # if observations.shape[0] >1:
         #     print(f"Time to encode: {time.time() - start}")
 
-        pyg_data = pyg_data.to(self.device) 
-        obj_emb = self.model(pyg_data.x_dict, pyg_data.edge_index_dict, pyg_data.batch_dict)
+        #pyg_data = pyg_data.to(self.device) 
+        #obj_emb = self.model(pyg_data.x_dict, pyg_data.edge_index_dict, pyg_data.batch_dict)
+        obj_emb = self.model(pyg_data, pyg_data.batch_dict)
         # Flatten or pool the embeddings if necessary to match the expected features_dim
         return obj_emb
 
diff --git a/logs/Freeway-GNN-training/best_model.zip b/logs/Freeway-GNN-training/best_model.zip
index 41369ae..81c1814 100644
Binary files a/logs/Freeway-GNN-training/best_model.zip and b/logs/Freeway-GNN-training/best_model.zip differ
diff --git a/logs/Freeway-GNN-training/monitor_0.csv.monitor.csv b/logs/Freeway-GNN-training/monitor_0.csv.monitor.csv
index 48dc5a8..824810d 100644
--- a/logs/Freeway-GNN-training/monitor_0.csv.monitor.csv
+++ b/logs/Freeway-GNN-training/monitor_0.csv.monitor.csv
@@ -1,33 +1,2 @@
-#{"t_start": 1722538752.493021, "env_id": "None"}
+#{"t_start": 1722686902.245413, "env_id": "None"}
 r,l,t
--1024.5,2049,71.239367
--1024.0,2048,134.616509
--1062.5,2125,194.623773
--974.0,2008,254.629861
--975.5,2011,315.903349
--979.5,2079,375.907573
--828.5,2017,441.423629
--814.0,2048,508.913724
--604.0,2048,575.270796
--544.0,2048,643.680322
--334.0,2048,712.710081
--304.0,2048,777.798116
--214.0,2048,842.636858
--409.0,2078,902.640861
--259.0,2018,964.275593
--274.0,2048,1024.99233
--386.0,2152,1084.995663
--222.0,1944,1149.779988
--154.0,2048,1211.176031
--364.0,2048,1273.837377
--244.0,2048,1340.420099
--244.0,2048,1406.638014
--64.0,2048,1471.509567
--214.0,2048,1542.852116
--124.0,2048,1608.17152
--364.0,2048,1673.883667
--124.0,2048,1740.133424
--274.0,2048,1811.237361
--304.0,2048,1877.319834
--244.0,2048,1945.873189
--64.0,2048,2011.776907
diff --git a/ppo_custom_heterognn_Freeway.zip b/ppo_custom_heterognn_Freeway.zip
index 2ab5bea..4df678f 100644
Binary files a/ppo_custom_heterognn_Freeway.zip and b/ppo_custom_heterognn_Freeway.zip differ
diff --git a/wandb/debug-internal.log b/wandb/debug-internal.log
index 1fdb4ed..b8b7aa3 120000
--- a/wandb/debug-internal.log
+++ b/wandb/debug-internal.log
@@ -1 +1 @@
-run-20240801_205915-0qp8eooh/logs/debug-internal.log
\ No newline at end of file
+run-20240803_140825-lyb929qz/logs/debug-internal.log
\ No newline at end of file
diff --git a/wandb/debug.log b/wandb/debug.log
index bf33139..f607940 120000
--- a/wandb/debug.log
+++ b/wandb/debug.log
@@ -1 +1 @@
-run-20240801_205915-0qp8eooh/logs/debug.log
\ No newline at end of file
+run-20240803_140825-lyb929qz/logs/debug.log
\ No newline at end of file
diff --git a/wandb/latest-run b/wandb/latest-run
index bda545f..deb7da8 120000
--- a/wandb/latest-run
+++ b/wandb/latest-run
@@ -1 +1 @@
-run-20240801_205915-0qp8eooh
\ No newline at end of file
+run-20240803_140825-lyb929qz
\ No newline at end of file
